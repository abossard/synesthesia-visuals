// GLSLWrapperGenerator.swift - Generates GLSL wrappers for Shadertoy shaders
// Implements: [prefix shim] + [common.glsl] + [original GLSL] + [suffix shim]

import Foundation

// MARK: - GLSL Wrapper Generator

/// Generates GLSL wrapper files for Shadertoy-style shaders
/// The wrapper adds compatibility macros and uniform declarations
/// without modifying the original shader source
public struct GLSLWrapperGenerator {

    // MARK: - Configuration

    /// GLSL version for SPIR-V compilation
    public let glslVersion: String

    /// Enable compatibility mode for older Shadertoy shaders
    public let compatibilityMode: Bool

    /// Channel sampler types for this pass
    public let channelTypes: [SamplerType]

    public init(
        glslVersion: String = "450",
        compatibilityMode: Bool = true,
        channelTypes: [SamplerType] = [.texture2D, .texture2D, .texture2D, .texture2D]
    ) {
        self.glslVersion = glslVersion
        self.compatibilityMode = compatibilityMode
        self.channelTypes = channelTypes
    }

    // MARK: - Wrapper Generation

    /// Generate complete wrapped GLSL source
    /// - Parameters:
    ///   - originalSource: Original shader source (untouched)
    ///   - commonSource: Optional common.glsl content
    /// - Returns: Wrapped GLSL ready for SPIR-V compilation
    public func generateWrapper(
        originalSource: String,
        commonSource: String? = nil
    ) -> String {
        var output = ""

        // Prefix shim
        output += generatePrefixShim()

        // Common code if present
        if let common = commonSource {
            output += "\n// === COMMON CODE ===\n"
            output += common
            output += "\n// === END COMMON CODE ===\n\n"
        }

        // Original shader source (verbatim)
        output += "// === ORIGINAL SHADER ===\n"
        output += originalSource
        output += "\n// === END ORIGINAL SHADER ===\n"

        // Suffix shim (main wrapper)
        output += generateSuffixShim(originalSource: originalSource)

        return output
    }

    // MARK: - Prefix Shim

    /// Generate the prefix shim with version, uniforms, and compatibility macros
    private func generatePrefixShim() -> String {
        var shim = """
        #version \(glslVersion)

        // ============================================
        // Shadertoy Runtime - GLSL Wrapper Prefix
        // Generated by ShadertoyRuntime
        // ============================================

        // Precision qualifiers (required for GLSL ES compatibility)
        #ifdef GL_ES
        precision highp float;
        precision highp int;
        #endif

        // ============================================
        // Shadertoy Uniform Block
        // ============================================
        layout(std140, binding = 0) uniform ShadertoyUniforms {
            vec3 _iResolution;       // Viewport resolution (pixels)
            float _pad0;

            float _iTime;            // Shader playback time (seconds)
            float _iTimeDelta;       // Time since last frame
            int _iFrame;             // Frame count
            float _iFrameRate;       // Render frame rate

            vec4 _iMouse;            // Mouse: xy=current, zw=click position
            vec4 _iDate;             // (year, month, day, seconds)

            float _iSampleRate;      // Audio sample rate
            vec3 _pad1;

            float _iChannelTime0;    // Channel playback times
            float _iChannelTime1;
            float _iChannelTime2;
            float _iChannelTime3;

            vec3 _iChannelResolution0;
            float _pad2;
            vec3 _iChannelResolution1;
            float _pad3;
            vec3 _iChannelResolution2;
            float _pad4;
            vec3 _iChannelResolution3;
            float _pad5;

            // Extended audio uniforms (VJ-specific)
            vec4 _iAudioBands;       // bass, lowMid, mid, highs
            vec4 _iAudioEnergy;      // energyFast, energySlow, beat, level
            vec4 _iKick;             // kickEnv, kickPulse, bpm, confidence
        };

        // ============================================
        // Uniform Macro Mappings (preserve original identifiers)
        // ============================================
        #define iResolution _iResolution
        #define iTime _iTime
        #define iTimeDelta _iTimeDelta
        #define iFrame _iFrame
        #define iFrameRate _iFrameRate
        #define iMouse _iMouse
        #define iDate _iDate
        #define iSampleRate _iSampleRate
        #define iChannelTime float[4](_iChannelTime0, _iChannelTime1, _iChannelTime2, _iChannelTime3)
        #define iChannelResolution vec3[4](_iChannelResolution0, _iChannelResolution1, _iChannelResolution2, _iChannelResolution3)

        // Extended audio macros (VJ-specific)
        #define iAudioBands _iAudioBands
        #define iAudioEnergy _iAudioEnergy
        #define iKick _iKick
        #define iBass _iAudioBands.x
        #define iLowMid _iAudioBands.y
        #define iMid _iAudioBands.z
        #define iHighs _iAudioBands.w
        #define iLevel _iAudioEnergy.w
        #define iBeat _iAudioEnergy.z
        #define iKickEnv _iKick.x

        """

        // Channel samplers
        shim += "\n// ============================================\n"
        shim += "// Channel Samplers (binding = 1-4)\n"
        shim += "// ============================================\n"

        for (index, samplerType) in channelTypes.enumerated() {
            let binding = index + 1
            switch samplerType {
            case .texture2D:
                shim += "layout(binding = \(binding)) uniform sampler2D iChannel\(index);\n"
            case .textureCube:
                shim += "layout(binding = \(binding)) uniform samplerCube iChannel\(index);\n"
            }
        }

        // Compatibility macros
        if compatibilityMode {
            shim += """

            // ============================================
            // Compatibility Macros (Shadertoy/WebGL style)
            // ============================================

            // Legacy Shadertoy uniform names
            #define iGlobalTime iTime
            #define time iTime
            #define resolution iResolution.xy
            #define mouse iMouse.xy / iResolution.xy

            // WebGL/GLSL ES texture functions
            #define texture2D texture
            #define textureCube texture
            #define texture2DLod textureLod
            #define textureCubeLod textureLod

            // Legacy GLSL functions
            #ifndef GL_ES
            #define lowp
            #define mediump
            #define highp
            #endif

            // Common helper macros
            #define PI 3.14159265359
            #define TAU 6.28318530718
            #define E 2.71828182846

            // Saturate (clamp 0-1)
            #define saturate(x) clamp(x, 0.0, 1.0)

            // Rotation matrix helper
            mat2 rot2D(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c, -s, s, c);
            }

            // Hash functions (common in Shadertoy)
            float hash11(float p) {
                p = fract(p * 0.1031);
                p *= p + 33.33;
                p *= p + p;
                return fract(p);
            }

            float hash21(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash22(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.xx + p3.yz) * p3.zy);
            }

            """
        }

        // Fragment output
        shim += """

        // ============================================
        // Fragment Output
        // ============================================
        layout(location = 0) out vec4 fragColor;

        """

        return shim
    }

    // MARK: - Suffix Shim

    /// Generate the suffix shim with main() wrapper
    private func generateSuffixShim(originalSource: String) -> String {
        // Check if shader defines its own main()
        let hasMain = detectMainFunction(in: originalSource)

        // Check if shader defines mainImage()
        let hasMainImage = detectMainImageFunction(in: originalSource)

        var shim = "\n// ============================================\n"
        shim += "// Shadertoy Runtime - GLSL Wrapper Suffix\n"
        shim += "// ============================================\n\n"

        if hasMain {
            // Shader has its own main() - rename it and call
            shim += """
            // Original shader defines main() - wrapping as _original_main()
            // Note: The original main() should be renamed via preprocessing
            // For now, we assume the shader uses gl_FragColor

            #ifdef GL_FRAG_COLOR_COMPAT
            // Legacy gl_FragColor compatibility
            void main() {
                _original_main();
                fragColor = gl_FragColor;
            }
            #endif

            """
        } else if hasMainImage {
            // Standard Shadertoy format - call mainImage
            shim += """
            // Shadertoy mainImage() wrapper
            void main() {
                // Use gl_FragCoord to match Shadertoy semantics
                // gl_FragCoord.xy is the center of the pixel (e.g., 0.5, 0.5 for first pixel)
                mainImage(fragColor, gl_FragCoord.xy);
            }

            """
        } else {
            // No recognized entry point - try to handle common patterns
            shim += """
            // No mainImage() found - checking for legacy patterns
            // This shader may use gl_FragColor directly or have non-standard entry

            #ifndef SHADERTOY_NO_MAIN
            void main() {
                // Fallback: simple pass-through for shaders with unknown structure
                // This may need adjustment based on the specific shader
                vec2 fragCoord = gl_FragCoord.xy;
                vec2 uv = fragCoord / iResolution.xy;

                // Default output if shader structure is unrecognized
                fragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);
            }
            #endif

            """
        }

        return shim
    }

    // MARK: - Source Analysis

    /// Detect if source contains a main() function definition
    private func detectMainFunction(in source: String) -> Bool {
        // Look for: void main() or void main(void)
        let patterns = [
            "void\\s+main\\s*\\(\\s*\\)",
            "void\\s+main\\s*\\(\\s*void\\s*\\)"
        ]

        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: []),
               regex.firstMatch(in: source, options: [], range: NSRange(source.startIndex..., in: source)) != nil {
                return true
            }
        }
        return false
    }

    /// Detect if source contains a mainImage() function definition
    private func detectMainImageFunction(in source: String) -> Bool {
        // Look for: void mainImage(out vec4 ..., in vec2 ...)
        // Allow various parameter styles
        let patterns = [
            "void\\s+mainImage\\s*\\(",
            "void\\s+mainimage\\s*\\("  // case insensitive fallback
        ]

        for pattern in patterns {
            if let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]),
               regex.firstMatch(in: source, options: [], range: NSRange(source.startIndex..., in: source)) != nil {
                return true
            }
        }
        return false
    }
}

// MARK: - Legacy Shader Converter

/// Converts legacy GLSL shaders (non-Shadertoy) to compatible format
public struct LegacyShaderConverter {

    /// Convert a legacy shader that uses main() and gl_FragColor
    /// to Shadertoy-compatible format with mainImage()
    public static func convertLegacyToMainImage(source: String) -> String {
        var converted = source

        // Replace gl_FragColor with fragColor parameter
        converted = converted.replacingOccurrences(of: "gl_FragColor", with: "_fragColor")

        // Replace gl_FragCoord with fragCoord parameter
        converted = converted.replacingOccurrences(of: "gl_FragCoord", with: "_fragCoord")

        // Look for void main() and convert to mainImage
        let mainPattern = "void\\s+main\\s*\\(\\s*(void)?\\s*\\)"
        if let regex = try? NSRegularExpression(pattern: mainPattern, options: []) {
            converted = regex.stringByReplacingMatches(
                in: converted,
                options: [],
                range: NSRange(converted.startIndex..., in: converted),
                withTemplate: "void mainImage(out vec4 _fragColor, in vec2 _fragCoord)"
            )
        }

        return converted
    }

    /// Detect shader type based on content analysis
    public enum ShaderType {
        case shadertoy       // Uses mainImage()
        case legacyGLSL      // Uses main() and gl_FragColor
        case glslES          // Has precision qualifiers
        case webGL           // Uses texture2D/textureCube
        case unknown
    }

    public static func detectShaderType(source: String) -> ShaderType {
        if source.contains("mainImage") {
            return .shadertoy
        }
        if source.contains("#ifdef GL_ES") || source.contains("precision mediump") || source.contains("precision highp") {
            return .glslES
        }
        if source.contains("texture2D") || source.contains("textureCube") {
            return .webGL
        }
        if source.contains("gl_FragColor") {
            return .legacyGLSL
        }
        return .unknown
    }
}

// MARK: - Wrapper Generator Factory

/// Factory for creating configured wrapper generators
public struct WrapperGeneratorFactory {

    /// Create a generator for a specific pass configuration
    public static func generator(for pass: PassConfig) -> GLSLWrapperGenerator {
        let channelTypes = pass.channels.map { $0.samplerType }
        return GLSLWrapperGenerator(
            glslVersion: "450",
            compatibilityMode: true,
            channelTypes: channelTypes
        )
    }

    /// Create a generator with default settings
    public static func defaultGenerator() -> GLSLWrapperGenerator {
        GLSLWrapperGenerator()
    }
}
