#define PROCESSING_COLOR_SHADER
// RingLattice_Kaleidoscope - Mirrored, symmetrical, hypnotic pattern
// Based on RGBringlattice3D

#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

uniform float bass;
uniform float mid;
uniform float highs;
uniform float level;
uniform float kickEnv;
uniform float speed;

#define PI 3.14159265359
#define TAU 6.28318530718

// Kaleidoscope fold - creates N-way symmetry
vec2 kaleidoscope(vec2 uv, float segments) {
    float angle = atan(uv.y, uv.x);
    float radius = length(uv);
    
    // Fold into segment
    float segmentAngle = TAU / segments;
    angle = mod(angle, segmentAngle);
    
    // Mirror within segment
    if(angle > segmentAngle * 0.5) {
        angle = segmentAngle - angle;
    }
    
    return vec2(cos(angle), sin(angle)) * radius;
}

float pointToGrille(vec3 pp, float b, float r) {
    vec3 p = abs(pp);
    vec3 pa = mod(p, 2.0 * b) - b;
    
    float dy = length(vec2(b - length(pa.xz), pa.y));
    float dz = length(vec2(b - length(pa.xy), pa.z));
    float ddy = length(vec3(pa.x, pa.z, pa.y * step(0.0, pa.y)));
    float ddz = length(vec3(pa.x, pa.y, pa.z * step(0.0, pa.z)));
    
    return min(min(dy, ddy), min(dz, ddz)) - r;
}

vec3 rotor(vec3 p, float speed) {
    float co = time * speed;
    float c = cos(co);
    float s = sin(co);
    mat3 mz = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);
    
    co = time * speed * 0.7;
    c = cos(co);
    s = sin(co);
    mat3 mx = mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);
    
    return p * mz * mx;
}

float render(vec3 org, vec3 dir) {
    float lambda = 0.0;
    float lamb = 100.0;
    float couleur = 0.0;
    float glow = 0.0;
    
    float cellSize = 8.0 + sin(time * 0.5) * 2.0;
    float ringSize = 0.5 + bass * 0.3;
    
    for(int i = 0; i < 80; i++) {
        vec3 pos = org + lambda * dir;
        lamb = pointToGrille(rotor(pos, 0.15), cellSize, ringSize);
        lambda += lamb * 0.85;
        couleur += 0.012;
        glow += 0.03 / (1.0 + lamb * lamb * 8.0);
        if(abs(lamb) < 0.001 || lambda > 200.0) break;
    }
    return clamp(couleur * 1.3 + glow * 0.4, 0.0, 1.0);
}

// Rainbow palette
vec3 rainbow(float t) {
    return 0.5 + 0.5 * cos(TAU * (t + vec3(0.0, 0.33, 0.67)));
}

void main(void) {
    vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
    uv.x *= resolution.x / resolution.y;
    
    // Kaleidoscope segments (changes slowly)
    float segments = 6.0 + floor(sin(time * 0.1) * 2.0 + 2.0);
    segments = max(segments, 3.0);
    
    // Apply kaleidoscope to UV
    vec2 kaleido = kaleidoscope(uv, segments);
    
    // Rotate the kaleidoscope pattern
    float rotAngle = time * 0.1 + bass * 0.5;
    float c = cos(rotAngle);
    float s = sin(rotAngle);
    kaleido = vec2(kaleido.x * c - kaleido.y * s, kaleido.x * s + kaleido.y * c);
    
    float t = time * (0.4 + speed * 0.3);
    
    // Camera moves through structure
    vec3 eye = vec3(
        sin(t * 0.3) * 100.0,
        cos(t * 0.25) * 100.0,
        t * 40.0
    );
    
    // Ray direction from kaleidoscoped UV
    vec3 dir = normalize(rotor(vec3(kaleido.x, kaleido.y, 1.2), 0.15));
    
    float coul = render(eye, dir);
    
    // Rainbow color based on angle and depth
    float colorAngle = atan(uv.y, uv.x) / TAU + 0.5;
    colorAngle += time * 0.05;  // Slowly rotate colors
    
    vec3 rainbowCol = rainbow(colorAngle + coul * 0.3);
    
    // Mix with structure depth
    vec3 color = rainbowCol * (1.0 - coul * 0.5);
    
    // Add white highlights
    color += vec3(1.0) * pow(1.0 - coul, 4.0) * 0.5;
    
    // Center glow
    float centerGlow = exp(-length(uv) * 3.0);
    color += rainbowCol * centerGlow * 0.5;
    
    // Pulse on kick
    color *= 1.0 + kickEnv * 0.4;
    
    // Mandala-style ring highlights
    float rings = sin(length(uv) * 30.0 - time * 2.0);
    rings = smoothstep(0.8, 1.0, rings);
    color += rainbow(colorAngle + 0.5) * rings * 0.2 * (1.0 - coul);
    
    // Vignette
    float vignette = 1.0 - pow(length(uv) * 1.0, 2.0);
    color *= max(vignette, 0.0);
    
    // Saturation boost
    float grey = dot(color, vec3(0.299, 0.587, 0.114));
    color = mix(vec3(grey), color, 1.3);
    
    gl_FragColor = vec4(color, 1.0);
}
