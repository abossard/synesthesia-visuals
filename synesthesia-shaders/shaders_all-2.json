{
 "userName": "abossard",
 "date": "2025-11-26T07:17:43.777Z",
 "numShaders": 37,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "WfdyW4",
    "date": "0",
    "viewed": 0,
    "name": "Fork Chimera's  abossard 201",
    "description": "Single pass fluid simulation with vorticity confinement and coloring. Fullscreen recommended (it's fast enough)\n\nclick and drag to add force and color. (mouse only define in common tab)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "simulation",
     "fluid",
     "curl",
     "smoke",
     "dust",
     "navierstokes",
     "vorticity"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Chimera's Breath\n// by nimitz 2018 (twitter: @stormoid)\n// https://www.shadertoy.com/view/4tGfDW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSimulation code is in the \"common\" tab (and extra defines)\n\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n    if (fragCoord.y < 1. || fragCoord.y >= (iResolution.y-1.))\n        col = vec4(0);\n    fragColor = col;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n/*\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\n#define dt 0.15\n#define USE_VORTICITY_CONFINEMENT\n//#define MOUSE_ONLY\n\n//Recommended values between 0.03 and 0.2\n//higher values simulate lower viscosity fluids (think billowing smoke)\n#define VORTICITY_AMOUNT 0.11\n\nfloat mag2(vec2 p){return dot(p,p);}\nvec2 point1(float t) {\n    t *= 0.62;\n    return vec2(0.12,0.5 + sin(t)*0.2);\n}\nvec2 point2(float t) {\n    t *= 0.62;\n    return vec2(0.88,0.5 + cos(t + 1.5708)*0.2);\n}\n\nvec4 solveFluid(sampler2D smp, vec2 uv, vec2 w, float time, vec3 mouse, vec3 lastMouse)\n{\n\tconst float K = 0.2;\n\tconst float v = 0.55;\n    \n    vec4 data = textureLod(smp, uv, 0.0);\n    vec4 tr = textureLod(smp, uv + vec2(w.x , 0), 0.0);\n    vec4 tl = textureLod(smp, uv - vec2(w.x , 0), 0.0);\n    vec4 tu = textureLod(smp, uv + vec2(0 , w.y), 0.0);\n    vec4 td = textureLod(smp, uv - vec2(0 , w.y), 0.0);\n    \n    vec3 dx = (tr.xyz - tl.xyz)*0.5;\n    vec3 dy = (tu.xyz - td.xyz)*0.5;\n    vec2 densDif = vec2(dx.z ,dy.z);\n    \n    data.z -= dt*dot(vec3(densDif, dx.x + dy.y) ,data.xyz); //density\n    vec2 laplacian = tu.xy + td.xy + tr.xy + tl.xy - 4.0*data.xy;\n    vec2 viscForce = vec2(v)*laplacian;\n    data.xyw = textureLod(smp, uv - dt*data.xy*w, 0.).xyw; //advection\n    \n    vec2 newForce = vec2(0);\n    #ifndef MOUSE_ONLY\n    #if 1\n    newForce.xy += 0.75*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0001);\n    newForce.xy -= 0.75*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0001);\n    #else\n    newForce.xy += 0.9*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0002);\n    newForce.xy -= 0.9*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0002);\n    #endif\n    #endif\n    \n    if (mouse.z > 1. && lastMouse.z > 1.)\n    {\n        vec2 vv = clamp(vec2(mouse.xy*w - lastMouse.xy*w)*400., -6., 6.);\n        newForce.xy += .001/(mag2(uv - mouse.xy*w)+0.001)*vv;\n    }\n    \n    data.xy += dt*(viscForce.xy - K/dt*densDif + newForce); //update velocity\n    data.xy = max(vec2(0), abs(data.xy)-1e-4)*sign(data.xy); //linear velocity decay\n    \n    #ifdef USE_VORTICITY_CONFINEMENT\n   \tdata.w = (tr.y - tl.y - tu.x + td.x);\n    vec2 vort = vec2(abs(tu.w) - abs(td.w), abs(tl.w) - abs(tr.w));\n    vort *= VORTICITY_AMOUNT/length(vort + 1e-9)*data.w;\n    data.xy += vort;\n    #endif\n    \n    data.y *= smoothstep(.5,.48,abs(uv.y-0.5)); //Boundaries\n    \n    data = clamp(data, vec4(vec2(-10), 0.5 , -10.), vec4(vec2(10), 3.0 , 10.));\n    \n    return data;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1.)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1.)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1.)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n//shader incoming relating to this palette\nvec3 getPalette(float x, vec3 c1, vec3 c2, vec3 p1, vec3 p2)\n{\n    float x2 = fract(x/2.0);\n    x = fract(x);   \n    mat3 m = mat3(c1, p1, c2);\n    mat3 m2 = mat3(c2, p2, c1);\n    float omx = 1.0-x;\n    vec3 pws = vec3(omx*omx, 2.0*omx*x, x*x);\n    return clamp(mix(m*pws, m2*pws, step(x2,0.5)),0.,1.);\n}\n\nvec4 pal(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.2, 0.5, .7), vec3(.9, 0.4, 0.1), vec3(1., 1.2, .5), vec3(1., -0.4, -.0));\n    return vec4(pal, 1.);\n}\n\nvec4 pal2(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.4, 0.3, .5), vec3(.9, 0.75, 0.4), vec3(.1, .8, 1.3), vec3(1.25, -0.1, .1));\n    return vec4(pal, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec2 velo = textureLod(iChannel0, uv, 0.).xy;\n    vec4 col = textureLod(iChannel1, uv - dt*velo*w*3., 0.); //advection\n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = vec4(0);\n    vec4 lastMouse = texelFetch(iChannel1, ivec2(0,0), 0).xyzw;\n    \n    if (iMouse.z > 1. && lastMouse.z > 1.)\n    {\n        float str = smoothstep(-.5,1.,length(mo - lastMouse.xy/iResolution.xy));   \n        col += str*0.0009/(pow(length(uv - mo),1.7)+0.002)*pal2(-iTime*0.7);\n    }\n    \n    #ifndef MOUSE_ONLY\n    col += .0025/(0.0005+pow(length(uv - point1(iTime)),1.75))*dt*0.12*pal(iTime*0.05 - .0);\n    col += .0025/(0.0005+pow(length(uv - point2(iTime)),1.75))*dt*0.12*pal2(iTime*0.05 + 0.675);\n    #endif\n    \n    \n    if (iFrame < 20)\n    {\n        col = vec4(0.);\n    }\n    \n    col = clamp(col, 0.,5.);\n    col = max(col - (0.0001 + col*0.004)*.5, 0.); //decay\n    \n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = iMouse;\n\n    fragColor = col;\n    \n}\n",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tctyW7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Cartoon ri abossard 706",
    "description": "try a cartoon style with a kind of adaptative anti-aliasing.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "cartoon",
     "edge"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// based on one desert canyon of the fantastic Shane shader\n\n// best for small size\n#define WITH_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 res = texture(iChannel0, uv);\n\n#ifdef WITH_AA\n    \n    vec3 dp = vec3(1./iResolution.xy, 0);\n    float needAA = 0.;\n    for (int j=-1; j<3; j++) {\n        for (int i=-1; i<3; i++) {\n            needAA += texture(iChannel0, uv).w;\n        }\n    }\n    \n    // Antialising only on edges and big curvature\n    if (needAA > .5) {\n    \tfor (int k=0; k<4; k++)\n        \tres += render(fragCoord+.66*vec2(k%2-1,k/2-1)-.33, iTime, iResolution.xy, iChannel0);\n        res /= 5.;\n    }\n    \n#endif\n\n    fragColor = res;\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = render(fragCoord.xy, iTime, iResolution.xy, iChannel0);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n#define FAR 400.\n//#define PRECISE\n//#define WITH_AO\n\n#define ID_SKY    0.\n#define ID_SHIP   1.\n#define ID_GROUND 2.\n#define ID_PATH   3.\n\n#define EDGE_WIDTH 5e-3\n\n\n\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\nconst float freqA = .34*.15/3.75;\nconst float freqB = .25*.25/2.75;\nconst float ampA = 20.;\nconst float ampB = 4.;\n\n\nvec3 gRO;\nmat3 gbaseShip;\n\nfloat gedge;\nfloat gedge2;\nfloat glastt;\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*.5;\n\ta = mod(a,angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    return vec2(ampA*sin(z * freqA) + 2.*cos(z*.0252) - 1., 10.+ ampB*cos(z * freqB) * (.5+ .5*sin(z*0.0015)));\n}\n\nfloat sdGround(in vec3 p, sampler2D channel){\n    p += vec3(0,2,0);\n    float tx1 = 2.5*textureLod(channel, p.xz/28. + p.xy/100., 0.).x;\n    float tx2 = 2.*textureLod(channel, p.xy/vec2(31.,15.), 0.).x;\n  \tfloat tx = tx1 - tx2;\n\n    vec3 q = p*.125;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n\n    float d = p.y + h*6.;\n    q = p*.07125;\n    float h3 = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    float d3 = p.y + h3*22.-22.;\n  \n    q = sin(p*.5 + h);\n    float h2 = q.x*q.y*q.z;\n  \n    vec3 p0 = p;\n    p.xy -= path(p.z);\n    \n    float dPath = length(p.xy)-38.;\n    \n    vec3 p1 = p;\n    float tnl = 1.5 - length(p.xy*vec2(1.2, 1.96)) + h2;// - (1. - tx)*.25;\n    \n    p.xz = mod(p0.xz+150.,300.)-150.; \n    \n    float dCaps = mix(999., sdVerticalCapsule(p+vec3(45,60,50), 130., 15.) + tx1, step(2500., p0.z));\n    \n    p = p1;\n    p.z = mod(p.z+250.,500.)-250.; \n    \n    float dGate = sdTorus(p.yzx-vec3(25,25,5), vec2(50.,15.))+tx1;\n\tdCaps = mix(dCaps, dGate, step(4600., p0.z));\n            \n    p.xz = mod(p0.xz+450.,900.)-450.;\n    float dCaps2 = sdVerticalCapsule(p+vec3(20,55,0), 100., 30.) + .5*tx;\n        \n    float d4 = smaxP(d - tx*.5+ tnl*.4, .2*tnl, 8.);\n    d3 = mix(d3, d4, smoothstep(.5,1., .5+.5*(sin(p0.z*.001-.8))));\n    \n    d = min(dCaps, smaxP(d3, d4, 10.));\n    float dend = max(p0.y-60., -dPath-.5*tx+.25*tx2);\n    d = mix(d, dend, smoothstep(7000.,9000., p0.z)*smoothstep(12000.,9000., p0.z));\n    d = smaxP(-dCaps2, d,2.);\n            \n    return d;\n}\n\nfloat sdShip(in vec3 p0) {\n    p0 -= vec3(4,0,0);\n    float d = length(p0) -4.;\n    \n    vec3 pRot = p0;\n    pModPolar(pRot.zy, 16.);\n    pRot.x = abs(pRot.x);\n    d = min(d, length(pRot-vec3(2.6,0,3.))-.2);\n\td = min(d, sdBox(pRot-vec3(4.5,0,.8), vec3(.5,.1,.2)));    \n    \n    vec3 p = p0;\n    p.zy = abs(p.zy);\n    p -= vec3(-5.6,2.5,2);\n    pR45(p.yz);\n    pR45(p.xy);\n    return min(d, sdBox(p, vec3(1.,2,.2)));  \n}\n\nfloat sdPath(in vec3 p0) {\n    float d2 = length(path(p0.z)-p0.xy)-.5;\n    return max(d2, -gRO.z + p0.z);\n}\n\nfloat map(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0-vec3(0,0,0));\n    return min(dPath,d); \n}\n\nfloat mapFull(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0);\n    return min(sdShip((p0-gRO)*gbaseShip),min(dPath,d)); \n}\n\nvec2 min2(vec2 c0, vec2 c1) {\n\treturn c0.x < c1.x ? c0 : c1;\n}\n\nvec2 mapColor(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0, channel);\n    float dPath = sdPath(p0);\n    return min2(vec2(sdShip((p0-gRO)*gbaseShip), ID_SHIP), \n                min2(vec2(dPath, ID_PATH), vec2(d, ID_GROUND))); \n}\n\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd, sampler2D channel){\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro, channel);\n    float sgn = sign(d);\n\n    float lastDistEval = 1e10, lastt = 0.;\n\tvec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n\n    for (int i=0; i<164; i++){\n        if (sign(d) != sgn || d < 0.01 || t > FAR) break;\n \n        told = t;    \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \n        d = map(rd*t + ro, channel);\n        d = min(d, sdShip(rdShip*t + roShip));\n        \n        if (d < lastDistEval) {\n            lastt = t;\n            lastDistEval = d;\n        } else {\n            if (d > lastDistEval + 0.0001 &&  lastDistEval/mix(30., lastt, smoothstep(FAR*.75, FAR*.9, t)) < EDGE_WIDTH) {\n            \tgedge = 1.f;\n                if (glastt == 0.) glastt = lastt;\n            }\n            if (d > lastDistEval + 0.0001 && (lastDistEval < EDGE_WIDTH*40. || lastDistEval/lastt < EDGE_WIDTH*2.)) {\n            \tgedge2 = 1.f;\n            }\n\t\t\t//edge = smoothstep(-EDGE_WIDTH,-EDGE_WIDTH*.5f,-(lastDistEval/100.));///lastt));\n\t\t}\n    }\n    if (glastt == 0.)  glastt = lastt;\n\n#ifdef PRECISE\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro, channel));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++) { \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro, channel);\n            if (abs(d) < 0.001)break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid;       \n    }\n#endif\n    \n    return min(t, FAR);\n}\n\n\nvec3 normal(in vec3 p, sampler2D channel) {  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*mapFull(p + e.yxx, channel) + e.xxy*mapFull(p + e.xxy, channel) + \n\t\t\t\t\t e.xyx*mapFull(p + e.xyx, channel) + e.yyy*mapFull(p + e.yyy, channel) );   \n}\n\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k, sampler2D channel){\n    ro += rd*hash(ro);\n    vec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n    float shade = 1.;\n    const int maxIterationsShad = 24; \n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = min(map(ro + rd*dist, channel), sdShip(roShip + dist*rdShip));\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .2, stepDist*2.);\n        if (abs(h)<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n#ifdef WITH_AO\n\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist, sampler2D channel )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n    for(float i=1.; i< nbIte+.5; i++){\n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - mapFull( p + n*l, channel))/(1. + l);\n    }\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n#endif\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\n\treturn vec3(smoothstep(.97,1.,max(dot(rd, sunDir), 0.)));\n}\n\n// Curve function, by Shadertoy user, Nimitz.\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curve(in vec3 p, sampler2D channel){\n    const float eps = .05, amp = 4., ampInit = .5;\n\tvec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    float t1 = mapFull(p + e.yxx, channel), t2 = mapFull(p + e.xxy, channel);\n    float t3 = mapFull(p + e.xyx, channel), t4 = mapFull(p + e.yyy, channel);\n    return clamp((t1 + t2 + t3 + t4 - 4.*mapFull(p, channel))*amp + ampInit, 0., 1.);\n}\n\n\nvec4 render(in vec2 fragCoord, float Time, vec2 Resolution, sampler2D channel){\n        \n    gedge = 0.;\n    gedge2= 0.;\n    glastt = 0.;\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - Resolution.xy*.5)/Resolution.y;\n    float dBox = sdBox(u, vec2(.5*Resolution.x/Resolution.y-.1,.4));\n    \n    vec3 col = vec3(.2);\n   \tfloat needAA = 0.; \n    float ed = 0., ed2 = 0., lastt1 = 0.;\n    \n    if (dBox <0.){\t\n\n        // Camera Setup.\n        vec3 lookAt = vec3(0, 0, Time*100.);  // \"Look At\" position.\n        vec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\n\n        lookAt.xy += path(lookAt.z);\n        ro.xy += path(ro.z);\n        lookAt.y -= .071;\n\n        // Using the above to produce the unit ray-direction vector.\n        float FOV = 3.14159/2.; // FOV - Field of view.\n\n        vec3 forward = normalize(lookAt - ro);\n        vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n\n        right.xy *= rot2( path(lookAt.z).x/64.);\n        right.xy *= rot2( -.7*cos(Time*.12));\n\n\n        vec3 up = cross(forward, right);\n\n        vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n        vec3 lp = vec3(.5*FAR, FAR, 1.5*FAR) + vec3(0, 0, ro.z);\n\n\n        gRO = ro+vec3(0,0,1);\n        gRO.xy = path(gRO.z);\n        vec3 p2 = vec3(path(gRO.z+1.), gRO.z+1.);\n\n        forward = normalize(p2 - gRO);\n        right = normalize(vec3(forward.z, 0, -forward.x )); \n        right.xy *= rot2( path(lookAt.z).x/32.);\n        up = cross(forward, right);\n        gbaseShip = mat3(forward, up, right);\n\n        float dist = mix(35., 15., smoothstep(7000.,8500., gRO.z));\n        dist = mix(dist, 45., smoothstep(10000.,12000., gRO.z));\n        ro += (dist*(.5+.5*cos(.31*Time))+2.)*vec3(.3,1,-2.);\n        ro.x += .3*dist*cos(.31*Time);\n\n        float t = logBisectTrace(ro, rd, channel);\n        ed = gedge; ed2 = gedge2;  lastt1 = glastt;\n\n\n        vec3 sky = getSky(ro, rd, normalize(lp - ro));\n\n        col = sky;\n\n        vec2 mapCol = mapColor(ro+t*rd, channel);\n\n        vec3 sp;\n\t\tfloat cur;\n        if (t < FAR){\n\n            sp = ro+t*rd; // Surface point.\n            vec3 sn = normal(sp, channel); // Surface normal.\n            vec3 ld = lp-sp;\n            ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n            float shd = softShadow(sp, ld, .1, FAR, 8., channel); // Shadows.\n            cur = curve(sp, channel);\n            float curv = cur*.9 +.1; // Surface curvature.\n#ifdef WITH_AO\n            float ao = calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#else\n            float ao = 1.;//calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#endif\n            float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n            float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\n            float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n            float amb = fre*fre2 + .06*ao;        \n\n            col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n            col = pow(col, vec3(1.5));\n            col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;      \n        }\n\n        col = pow(max(col, 0.), vec3(.75));\n\n        u = fragCoord/Resolution.xy;\n\n        vec3 cGround = vec3(248,210,155)/256.;\n        vec3 cSky = vec3(177,186,213)/256.;\n\n        if (t < FAR){\n            \n            vec3 cFill;\n            if (mapCol.y == ID_PATH) {\n                cFill = vec3(1,.01,0.01);//mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(12.0,12.1,(sp.y)));\n            }\n            else if (mapCol.y == ID_SHIP) {\n               \tvec3 pShip = (sp-gRO)*gbaseShip;\n                cFill = mix(vec3(0,1,1),vec3(.7),smoothstep(.0,.1, pShip.x-1.3));\n            } else {\n                cFill = mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(.0,.1,sp.y-8.));\n                cFill = mix(cFill, vec3(1,0,0), .4*smoothstep(1000.,3000., gRO.z));\n            \tvec3 col3 = cos(sp.y*.08+1.1)*clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n\n                cFill = mix(cFill, col3, .5*smoothstep(6000.,8500., gRO.z));\n            }\n\n            col = mix(cFill,cSky,t/FAR)*(.5+.5*smoothstep(.4,.5,length(col)));\n            col = mix(col, vec3(.0), ed);\n            col = mix(vec3(0), col, .5+.5*smoothstep(.4,.41,cur)); // Surface curvature.;\n            ed2 += cur<.35?1.:0.;\n\n        } else {\n            col = mix(cSky*abs(1.-rd.y),vec3(1),smoothstep(1.3,1.4,length(col)));\n            col = mix(col, vec3(.1), ed);\n        \tfloat sun = max(dot(rd, normalize(lp - ro)), 0.); // Sun strength.\n\t\t\tcol = mix(vec3(0), col, smoothstep(.09/Resolution.y,.2/Resolution.y, abs(sun-.9892)));//.zyx;\t\n        }\n\n        col = mix(col, cSky*abs(1.-rd.y), sqrt(smoothstep(FAR - (ed <0. ? 200. : 100.), FAR, lastt1)));\n        \n    }  \n    \n    // BD frame\n    col = mix(col, vec3(.2),smoothstep(.0,1./Resolution.y,dBox));\n    col = mix(col, vec3(0.),smoothstep(1./Resolution.y,.0,abs(dBox)-.005));\n\n    return vec4(clamp(col, 0., 1.), ed2);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftyW7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Aurora Ter abossard 726",
    "description": "doodle",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "terrain",
     "glow",
     "aurora",
     "fly",
     "terrestris"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define R(a) mat2(cos((a) + vec4(0,-11, 11,0)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    float speed = -3.5;\n    float pos = iTime * speed;\n\n    float focal = 2.;\n\n    float r = 200.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3( cos(pos/r)*r, 3. + sin(.1*pos), sin(pos/r)*r );\n\n    rd.xy *= R(.3*sin(.1*iTime)+.4);\n\n    rd.xz *= R(pos/r);\n\n    float hash = fract(631.123123*sin(float(iFrame)+length(uv)*331.+dot(uv, vec2(111.123123,171.3123))));\n    float t = 1.+.2*hash;\n    const float phi = sqrt(5.)*.5+.5;\n    float daynight = smoothstep(-.6, .6, sin(iTime*.05));\n    for(int i = 0; i < 99 && t < 1e3; i++)\n    {\n        vec3 p = rd * t + ro;\n        vec3 q = p;\n\n        for(float j = 0.01; j < 11.; j+=j)\n        {\n            p.xz *= R(phi * 3.1415);\n            p.xz -= 1.3*j;\n            p += .4*j * cos(p.zxy/j);\n        }\n\n        float sdf = max(p.y+1.5, 0.); // length(p) - 1.;\n        \n        sdf = mix(sdf, min(sdf,7.-.2*p.y), daynight);\n        float dt = abs(sdf) * .3 + 1e-3;\n\n        vec3 cmap = (1. + -cos(p.y*.3+ .1 * (t+1.5*iTime) + vec3(1,2,3)  + length(p-ro)*.1) ) * exp2(2.65*tanh(q.y*.55)-1.55) * exp2(-.01*t);\n        color += cmap * dt / (sdf * sdf + 1.);\n\n        t += dt;\n    }\n\n    color = tanh(.0025*color*color);\n    color = pow(color, vec3(1. / 2.2));\n    \n    //color = color*0. + hash;\n    fragColor = vec4(color, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wftyW7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Lover 2 abossard 734",
    "description": "Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3  \ntrying to mimic Karthik Dondeti https://twitter.com/d0ndeti/status/1479814051366539264 series.\n\n- A:use close curve, starting as circle. k partics\n- I: basic drawing\nstill, there are crossings.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "paper",
     "reproduction",
     "dondeti"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  Q = B( U ).zzzz; }\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n#define  k ( .02 * R.x*R.y )\nMain \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    if ( i < k ) {\n    for (float j = -20.; j <= 20.; j++) \n        if (j!=0.) {//  && j+i>=0. && j+i<R.x*R.y) {\n        vec4 a = A(_21(mod(i+j,k)));\n        //if (j!=0. && j+i>=0. && j+i<R.x*R.y) {\n        //vec4 a = A(_21(i+j));\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n    }\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f -= 100.*d.w*u;\n    }\n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw += f-.03*Q.zw;\n    Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n    Q.zw = mix(Q.zw,m.zw,0.1);\n    Q.xy = mix(Q.xy,m.xy,0.01);\n    if (Q.x>R.x)Q.y=.5*R.y,Q.z=-10.;\n    if (Q.x<0.)Q.y=.5*R.y,Q.z=10.;\n    }\n     if (iFrame < 1 || keyClick(32)) {\n        if ( i > k ) \n          Q = vec4(R+i,0,0); \n        else\n          Q = vec4(.5*R + .25*R.y* cos( 6.28*i/k + vec2(0,1.57)), 0,0 );\n    //  Q = vec4(i-.5*R.x*R.y,.5*R.y,0,0);\n    }\n    \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-7.));\n    XY(U,Q,vec4(Q.x+7.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    vec4 a3 = A(_21(Q.x-1.));\n    float l1 = sg(U,a1.xy,a2.xy);\n    float l2 = sg(U,a1.xy,a3.xy);\n    float l = min(l1,l2);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    Q = mix(Q,D(U),.5);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcdyW7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Shader Art abossard 760",
    "description": "[url]https://youtu.be/f4s1h2YETNY[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fractal",
     "sdf",
     "tutorial",
     "intro",
     "repetition",
     "code",
     "youtube",
     "tuto",
     "creative"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wctyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork flow by st abossard 441",
    "description": "flow by stream function. see [url]https://hal.inria.fr/inria-00345903/[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fluid",
     "flow",
     "short",
     "incompressible",
     "stream",
     "streamfunction"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\n\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\n\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\n\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n    \nfloat f(float d) { // interpolation function\n    float t = 1.-d/r;\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU /= iResolution.y;\n    \n    // --- interpolate stream function : add(distance to border, stream at border)\n    float t = iTime,wf=0.,wT=0., w; \n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\n    w = wf / wT;                               // stream field\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\n    \n    // --- display\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\n\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Smooth Vor abossard 446",
    "description": "A method to produce smooth, precise contour lines... but it's really just an excuse to make a colorful, moving abstract picture. :)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "abstract",
     "smooth",
     "contour"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\n\tSmooth Voronoi Contours\n\t-----------------------\n\n\tUsing a numerical gradient to produce smooth \"fract\" contours on 2D Voronoi.\n\n\tShadertoy user \"drone1\" was kind enough to help me problem shoot some AA code\n\tyesterday on an image similar to this one, but I wanted to produce it without\n\tAA for realtime usage. There might be better methods, but this is the one I\n\tchose. It's partly based off of IQ's \"Ellipse - Distance Estimation\" example.\n\n\tIf you press pause, you should notice that the contour lines are smooth and \n\tprecise, regardless of the shape of the curve.\n\t\n\tFor anyone wondering, the weird abstract image is just an amalgamation of two \n\tlayers of smooth 2D Voronoi and an old concentric circle trick. In pseudo code:\n\n\tfloat val = Vor(p*freq)*A1 + Vor(p*freq*3.)*A2;\n\tval = clamp(cos(val*freq2*PI)*contrast, 0., 1.);\n\n    See IQ's distance estimation example for a good explanation regarding the \n\tgradient related contour snippet:\n\n    Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    There's an accompanying articles, which is really insightful here:\n    https://iquilezles.org/articles/distance\n\n\tAnother example using the technique.\n\t2D Noise Contours - Shane\n\thttps://www.shadertoy.com/view/XdcGzB\n\n*/\n\n// Glossy version. It's there to show that the method works with raised surfaces too.\n//#define GLOSSY\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    return cos(p*6.283 + iTime)*.5;\n    //return abs(fract(p+ iTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iTime))*.5; // Bounce.\n\n}\n\n// Smooth Voronoi. I'm not sure who came up with the original, but I think IQ\n// was behind this particular algorithm. It's just like the regular Voronoi\n// algorithm, but instead of determining the minimum distance, you accumulate\n// values - analogous to adding metaball field values. The result is a nice\n// smooth pattern. The \"falloff\" variable is a smoothing factor of sorts.\n//\nfloat smoothVoronoi(vec2 p, float falloff) {\n\n    vec2 ip = floor(p); p -= ip;\n\t\n\tfloat d = 1., res = 0.0;\n\t\n\tfor(int i = -1; i <= 2; i++) {\n\t\tfor(int j = -1; j <= 2; j++) {\n            \n\t\t\tvec2 b = vec2(i, j);\n            \n\t\t\tvec2 v = b - p + hash22(ip + b);\n            \n\t\t\td = max(dot(v,v), 1e-4);\n\t\t\t\n\t\t\tres += 1.0/pow( d, falloff );\n\t\t}\n\t}\n\n\treturn pow( 1./res, .5/falloff );\n}\n\n// 2D function we'll be producing the contours for. \nfloat func2D(vec2 p){\n\n    \n    float d = smoothVoronoi(p*2., 4.)*.66 + smoothVoronoi(p*6., 4.)*.34;\n    \n    return sqrt(d);\n    \n}\n\n// Smooth fract function. A bit hacky, but it works. Handy for all kinds of things.\n// The final value controls the smoothing, so to speak. Common sense dictates that \n// tighter curves, require more blur, and straighter curves require less. The way \n// you do that is by passing in the function's curve-related value, which in this case\n// will be the function value divided by the length of the function's gradient.\n//\n// IQ's distance estimation example will give you more details:\n// Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n// There's an accompanying article, which is really insightful, here:\n// https://iquilezles.org/articles/distance\nfloat smoothFract(float x, float sf){\n \n    x = fract(x); return min(x, x*(1.-x)*sf);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n\n    // Standard epsilon, used to determine the numerical gradient. \n    vec2 e = vec2(0.001, 0); \n\n    // The 2D function value. In this case, it's a couple of layers of 2D simplex-like noise.\n    // In theory, any function should work.\n    float f = func2D(uv); // Range [0, 1]\n    \n    // Length of the numerical gradient of the function above. Pretty standard. Requires two extra function\n    // calls, which isn't too bad.\n    float g = length( vec2(f - func2D(uv-e.xy), f - func2D(uv-e.yx)) )/(e.x);\n   \n    // Dividing a constant by the length of its gradient. Not quite the same, but related to IQ's \n    // distance estimation example: Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    g = 1./max(g, 0.001);\n    \n    // This is the crux of the shader. Taking a function value and producing some contours. In this case,\n    // there are twelve. If you don't care about aliasing, it's as simple as: c = fract(f*12.);\n    // If you do, and who wouldn't, you can use the following method. For a quick explanation, refer to the \n    // \"smoothFract\" function or look up a concetric circle (bullseye) function.\n    //\n    // For a very good explanation, see IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    //\n    // There's an accompanying articles, which is really insightful, here:\n\t// https://iquilezles.org/articles/distance\n    //\n    float freq = 12.; \n    // Smoothing factor. Hand picked. Ties in with the frequency above. Higher frequencies\n    // require a lower value, and vice versa.\n    float smoothFactor = iResolution.y*0.0125; \n    \n    #ifdef GLOSSY\n    float c = smoothFract(f*freq, g*iResolution.y/16.); // Range [0, 1]\n    //float c = fract(f*freq); // Aliased version, for comparison.\n    #else\n    float c = clamp(cos(f*freq*3.14159*2.)*g*smoothFactor, 0., 1.); // Range [0, 1]\n    //float c = clamp(cos(f*freq*3.14159*2.)*2., 0., 1.); // Blurry contours, for comparison.\n    #endif\n    \n    \n    // Coloring.\n    //\n    // Convert \"c\" above to the greyscale and green colors.\n    vec3 col = vec3(c);\n    vec3 col2 = vec3(c*0.64, c, c*c*0.1);\n    \n    #ifdef GLOSSY\n    col = mix(col, col2, -uv.y + clamp(fract(f*freq*0.5)*2.-1., 0., 1.0));\n    #else\n    col = mix(col, col2, -uv.y + clamp(cos(f*freq*3.14159)*2., 0., 1.0));\n    #endif\n    \n    // Color in a couple of thecontours above. Not madatory, but it's pretty simple, and an interesting \n    // way to pretty up functions. I use it all the time.\n    f = f*freq;\n    \n    #ifdef GLOSSY\n    if(f>8. && f<9.) col *= vec3(1, 0, .1);\n    #else\n    if(f>8.5 && f<9.5) col *= vec3(1, 0, .1);\n    #endif \n   \n    \n\t// Since we have the gradient related value, we may as well use it for something. In this case, we're \n    // adding a bit of highlighting. It's calculated for the contourless noise, so doesn't match up perfectly,\n    // but it's good enough. Comment it out to see the texture on its own.  \n    #ifdef GLOSSY\n    col += g*g*g*vec3(.3, .5, 1)*.25*.25*.25*.1;\n    #endif \n    \n    \n    //col = c * vec3(g*.25); // Just the function and gradient. Has a plastic wrap feel.\n\t\n    // Done.\n\tfragColor = vec4( sqrt(clamp(col, 0., 1.)), 1.0 );\n\t\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wftyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork a pixel fl abossard 448",
    "description": "A cellular automaton that simulates a compressible pixel fluid inside an arbitrary container.\nSimulation consists of two main passes:\n(1) averaging mass while keeping total mass constant\n(2) enforcing a vertical pressure gradient",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "pixel",
     "fluid",
     "sandbox",
     "diffusion",
     "cellular",
     "gravity",
     "ca",
     "automaton",
     "boundary",
     "compressible",
     "conditions",
     "communicating",
     "vessels"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// IMAGE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(floor(fragCoord));\n    ivec2 c = ivec2(floor(iResolution.xy/2.0));\n    v = (v-c)/SCALE+c;\n    vec4 a = texelFetch(iChannel0, v, 0);\n    //fragColor = vec4(a.w > 0.5 ? vec3(0.5) : a.z > 0.0 ? mix(vec3(0,1,1),vec3(0,0,0.5),a.z) : vec3(0),1);\n    //fragColor = vec4(a.w > 0.5 ? vec3(0.5) : a.z > 0.0 ? pow(vec3(.1, .7, .8), vec3(4.*a.z)) : vec3(0),1); // palette: https://www.shadertoy.com/view/MlcGD7 natural colors (fire, water,...) by FabriceNeyret2\n    fragColor = vec4(a.w > 0.5 ? mix(vec3(0.3),vec3(0.5),hash(vec2(v))) : a.z > 0.0 ? pow(vec3(.1, .7, .8), vec3(4.*a.z)) : vec3(0),1); // palette: https://www.shadertoy.com/view/MlcGD7 natural colors (fire, water,...) by FabriceNeyret2\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// BUFFER A\n\n#define KEY_SPACE 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(floor(fragCoord));\n    ivec2 c = ivec2(floor(iResolution.xy / 2.0));\n\n    ivec2 m = ivec2(floor(iMouse.xy));\n    m = (m-c)/SCALE+c;\n\n    // PRESS SPACE TO RESTART\n    bool restart = texelFetch(iChannel3, ivec2(KEY_SPACE,0), 0).x > 0.0;\n    if(iFrame <= 0 || restart || any(lessThan(iChannelResolution[0].xy,vec2(1)))) // Apparently iChannelResolution is more reliable than textureSize: https://shadertoyunofficial.wordpress.com/2019/01/26/classical-corner-cases/\n    //if(iTime <= 0.5 || restart) // in case it takes some frames for texture to load\n    //if(iFrame <= 60 || restart) // in case it takes some frames for texture to load\n    {\n        fragColor = vec4(0,0,0,0);\n        //fragColor = vec4(v == c);\n        //fragColor = vec4((texelFetch(iChannel1, v, 0).x >= 0.5));\n        //float f = texture(iChannel1, fragCoord/iResolution.xy).x;\n        //float f = fbm(fragCoord, 0.5, 8); // use noise to avoid troubble with texture load\n        //float f = noise(33.5*fragCoord/iResolution.xy-vec2(2,0)); // use noise to avoid troubble with texture load\n        float f = noise(33.5*mat2(1,1,-1,1)*(fragCoord/iResolution.xy)-vec2(4,0)); // use noise to avoid troubble with texture load\n        //if(sin(3.1415926*f*10.0) >= 0.0)\n        //if(f < 0.75)\n        //if(f < -0.0)\n        if(f < -0.03)\n        {\n            fragColor = vec4(0,0,0,1);\n        }\n        else\n        {\n            /*\n            if((v.x-c.x)*(v.x-c.x)+(v.y-c.y)*(v.y-c.y)<5*5)\n            {\n                // start with a blob of water\n                //if((uhash(uvec2(p), 0u)&15u) == 0u)\n                if(true)\n                {\n                    fragColor = encode(255);\n                }\n                else\n                {\n                    fragColor = encode(0);\n                }\n            }\n            else\n            */\n            {\n                fragColor = encode(1);\n                //fragColor = encode(2);\n                //fragColor = encode(5);\n            }\n        }\n    }\n    else\n    {\n        fragColor = hstep(iChannel0, v);\n        if(iMouse.z > 0.0 && m == v)\n        {\n            // keep adding pressure at center\n            fragColor = encode(255);\n        }\n    }\n    /*\n    //if(v == c)\n    if((v.x-c.x)*(v.x-c.x)+(v.y-c.y)*(v.y-c.y)<5*5)\n    {\n        // keep adding pressure at center\n        fragColor = encode(255);\n    }\n    */\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// COMMON\n\n// https://www.shadertoy.com/view/t3l3R7 a pixel fluid cellular automaton, 2025 by jt \n// diffusion: https://www.shadertoy.com/view/W3l3R4 integer average conserving total (jt)\n// gradient: https://www.shadertoy.com/view/tfjSWc pixel fluid gravitation rnd swap (jt)\n\n// A cellular automaton that simulates a compressible\n// pixel fluid inside an arbitrary container.\n// Simulation consists of two main passes:\n// (1) averaging mass while keeping total mass constant\n// (2) enforcing a vertical pressure gradient\n\n// Press SPACE to reset.\n// Click mouse to add water.\n\n// Feel free to use this in your games/simulations as long as this shader is credited.\n// Looking forward to see wonderful pixel worlds :D\n\n// tags: pixel, sandbox, diffusion, cellular, ca, automaton, boundary, conditions, gravity, fluid, communicating, vessels, compressible\n\n// The MIT License\n// Copyright (c) 2025 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define SCALE 5\n\nvec2 grad( ivec2 z ) // Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p ) // Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbu;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51u;\n    x ^= x >> 15u;\n    x *= 0x31848babu;\n    x ^= x >> 14u;\n    return x;\n}\n\n#define HASH(u) triple32(u)\n\nuint uhash(uvec2 v)\n{\n    return HASH(v.x + HASH(v.y));\n}\n\nfloat hash(vec2 v)\n{\n    return float(uhash(uvec2(v)))/float(0xffffffffU);\n}\n\nfloat hash12(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fbm(vec2 x, float H, int N) // https://iquilezles.org/articles/fbm/\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<N; i++ )\n    {\n        //t += a*hash12(f*x);\n        t += a*hash(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// https://www.shadertoy.com/view/DtjyWD integer division - rounding down\nivec2 div_floor(ivec2 a, ivec2 b) // vector version thanks to Fabrice\n{\n    ivec2  S = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return S * ((1 - abs(a)) / abs(b) - 1)+(1-S)*(a / b); // emulates ()?:\n}\n\n// this implementation replaces operator % which is buggy (for negative numbers) on windows\nivec2 mod_positive(ivec2 a, ivec2 b) // https://www.shadertoy.com/view/DtjyWD integer modulo strictly positive\n{\n    return a - div_floor(a, b) * b;\n}\n\nvec4 get(sampler2D s, ivec2 v)\n{\n    //return texelFetch(iChannel0, mod_positive(v, textureSize(iChannel0, 0)), 0);\n    return texelFetch(s, v, 0);\n}\n\nbool get_w(sampler2D s, ivec2 v)\n{\n    return get(s, v).w >= 0.5;\n}\n\nint decode(vec4 v)\n{\n    return int(v.z*255.0);\n}\n\nvec4 encode(int i)\n{\n    return vec4(0,0,float(i) / 255.0,0);\n}\n\nvec4 hstep(sampler2D s, ivec2 v) // https://www.shadertoy.com/view/tcjXzz cellular automaton heat equation (jt)\n{\n    vec4 left_raw   = get(s, v+ivec2(-1,0));\n    vec4 center_raw = get(s, v+ivec2( 0,0));\n    vec4 right_raw  = get(s, v+ivec2(+1,0));\n    \n    bool left_wall   = left_raw.w > 0.5;\n    bool center_wall = center_raw.w > 0.5;\n    bool right_wall  = right_raw.w > 0.5;\n\n    int left_value   = decode(left_raw);\n    int center_value = decode(center_raw);\n    int right_value  = decode(right_raw);\n\n    bool left_parity   = (left_value&1)!=0;\n    bool center_parity = (center_value&1)!=0;\n    bool right_parity  = (right_value&1)!=0;\n    \n    // NOTE: subtracting parity bit ensures following division by two is lossless\n    int left_half   = (left_value-int(left_parity))>>1;\n    int center_half = (center_value-int(center_parity))>>1;\n    int right_half  = (right_value-int(right_parity))>>1;\n\n    if(center_wall)\n    {\n        // center position solid: keep as is\n        return center_raw;\n    }\n\n    int result = int(center_parity); // preserve even/odd (which otherwise disappears by average)\n\n    // NOTE: adding and duplicating is lossless\n    if(left_wall)\n    {\n        if(right_wall)\n        {\n            // both left solid and right solid: keep previous value\n            result += 2*center_half;\n        }\n        else\n        {\n            // left solid but right free: average center with right\n            result += center_half + right_half;\n        }\n    }\n    else\n    {\n        if(right_wall)\n        {\n            // left free and right solid: average center with left\n            result += center_half + left_half;\n        }\n        else\n        {\n            // both left free and right free: average left with right\n            result += left_half + right_half;\n        }\n    }\n\n    return encode(result);\n}\n\nvec4 vstep(sampler2D s, ivec2 v) // https://www.shadertoy.com/view/tcjXzz cellular automaton heat equation (jt)\n{\n    vec4 down_raw   = get(s, v+ivec2(0,-1));\n    vec4 center_raw = get(s, v+ivec2(0, 0));\n    vec4 up_raw     = get(s, v+ivec2(0,+1));\n    \n    bool down_wall   = down_raw.w > 0.5;\n    bool center_wall = center_raw.w > 0.5;\n    bool up_wall     = up_raw.w > 0.5;\n\n    int down_value   = decode(down_raw);\n    int center_value = decode(center_raw);\n    int up_value     = decode(up_raw);\n\n    bool down_parity   = (down_value&1)!=0;\n    bool center_parity = (center_value&1)!=0;\n    bool up_parity     = (up_value&1)!=0;\n    \n    // NOTE: subtracting parity bit ensures following division by two is lossless\n    int down_half   = (down_value-int(down_parity))>>1;\n    int center_half = (center_value-int(center_parity))>>1;\n    int up_half     = (up_value-int(up_parity))>>1;\n\n    if(center_wall)\n    {\n        // center position solid: keep as is\n        return center_raw;\n    }\n\n    int result = int(center_parity); // preserve even/odd (which otherwise disappears by average)\n\n\n    // NOTE: adding and duplicating is lossless\n    if(down_wall)\n    {\n        if(up_wall)\n        {\n            // both down solid and up solid: keep previous value\n            result += 2*center_half;\n        }\n        else\n        {\n            // down solid but up free: average center with up\n            result += center_half + up_half;\n        }\n    }\n    else\n    {\n        if(up_wall)\n        {\n            // down free and up solid: average center with up\n            result += center_half + down_half;\n        }\n        else\n        {\n            // both down free and up free: average down with up\n            result += down_half + up_half;\n        }\n    }\n    \n    return encode(result);\n}\n\nvec4 sim(sampler2D s, ivec2 p, bool flip) // https://www.shadertoy.com/view/tfjSWc pixel fluid gravitation rnd swap (jt)\n{\n    ivec2 q = p;\n    q.y = ((q.y + int(flip)) ^ 1) - int(flip); // flip even-odd\n\n    vec4 a = get(s, p);\n    vec4 b = get(s, q);\n    if(a.w > 0.5 || b.w > 0.5)\n        return a; // position in a wall: keep as is\n\n    int A = decode(a);\n    int B = decode(b);\n    return\n        ((p.y & 1) == int(flip))\n        ?\n        encode(A + (B > 0 && A < 255 ? 1 : 0))\n        :\n        encode(A - (A > 0 && B < 255 ? 1 : 0));\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// BUFFER B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(floor(fragCoord));\n    fragColor = vstep(iChannel0, v);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// BUFFER C\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(floor(fragCoord));\n    fragColor = sim(iChannel0, v, false); // even\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// BUFFER D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(floor(fragCoord));\n    fragColor = sim(iChannel0, v, true); // odd\n}\n",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcdyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Liquid Toy abossard 465",
    "description": "Another liquid blob",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "mouse",
     "fluid",
     "abstract",
     "oil",
     "smoke",
     "paint"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n// Liquid toy by Leon Denise 2022-05-18\n// Playing with shading with a fake fluid heightmap\n\n// 2023-01-20 update:\n// fix scalars to be resolution independant\n// (samed speed and look at different frame size)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy / 1024.).rgb;\n    \n    // value from buffer A\n    vec4 data =  texture(iChannel0, uv);\n    float gray = data.x;\n    \n    // gradient normal from gray value\n    float range = 3.;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1);\n    vec3 unit = vec3(range/472./aspect,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray*gray));\n        \n    // backlight\n    vec3 color = vec3(.3)*(1.-abs(dot(normal, vec3(0,0,1))));\n    \n    // specular light\n    vec3 dir = normalize(vec3(0,1,2));\n    float specular = pow(dot(normal, dir)*.5+.5,20.);\n    color += vec3(.5)*ss(.2,1.,specular);\n    \n    // rainbow\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*1.+dot(normal, dir)*4.-uv.y*3.-3.);\n    color += tint * smoothstep(.15,.0,gray);\n\n    // dither\n    color -= dither.x*.1;\n    \n    // background blend\n    vec3 background = vec3(1);\n    background *= smoothstep(1.5,-.5,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), ss(.01,.1,gray));\n    \n    // display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(tint);\n    }\n\n    fragColor = vec4(color, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rr",
       "filepath": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin",
       "type": "volume",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\n// Liquid toy by Leon Denise 2022-05-18\n// Playing with shading with a fake fluid heightmap\n\nconst float speed = .01;\nconst float scale = .1;\nconst float falloff = 3.;\nconst float fade = .4;\nconst float strength = 1.;\nconst float range = 5.;\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += texture(iChannel0, p/amplitude).xyz * amplitude;\n        amplitude /= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1);\n    \n    // noise\n    vec3 spice = fbm(vec3(uv*scale,iTime*speed));\n    \n    // draw circle at mouse or in motion\n    float t = iTime*2.;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.)/iResolution.y;\n    if (iMouse.z > .5) uv -= mouse;\n    else uv -= vec2(cos(t),sin(t))*.3;\n    float paint = trace(length(uv),.1);\n    \n    // expansion\n    vec2 offset = vec2(0);\n    uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture(iChannel1, uv);\n    vec3 unit = vec3(range/472./aspect,0);\n    vec3 normal = normalize(vec3(\n        TEX1(uv - unit.xz)-TEX1(uv + unit.xz),\n        TEX1(uv - unit.zy)-TEX1(uv + unit.zy),\n        data.x*data.x)+.001);\n    offset -= normal.xy;\n    \n    // turbulence\n    spice.x *= 6.28*2.;\n    spice.x += iTime;\n    offset += vec2(cos(spice.x),sin(spice.x));\n    \n    uv += strength * offset / aspect / 472.;\n    \n    // sample buffer\n    vec4 frame = texture(iChannel1, uv);\n    \n    // temporal fading buffer\n    paint = max(paint, frame.x - iTimeDelta * fade);\n    \n    // print result\n    fragColor = vec4(clamp(paint, 0., 1.));\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n#define TEX1(uv) texture(iChannel1, uv).r\n#define TEX2(uv) texture(iChannel2, uv).r\n#define TEX3(uv) texture(iChannel3, uv).r\n\n// shorcut for smoothstep uses\n#define trace(edge, thin) smoothstep(thin,.0,edge)\n#define ss(a,b,t) smoothstep(a,b,t)\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcdyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Worms abossard 467",
    "description": "Pretty much inspired by nimitz's spiral shader (https://www.shadertoy.com/view/4sfXDs)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raymarching",
     "distancefield",
     "vr"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot\n// host, display, distribute or share this Work neither as\n// is or altered, in any form including physical and\n// digital. You cannot use this Work in any commercial or\n// non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it. You\n// cannot use this Work to train AI models. I share this\n// Work for educational purposes, you can link to it as\n// an URL, proper attribution and unmodified screenshot,\n// as part of your educational material. If these\n// conditions are too restrictive please contact me.\n\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/metal-print/Worms-with-code-by-InigoQuilez/39863456.0JXQP\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nvec2  sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3  opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\nvec2 sdCylinder( in vec3 p )\n{\n    return vec2( length(p.xz), (p.y+50.0)/100.0 );\n}\n\nvec3 map( vec3 p )\n{\n    float time = iTime*1.0;\n    \n    vec2  id = floor( (p.xz+1.0)/2.0 );\n    float ph = hash(id+113.1);\n    float ve = hash(id);\n\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    p.xz += 0.5*cos( 2.0*ve*time + (p.y+ph)*vec2(0.53,0.32) - vec2(1.57,0.0) );\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(p.y-ve*time*ve+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(p.y-ve*time*ve+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(p.y-ve*time*ve+4.0);\n    \n    vec2 h1 = sdCylinder( p1 );\n    vec2 h2 = sdCylinder( p2 );\n    vec2 h3 = sdCylinder( p3 );\n\n    return opU( opU( vec3(h1.x-0.15*(0.8+0.2*sin(200.0*h1.y)), ve + 0.000, h1.y), \n                     vec3(h2.x-0.15*(0.8+0.2*sin(200.0*h2.y)), ve + 0.015, h2.y) ), \n                     vec3(h3.x-0.15*(0.8+0.2*sin(200.0*h3.y)), ve + 0.030, h3.y) );\n\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec3 h = map(ro + t*rd);\n        res = vec3( t, h.yz );\n        if( abs(h.x)<(px*t) || t>maxdist ) break;\n        t += min( h.x, 0.5 )*0.85;\n    }\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.003;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.1;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.0*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += h-d;\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float px )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    vec3 res = intersect( ro, rd, px, maxdist );\n    if( res.x < maxdist )\n    {\n        vec3  pos = ro + res.x*rd;\n        vec3  nor = calcNormal( pos );\n        float occ = calcOcc( pos, nor );\n\n        col = 0.5 + 0.5*cos( res.y*30.0 + vec3(0.0,4.4,4.0) );\n        col *= 0.5 + 1.5*nor.y;\n        col += clamp(1.0+dot(rd,nor),0.0,1.0);\n        float u = 800.0*res.z - sin(res.y)*iTime;\n        col *= 0.95 + 0.05*cos( u + 3.1416*cos(1.5*u + 3.1416*cos(3.0*u)) + vec3(0.0,1.0,2.0) );\n        col *= vec3(1.5,1.0,0.7);\n        col *= occ;\n\n        float fl = mod( (0.5+cos(2.0+res.y*47.0))*iTime + res.y*7.0, 4.0 )/4.0;\n        col *= 2.5 - 1.5*smoothstep(0.02,0.04,abs(res.z-fl));\n        \n        col *= exp( -0.1*res.x );\n        col *= 1.0 - smoothstep( 20.0, 30.0, res.x );\n    }\n    \n    return pow( col, vec3(0.5,1.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        vec3  ro = vec3(0.6,2.4,1.2);\n        vec3  ta = vec3(0.0,0.0,0.0);\n        float fl = 3.0;\n        vec3  ww = normalize( ta - ro);\n        vec3  uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n        vec3  vv = normalize( cross(ww,uu) );\n        vec3  rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\n        vec3 col = render( ro, rd, 1.0/(iResolution.y*fl) );\n \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    vec2 q = fragCoord.xy/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, 0.001 );\n    \n\tfragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfdyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork 3D Audio V abossard 470",
    "description": "Continuation of my attemps to extract audio features from a song",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "sound",
     "interactive",
     "music",
     "pixel",
     "light",
     "bloom",
     "visual",
     "live",
     "neon"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "MtjXzc",
       "filepath": "https://soundcloud.com/blazerjacket/blazerjacket-x-neogarde-freedom-or-death",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* \"3D Audio Visualizer\" by @kishimisu - 2022 (https://www.shadertoy.com/view/dtl3Dr)\n    \n    This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n    Wait for the drop!\n\n   The lights of this scene react live to the audio input.\n   I'm trying to find interesting ways to extract audio\n   features from the audio's FFT to animate my scenes.\n   \n   Each light is associated to a random frequency range,\n   ranging from bass (distant lights) to high (close lights)   \n   \n   Really happy with this result!\n*/\n\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .8, 1.), a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col  = vec3(0.);\n    float vol = getVol(8.);\n    \n    float hasSound = 1.; // Used only to avoid a black preview image\n    if (iChannelTime[0] <= 0.) hasSound = .0;\n \n    for (float i = 0., t = 0.; i < 30.; i++) {\n        vec3 p  = t*normalize(vec3(uv, 1.));        \n        \n        vec3 id = floor(abs(p));\n        vec3 q  = fract(p)-.5;\n        \n        float boxRep = sdBox(q, vec3(.3));\n        float boxCtn = sdBox(p, vec3(7.5, 6.5, 16.5));\n\n        float dst = max(boxRep, abs(boxCtn) - vol*.2);     \n        float freq = smoothstep(16., 0., id.z)*3.*hasSound + hash13(id)*1.5;\n       \n        col += vec3(.8,.6,1) * (cos(id*.4 + vec3(0,1,2) + iTime) + 2.) \n             * light(dst, 10. - vol) \n             * getPitch(freq, 1.);\n        \n        t += dst;\n    }\n    \n    fragColor = vec4(col,1.0);   \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfdyD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork h e e e l  abossard 472",
    "description": "My entry for the Revision 2018 Animated GIF Compo (1st place \\o/), with an extra bit of post process that blew the file size limit.\n\nUncomment ANOTHER_LEVEL to go deeper",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fractal",
     "spiral",
     "antialias",
     "loop",
     "helix",
     "outline",
     "revision",
     "carpaint"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n//#define ANOTHER_LEVEL\n\n\nfloat guiLead = 0.6;\nfloat guiInnerRatio = 0.4407892623709694;\nfloat guiFocal = 3.;\nfloat guiRotateModel = 0.4560833039600971;\nfloat guiDebug = 0.6749066960348409;\nfloat guiZipOffset = 30.;\nfloat guiZipSize = 60.;\nfloat guiZipSpeed = 3.3;\nfloat guiZoom = 0.1;\nfloat guiModelScale = 7.749066960348409;\n\nmat4 cameraMatrix = mat4(\n    -0.7063226699829102,\n    0.7052236199378967,\n    0.06198469549417496,\n    0,\n    -0.30620118975639343,\n    -0.3832840919494629,\n    0.8714323043823242,\n    0,\n    0.6382971405982971,\n    0.5965006947517395,\n    0.48660656809806824,\n    0,\n    0.14653973281383514,\n    0.6211488246917725,\n    0.13233166933059692,\n    1\n);\n\nvec3 camPosition = vec3(0.14653973281383514, 0.6211488246917725, 0.13233166933059692);\n\nfloat time;\n\n#define PI 3.14159265359\n#define HALF_PI 1.5707963267948966\n#define TAU 6.28318530718\n#define PHI 1.618033988749895\n\n\n// --------------------------------------------------------\n// Utils\n// --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n\n// --------------------------------------------------------\n// Helix\n// https://www.shadertoy.com/view/MstcWs\n// --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // tangent by the repeat cell\n    vec2 tangent = vec2(line.y, -line.x);\n    closest += cell * repeatSize * tangent;\n\n    return closest;\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n// Cartesian to helix coordinates\nvoid pModHelix(inout vec3 p, float lead, float radius) {\n    vec3 closest = closestHelix(p, lead, radius);\n    float helixAngle = atan((2. * PI * radius) / lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x / lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    p = vec3(x, y, z);\n}\n\nfloat pModHelixScale(inout vec3 p, float lead, float innerRatio) {\n    float radius = mix(.25, .5, innerRatio);\n    pModHelix(p, lead, radius);\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\nfloat pModHelixUnwrap(inout vec3 p, float lead, float innerRatio, float t) {\n    float radius = mix(.25, .5, innerRatio);\n    float width = cos(asin(t));\n    float adjust = (1. / width);\n    float offset = ((.5 * adjust) - .5) * 7.;\n\n    vec3 pp = p;\n    pp.z -= radius;\n    pR(pp.xy, PI * -.5);\n    pp.x *= -1.;\n\n    p.z += offset;\n    radius += offset;\n    pModHelix(p, lead, radius);\n\n    p = mix(p, pp, rangec(.8, 1., t));\n\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    int id;\n};\n\nfloat anim(float t, float index) {\n    float overlap = .5;\n    float steps = 2.;\n    float all = mix(steps, 1., overlap);\n    float width = 1. / (all - 1.);\n    float each = width * (1.- overlap);\n    float start = index * each - width * .5;\n    float end = start + width;\n    return range(start, end, t);\n}\n\nfloat unzip(vec3 p, float t) {\n    float size = guiZipSize;\n    float speed = guiZipSpeed;\n\n    t *= size * speed;\n\n    if (sign(p.y) != sign(p.x)) {\n        float radius = mix(.25, .5, guiInnerRatio);\n        float scale = mix(.5, 0., guiInnerRatio);\n        float factor = radius / scale * PI * 2.;\n        t -= (factor - .5);\n    }\n\n    return range(size, 0., abs(p.x) + size - t);\n}\n\nvoid addPipe(inout float d, vec3 p, float scale, float tt) {\n\n    float t = clamp(tt, 0., 1.);\n\n    float boundry = 1.;\n    float part;\n    float separate = (\n        rangec(0., boundry * .01, t) * .3 +\n        rangec(boundry * .01, boundry, t) * .7\n    );\n\n    float round = rangec(.0, 1., t);\n\n    part = fBox2(p.yz, vec2(mix(guiLead * 2., .5, separate), .5));\n    part = mix(part, length(p.yz) - .5, round);\n    part /= scale;\n\n    d = mix(d, part, smoothstep(.0, .01, t));\n}\n\nvoid unzipHelixModel(inout float d, inout float scale, inout vec3 p, float lead, float innerRatio, float step, float invert) {\n    float offset = guiZipOffset / lead;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n    float t1 = unzip(p + vec3(offset,0,0) * invert, anim(time, step));\n    addPipe(d, p, scale, t1);\n}\n\nModel map(vec3 p) {\n\n    float part, d, t1, t2, t3, t4;\n    float lead = guiLead;\n    float innerRatio = guiInnerRatio;\n    vec2 uv1, uv2, uv3;\n\n    p /= guiModelScale;\n\n    vec3 pp = p;\n\n    d = 1e12;\n\n    float s = mix(.5, 0., innerRatio);\n\n    float scale = 1./pow(1./s, time);\n\n    pR(p.xy, PI * -.5 * time + guiRotateModel * PI * 2.);\n    \n    p *= scale;\n    p.z += .5;\n\n    scale *= pModHelixUnwrap(p, lead, innerRatio, time);\n    p.x *= -1.;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n\n    #ifdef ANOTHER_LEVEL\n        scale *= pModHelixScale(p, lead, innerRatio);\n        p.x *= -1.;\n    #endif\n\n    d = min(d, length(p.yz) - .5);\n    d /= scale;\n\n    unzipHelixModel(d, scale, p, lead, innerRatio, -1., 1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 0., -1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 1., 1.);\n\n    d *= guiModelScale;\n\n    return Model(d, vec3(0), 1);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nconst float OUTLINE = .003; // Outline thickness\nconst float OUTLINE_BOUNDRY = .5; // Where to feather the inside/outside\nconst float MAX_TRACE_DISTANCE = 1.5; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\n// Faster runtime\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n// Faster compilation\nconst int NORMAL_STEPS = 6;\nvec3 _calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n// Adapted from https://www.shadertoy.com/view/Xds3zN\nvec3 doLighting(vec3 pos, vec3 nor, vec3 rd) {\n\n    vec3 col;\n    vec3 up = normalize(vec3(1));\n\n    // lighitng        \n    float occ = mix(calcAO( pos, nor ), 1., .8);\n    vec3  lig = normalize(vec3(0,.2,1));\n    float amb = clamp(dot(nor, up) * .5 + .5, 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    vec3  hal = normalize( lig-rd );\n    float spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n\n    vec3 cA = vec3(.7,.3,.9);\n    vec3 cB = vec3(.4,.9,.8);\n    vec3 cC = vec3(.7,0,.7);\n\n    col = mix(cA, cB, rangec(.0, 1., dot(-rd, nor))); // need better ramp\n    col = mix(col, vec3(.8,.5,1), rangec(.5, 1., dif) * .5);\n    col += cC * rangec(.5, 1., dif) * .1;\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 ) * .9;\n\n    vec3 lin = vec3(0);\n    lin += .5 * dif;\n    lin += .1 * spe * dif;\n    lin += .2 * fre * occ;\n    lin += .5 * amb * occ;\n    lin += .4 * occ;\n    col = col*lin;\n\n    return col;\n}\n\nvec3 background;\n\nvoid applyFog(inout vec3 color, vec3 pos) {\n    float fog = length(camPosition - pos);\n    fog = smoothstep(float(MAX_TRACE_DISTANCE) * .36, float(MAX_TRACE_DISTANCE), fog);\n    color = mix(color, background, fog);\n}\n\nvec3 shadeSurface(vec3 pos, Ray ray) {\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        return background;\n    }\n\n    vec3 normal = calcNormal(pos);\n\n    vec3 color = doLighting(\n        pos,\n        normal,\n        ray.direction\n    );\n\n    applyFog(color, pos);\n    \n    return color;\n}\n\nvec4 shadeOutline(vec3 pos, float t) {\n    float alpha = smoothstep(0., OUTLINE_BOUNDRY, t);\n    alpha -= smoothstep(OUTLINE_BOUNDRY, 1., t);\n    alpha *= .5;\n\tvec3 color = vec3(0);\n    applyFog(color, pos);\n    return vec4(color, alpha);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// --------------------------------------------------------\n\nvec3 raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float lastDist = currentDist;\n    vec3 pos, lastPos = vec3(0);    \n    vec4 outline = vec4(0);\n    \n    Model model;\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for (int i = 0; i < NUM_OF_TRACE_STEPS; i++) {\n\n        lastPos = pos;\n        pos = ray.origin + ray.direction * ray.len;\n\n        if (ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        if (currentDist < INTERSECTION_PRECISION) {\n            break;\n        }\n\n        if (currentDist > lastDist && currentDist < OUTLINE) {\n\n            float t = lastDist / OUTLINE;\n            \n            vec4 newOutline = shadeOutline(pos, t);\n            float contribution = 1. - outline.a;\n            outline.rgb = mix(outline.rgb, newOutline.rgb, contribution);\n            outline.a += newOutline.a * contribution;\n\n            if (t < OUTLINE_BOUNDRY) {\n                pos = lastPos;\n                break;\n\t\t\t}\n        }\n\n        model = map(pos);\n        lastDist = currentDist;\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\t\n    vec3 color = mix(\n        shadeSurface(pos, ray),\n       \toutline.rgb,\n        outline.a\n\t);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 bgA = vec3(.6,.5,.8) * .55;\n    vec3 bgB = vec3(.7,.9,1.) * .5;\n    background = mix(bgA, bgB, dot(p, normalize(vec2(.2,-.6))) * .5);\n    //background = mix(vec3(.4,.3,.5) * .9, vec3(.6), -.2);\n\n    time = iTime;\n    time *= .6;\n    time += .53;\n    time = mod(time, 1.);\n    \n    float camDist = length(camPosition);\n\n    mat4 camMat = cameraMatrix;\n    float focalLength = guiFocal;\n    vec3 rd = normalize(\n        (vec4(p, -focalLength, 1) * camMat).xyz\n    );\n    \n    vec3 color = raymarch(CastRay(camPosition, rd));\t\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float vig = pow(\n        16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y),\n        0.075\n    );\n    color *= vec3(.9, .95, 1.) * vig * 1.1;\n\n    color = mix(color, vec3(pow(length(color * .6), 2.)), .1);\n    color *= 1.05;\n    color = pow(color, vec3(1.2,1.3,1.2));\n\n    fragColor = vec4(color,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tctcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork w10 abossard 499",
    "description": "Windows10 wallpapar wip.\n\nOMG\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\n\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\nomg.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "windows10",
     "cineshader"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n#define ZERO   (min(iFrame,0))\n\nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2( 127.1, 311.7 ) );\n\treturn fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p.xy)-vec2(F),0.0)) - R;\t\n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;\t\n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p)-F,0.0)) - R;\t\n}\n\n\nfloat map1(vec3 p, float scale) {\n\tfloat G = 0.50;\n\tfloat F = 0.50 * scale;\n\tfloat t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n\tt = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n\treturn t;\n}\n\nfloat map2(vec3 p) {\n\tfloat t = map1(p, 0.9);\n\t//t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n    t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n\treturn t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n\tfloat d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tcolor += d * noise( p * 5.0 + iTime);\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0);\n    for(int count = 0 ; count < 2; count++) {\n        vec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        uv *= 1.4;\n        uv.x += hash(uv.xy + iTime + float(count)) / 512.0;\n        uv.y += hash(uv.yx + iTime + float(count)) / 512.0;\n        vec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0 + sin(iTime) * 0.01));\n        dir.xz = rot(dir.xz, d2r(70.0));\n        dir.xy = rot(dir.xy, d2r(90.0));\n        vec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n        vec3  col   = vec3(0.0);\n        float t     = 0.0;\n        float M     = 1.002;\n        float bsh   = 0.01;\n        float dens  = 0.0;\n\n        for(int i = ZERO ; i < REP * 24; i++) {\n            float temp = map1(pos + dir * t, 0.6);\n            if(temp < 0.2) {\n                col += WBCOL * 0.005 * dens;\n            }\n            t += bsh * M;\n            bsh *= M;\n            dens += 0.025;\n        }\n\n        //windows\n        t = 0.0;\n        float y = 0.0;\n        //for(int i = 0 ; i < REP * 50; i++)\n        for(int i = ZERO ; i < REP; i++)\n        {\n            float temp = map2(pos + dir * t);\n            if(temp < 0.025) {\n                //col += WBCOL2 * 0.005;\n                col += WBCOL2 * 0.5;\n            }\n            t += temp;\n            y++;\n        }\n        col += ((2.0 + uv.x) * WBCOL2) + (y / (25.0 * 50.0));\n        col += gennoise(dir.xz) * 0.5;\n        col *= 1.0 - uv.y * 0.5;\n        col *= vec3(0.05);\n        col  = pow(col, vec3(0.717));\n        fragColor += vec4(col, 1.0 / (t));\n    }\n    fragColor /= vec4(2.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wctcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Yin Yang A abossard 501",
    "description": "see Common tab",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "distancefield",
     "math",
     "curve",
     "arclength"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// This tab is solely for rendering the functions.\n\n#define SMOOTH_SIZE (5. / iResolution.y)\n\nvec3 dfVisualize(float v)\n{\n    vec3 colorNegative = vec3(.2, .6, .6);\n    vec3 colorPositive = vec3(.6, .6, .2);\n    vec3 colorVoid = vec3(1, 1, 1);\n    \n    vec3 col = mix(\n        mix(colorNegative, colorPositive, step(0., v)),\n        colorVoid,\n        smoothstep(0., 0.3, min(abs(v), .23)));\n    col *= .3 + .7 * smoothstep(0., SMOOTH_SIZE, abs(fract(v * 10. + .5) -.5) / 10.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= 1.8;\n    uv.y += iTime;\n    \n    float v = yinyangDots_surface(uv);\n    \n\tvec3 col = dfVisualize(v);    \n\n\tvec2 rs = vec2(yinyangCurve_surface(uv), yinyang_arcLength(uv));\n    \n    rs.y = fract(rs.y + iTime) - .5;\n    v = length(vec2(abs(rs.x), max(abs(rs.y) - .3, 0.))) - .05;\n    \n   \tcol = mix(col, vec3(.0, .0, .0), smoothstep(SMOOTH_SIZE, 0., v));\n    \n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Created by srtuss; 2019-09-28\n//\n// Functions for computing the accurate distance-field and arc-length\n// of a Yin-Yang shaped curve. Might have to some interesting uses,\n// for animations or adding details to your scenes!\n//\n\n#define PI (3.1415926535897932384626433832795)\n\n// Distance-field function of just the curve, without the holes:\nfloat yinyangCurve_surface(vec2 uv)\n{\n    float k = step(0., uv.x) * 2.;\n    return (length(vec2(uv.x, mod(uv.y + k, 4.) - 2.)) - 1.) * (k - 1.);\n}\n\n// Distance-field function of the curve, with holes:\nfloat yinyangDots_surface(vec2 uv)\n{\n    float v = yinyangCurve_surface(uv);\n    float holeSize = .3;\n    uv.y = mod(uv.y + 1., 4.) - 1.;\n    return min(max(v, -length(uv) + holeSize), length(uv - vec2(0., 2.)) - holeSize);\n}\n\n// Arc-length function of the curve:\n// returns arc-length in radians\nfloat yinyang_arcLength(vec2 uv)\n{\n    float k = step(0., uv.x);\n    uv.y += k * 2.;\n    float id = floor(uv.y / 4. - 1.) * -2. + k - 3.5;\n   \tuv = vec2(uv.x * (k * 2. - 1.), mod(uv.y, 4.) - 2.);\n    return atan(uv.x, uv.y) + id * PI;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork mandelbulb abossard 504",
    "description": "a mandelbulb",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "fractal",
     "cineshader"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n//#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.1;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\t   vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wftcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork The Chaos  abossard 506",
    "description": "The Chaos Factory\nI needed a small 2D physics engine for other shaders to I implemented this (Box2D-lite, https://github.com/erincatto/box2d-lite, MIT License)\nYou can add/push/pull boxes with the top-left selection!",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "collision",
     "simulation",
     "interactive",
     "bounce",
     "box",
     "box",
     "solver",
     "physics",
     "dynamic",
     "rigidbody",
     "factory",
     "friction",
     "impulse",
     "box2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\nThe Chaos Factory\n\nGPU implementation of Erin Catto's Box2D-lite (https://github.com/erincatto/box2d-lite, MIT License)\n\nBroad phase and revolute joints\n\nNever got any stacking to work, even when accumulating impulses, even across multiple frames \nThat's why the demo is as little static as possible...\nYou can add/push/pull boxes with the top-left selection!\n\nSpecial thanks to the shadertoy community :\n- Dave_Hoskins for its hash functions\n- iq for its sdf functions (and many other resources)\n- FabriceNeyret2 and P_Malin for text rendering (and many other resources)\n- s23b for blueprint-like rendering (please check https://www.shadertoy.com/view/4tySDW)\n\n*/\n\n\n// Rendering\n\nfloat sdBox(vec2 p, vec2 b) // https://www.youtube.com/watch?v=62-pRVZuS5c\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) // https://www.shadertoy.com/view/3tdSDj\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return length(pa-h*ba);\n}\n\nfloat sdTriangle(  in vec2 p, in float r ) // https://www.shadertoy.com/view/Xl2yDW\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p -= vec2(0.5,0.5*k)*max(p.x+k*p.y,0.0);\n    p.x =  p.x - clamp(p.x,-r,r);\n    p.y = -p.y - r*(1.0/k);\n    return length(p)*sign(p.y);\n}\n\n// modified version of sdSegment for a dotted segment\nfloat sdDotted(vec2 p, vec2 a, vec2 b, int sep) // sep is number of separation\n{\n    float n = 2.*float(sep)+1., dh = 1./n;\n    vec2 pa = p-a, ba = b-a;\n    \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float rh = fract(n*h/2.);\n    if(rh > .5001)\n    {\n        float closest_h = floor(n*h)*dh; \n        return min(length(pa-closest_h*ba), length(pa-(closest_h+dh)*ba));\n    }\n    return length(pa-h*ba);\n}\n\nfloat sdArrow(vec2 p, float l)\n{\n    return min(sdTriangle(p, .03), sdSegment(p, vec2(0, -l), vec2(0))-0.004);\n}\n\nfloat sdDottedArrow(vec2 p, float l, int sep)\n{\n    return min(sdTriangle(p, .03), sdDotted(p, vec2(0, -l), vec2(0), sep)-0.004);\n}\n\nfloat sdBody(vec2 p, Body b)\n{\n    return sdBox(rot(-b.ang)*(p-b.pos), b.size);\n}\n\nfloat sdJoint(vec2 p, Joint j, sampler2D buff)\n{\n    // load associated bodies\n    Body b0 = loadBody(buff, j.b0_id);\n    Body b1 = loadBody(buff, j.b1_id);\n\n    // Have the dotted line relative to the joint's softness\n    float d = FLT_MAX;\n    vec2 off = rot(b0.ang)*j.loc_anc0;\n    float sep_size = j.softness * .003;\n    int sep0 = int(length(off)/sep_size*.5);\n    int sep1 = int(length(b1.pos-b0.pos-off)/sep_size*.5);\n    if(b0.inv_mass != 0.) d = min(d, sdDotted(p, b0.pos, b0.pos+off, sep0)-0.003);\n    if(b1.inv_mass != 0.) d = min(d, sdDotted(p, b1.pos, b0.pos+off, sep1)-0.003);\n    \n    return d;\n}\n\nfloat drawChar(vec2 char_p, int char_id) // https://www.shadertoy.com/view/llySRh\n{\n    if (char_p.x < .0 || char_p.x>1. || char_p.y<0. || char_p.y>1.) return 0.;\n    vec2 p = char_p/16.; \n    return textureGrad(iChannel2, p + fract(vec2(char_id,15-char_id/16)/16.), dFdx(p), dFdy(p)).x;\n}\n\nfloat drawCharIt(vec2 char_p, int char_id) // https://www.shadertoy.com/view/ldfcDr\n{\n    char_p.x += (1.-char_p.y)*0.3f;\n    return drawChar(char_p, char_id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    float px = rcp(min(iResolution.x, iResolution.y));\n    vec2 uv = VIEW(fragCoord);\n    \n    Globals g = loadGlobals(iChannel0);\n    \n    // Bodies and background\n    float body_d = FLT_MAX;\n    float outline_d = FLT_MAX; // to get outline inside overlapping moving boxes\n    int closest_b_id = -1;\n    Body closest_b = loadBody(iChannel0, 0);\n    for(int b_id = 0; b_id < g.n_body; b_id++)\n    {\n        if(isInvisibleBody(b_id)) continue;\n        Body b = loadBody(iChannel0, b_id);\n        if(dot2(uv-b.pos) > dot2(b.size)) continue; // helps framerate a bit with lots of bodies\n        float b_d = sdBody(uv, b);\n        if(b_d < body_d)\n        {\n            body_d = b_d;\n            closest_b = b;\n            closest_b_id = b_id;\n        }\n        \n        outline_d = min(abs(outline_d), abs(b_d));\n    }\n    \n    vec3 col = vec3(0, .35, .58) - .07 * saturate(dot2(uv*.5)); // background\n    if(body_d > 0.0)\n    {\n        // background grids\n        vec4 grid_uv = vec4(24,24,6,6)*(uv.xyxy-VIEW_ZOOM-iTime*.005*vec4(5,-3,-5,3));\n        vec4 grid = smoothstep(1.-max(10.*px,0.01)*vec4(4,4,1,1), vec4(1), sin(PI*grid_uv))*vec4(.5,.5,1,1);\n        col = mix(col, vec3(.7), max(grid.x, max(grid.y, max(grid.z, grid.w))));\n        \n        // Arrows\n        float arr_d = FLT_MAX;\n        #define ARR_ANIM(P) vec2(0,.05*sin(3.*iTime+1000.*P))\n        arr_d = min(arr_d, sdDottedArrow(uv-vec2(1,0)+ARR_ANIM(0.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(uv-vec2(1.9,-.5)+ARR_ANIM(1.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(-1.2)*(uv-vec2(0,.75))+ARR_ANIM(2.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(.8)*(uv-vec2(.3,-.5))+ARR_ANIM(3.), .3, 3));\n        arr_d = min(arr_d, sdDottedArrow(rot(PI*.5)*(uv-vec2(-.7,-.83))+ARR_ANIM(3.), .3, 3));\n        arr_d = min(arr_d, sdArrow(rot(1.72)*(uv-vec2(-.9,-.15))+ARR_ANIM(4.), .1));\n        arr_d = min(arr_d, sdArrow(rot(-1.72)*(uv-vec2(-1.3,-.43))+ARR_ANIM(5.), .1));\n        arr_d = min(arr_d, sdArrow(rot(1.72)*(uv-vec2(-1.4,-.61))+ARR_ANIM(6.), .1));\n        arr_d = min(arr_d, sdArrow(rot(2.6)*(uv-vec2(-1.83,.7))+ARR_ANIM(7.), .1));\n        arr_d = min(arr_d, sdArrow(rot(-2.6)*(uv-vec2(-1.15,.7))+ARR_ANIM(8.), .1));\n        if(g.funnel_b_id >= 0) // funnel arrow\n        {\n            vec2 f_dir = loadBody(iChannel0, g.funnel_b_id).pos - vec2(-1.75,.1);\n            arr_d = min(arr_d, sdArrow(rot(PI*0.5-atan(f_dir.y,f_dir.x))*(uv-vec2(-1.75,.1))-vec2(0,.1), .1));\n        }\n        if(MOUSE_DOWN) // force arrows\n        {\n            vec2 m = VIEW(iMouse);\n            if(g.mode==0) arr_d = min(arr_d, sdDottedArrow(rot(PI*.25)*abs(uv-m)-vec2(0,.2+.1*sin(5.*iTime)), .15, 2));\n            if(g.mode==1) arr_d = min(arr_d, sdDottedArrow(rot(PI*1.25)*abs(uv-m)-vec2(0,-.2+.1*sin(5.*iTime)), .15, 2));\n        }\n\n        col = mix(col, vec3(.8), 1.0-smoothstep(0.,.008, arr_d));    \n\n    } \n    else // bodies\n    {\n        if(closest_b.inv_mass == 0.0 && abs(closest_b.ang_vel) < EPS) // solid lines pattern\n        {\n            float ang = round((4.*closest_b.ang-PI)/(2.*PI))/2.*PI+PI*.25;\n            vec2 ruv = vec2(cos(ang) * uv.x, sin(ang) * uv.y);\n            col = mix(col, vec3(1), smoothstep(-.07, -0.06, body_d) * smoothstep(1.-max(75.*px,0.1), 1. ,.5+.5*sin(PI*40.*(ruv.x + ruv.y))));\n        }\n        \n        col *= (closest_b_id < FACTORY_FIXED_BODIES) ? 0.8 : 1.2; // bodies color\n        // if(closest_b_id == g.funnel_b_id) col = col.zyx; // visualize closest body to the funnel exit\n    }\n\tcol = mix( col, vec3(1), 1.0-smoothstep(0.,.008, abs(closest_b_id >= FACTORY_FIXED_BODIES ? outline_d : body_d)) ); // outline\n\n    // Joints\n    float joint_d = FLT_MAX;\n    int closest_j_id = -1;\n    for(int joint_id = 0; joint_id < g.n_joint; joint_id++)\n    {\n        Joint j = loadJoint(iChannel0, g, joint_id);\n        float j_d = sdJoint(uv, j, iChannel0);\n        \n        if(j_d < joint_d)\n        {\n            joint_d = j_d;\n            closest_j_id = joint_id;\n        }\n    }\n    Joint closest_j = loadJoint(iChannel0, g, closest_j_id);\n    col = mix( col, vec3(1), 1.-smoothstep(.0, 0.004, (joint_d)));\n    \n    // Texts\n    #define PRINT_CHR(P,C,D,F) D=max(D,F(P,C));\n    #define PRINT_STR(P,A,D,F) for(int i=0;i<A.length();i++,P.x-=.44)D=max(D,F(P,A[i]));\n    #define PRINT_INT(P,N,D,F) for(int i=0,n=N;n>0||i==0;i++,n/=10,P.x+=.44)D=max(D,F(P,48+n%10));\n    float char_d = 0.;\n    vec2 p = vec2(6,6.3)*(uv-vec2(-.6,1.27));\n    int title[] = int[](84,104,101,32,67,104,97,111,115,32,70,97,99,116,111,114,121);\n    PRINT_STR(p, title, char_d, drawChar)\n    p = (p+vec2(8.8, .58))*1.4;\n    int subtitle[] = int[](71,80,85,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,32,111,102,32,66,111,120,50,68,45,108,105,116,101);\n    PRINT_STR(p, subtitle, char_d, .8*drawCharIt)\n    p = vec2(8,8.3)*(uv-vec2(-1.95,-1.27));\n    int hint_0[] = int[](67,108,105,99,107,32,116,111,32,112,117,115,104,32,98,111,120,101,115,33);\n    int hint_1[] = int[](67,108,105,99,107,32,116,111,32,112,117,108,108,32,98,111,120,101,115,33);\n    int hint_2[] = int[](67,108,105,99,107,32,116,111,32,97,100,100,32,109,111,114,101,33,32,32);\n    if(g.mode == 0) PRINT_STR(p, hint_0, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    if(g.mode == 1) PRINT_STR(p, hint_1, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    if(g.mode == 2) PRINT_STR(p, hint_2, char_d, (.5+.5*sin(2.*iTime))*drawChar)\n    int boxes[] = int[](66,111,120,101,115,32,58,32);\n    p = p-vec2(-8.6,1.15);\n    PRINT_STR(p, boxes, char_d, .8*drawCharIt)\n    p.x -= float(boxes.length())*.44;\n    PRINT_INT(p, bodyMax(g.res), char_d, .8*drawCharIt)\n    p.x += .44;\n    PRINT_CHR(p, 47, char_d, .8*drawCharIt)\n    p.x += .88;\n    PRINT_INT(p, g.n_body, char_d, .8*drawCharIt)\n    p = vec2(8,8.3)*(uv-vec2(-1.87,.04));\n    PRINT_INT(p, g.n_funnel, char_d, drawChar)\n    col = mix(col, vec3(1), char_d);    \n    \n    // Icons\n    float icon_d = FLT_MAX;\n    p = uv - vec2(-1.7, 1.3);\n    #define ANIM_ICON(GM, M) ((GM == M) ? sin(5.*iTime) : 0.0)\n    icon_d = min(icon_d, sdArrow(rot(PI*.25)*(abs(p)-vec2(.05+.005*ANIM_ICON(g.mode, 0))), .05));\n    icon_d = min(icon_d, sdArrow(rot(PI*1.25)*(abs(p-vec2(.3, 0))-vec2(.035+.005*ANIM_ICON(g.mode, 1))), .05));\n    icon_d = min(icon_d, abs(sdBox(rot(-.2)*(p-vec2(.6,-.03)), vec2(.04)))-.004);\n    icon_d = min(icon_d, sdBox((1.+.1*ANIM_ICON(g.mode, 2))*(p-vec2(.64,.04)), vec2(.04,.01)));\n    icon_d = min(icon_d, sdBox((1.+.1*ANIM_ICON(g.mode, 2))*(p-vec2(.64,.04)), vec2(.01,.04)));\n    col = mix(col, vec3(1.,.73, 0.), 1.-step(0., sdBox(p - vec2(float(g.mode) * .3, 0), vec2(.1))));\n    p.x = p.x - .3*clamp(round(p.x/.3), 0., 2.);\n    icon_d = min(icon_d, abs(sdBox(p, vec2(.09))-.01)-.005);\n    col = mix(col, vec3(1), 1.-smoothstep(.0, 0.004, icon_d));    \n   \n    fragColor = vec4(pow(col,vec3(1.21)),1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common\n\n// Constants\n#define PI (3.141592)\n#define FLT_MAX (1e12)\n#define EPS (1e-12)\n\n// Engine internals\n#define GRAVITY (vec2(0,-1.)) \n#define ALLOWED_PENETRATION (.0005)\n#define K_BIAS_FACTOR (.2)\n#define MAX_VELOCITY (10.)\n#define MAX_ANG_VELOCITY (100.)\n\n// Factory example \n#define SPAWN_COOLDOWN (.05)\n#define VIEW_ZOOM (1.4+.1*exp(-iTime))\n#define VIEW_OFFSET (vec2(0,.05))\n#define VIEW(P) (VIEW_ZOOM*(2.0*(P).xy-iResolution.xy)/iResolution.y+VIEW_OFFSET)\n#define FACTORY_FIXED_BODIES (70)\n#define FACTORY_MOVING_BODIES (60)\n#define FACTORY_JOINTS (30)\n#define BOX_SIZE 1.*(.03 + vec2(.03*rnd.xz))\n#define BOX_MASS (.05)\n#define BOX_FRICTION (10.)\n#define INIT_SEED (int(3. + 1.*iDate.w*100.))\n\n#define MOUSE_DOWN (iMouse.z > 0.)\n\nvec3 hash31(uint q) // https://www.shadertoy.com/view/XdGfRR\n{\n\tuvec3 n = q * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn vec3(n) * 2.328306437080797e-10;\n}\n\nfloat rcp(float x) { return 1. / x; }\nvec2 rcp(vec2 v) { return vec2(rcp(v.x), rcp(v.y)); }\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nfloat dot2(vec2 v) { return dot(v, v); }\nfloat cross2(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\nvec2 cross2(vec2 a, float b) { return vec2(a.y * b, a.x * -b); }\nvec2 cross2(float a, vec2 b) { return vec2(b.y * -a, b.x * a); }\nfloat smoothsquare(float x, float eps) { float s = sin(2.*PI*x); return .5+.5*s*rcp(sqrt(s*s+eps*eps)); }\nmat2 m_abs(mat2 m) { return mat2(abs(m[0]), abs(m[1])); }\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nstruct Globals\n{\n    ivec2 res;\n    int n_body;\n    int n_joint;\n    float time;\n    // factory example specific fields :\n    float t_added; \n    int n_funnel;\n    int funnel_b_id;\n    int mode;\n};\n\n#define size_of_Globals (9)\n#define pixel_count_of_Globals (3)\n\nstruct Body \n{\n    vec2 pos;    \n    vec2 vel;\n    \n    float ang;\n    float ang_vel;\n    \n    vec2 size;\n    float inv_mass;\n    float inv_friction;\n    float inv_i;\n};\n\n#define size_of_Body (11)\n#define pixel_count_of_Body (3)\n\nstruct Joint\n{\n    int b0_id;\n    int b1_id;\n    vec2 loc_anc0;\n    vec2 loc_anc1;\n    float bias_factor;\n    float softness;\n    vec2 r0;\n    vec2 r1;\n    mat2 M;\n    vec2 bias;\n    vec2 P;\n};\n\n#define size_of_Joint (20)\n#define pixel_count_of_Joint (5)\n\nstruct Contact\n{\n    vec2 pos;\n    vec2 normal;\n    float sep;\n    \n    float mass_n;\n    float mass_t;\n    float bias;\n};\n\n#define size_of_Contact (8)\n#define pixel_count_of_Contact (2)\n\nint address(int width, ivec2 addr2D)\n{\n    return addr2D.x + addr2D.y * width; \n}\n\nint bufferAddress(sampler2D buff, ivec2 addr2D)\n{\n    return address(textureSize(buff, 0).x, addr2D);\n}\n\nivec2 address2D(int width, int addr)\n{\n    return ivec2(addr % width, addr / width);\n}\n\nivec2 address2D(ivec2 res, int addr)\n{\n    return address2D(res.x, addr);\n}\n\nivec2 address2D(vec2 res, int addr)\n{\n    return address2D(int(res.x), addr);\n}\n\nivec2 bufferAddress2D(sampler2D buff, int addr)\n{\n    return address2D(textureSize(buff, 0).x, addr);\n}\n\nint bodyStartAddress() \n{ \n    return pixel_count_of_Globals; \n}\n\nint bodyAddress(int b_id)\n{\n    return bodyStartAddress() + pixel_count_of_Body * b_id;\n}\n\nint jointStartAddress(Globals g) \n{ \n    return bodyStartAddress() + g.n_body * pixel_count_of_Body; \n}\n\nint jointAddress(Globals g, int j_id)\n{\n    return jointStartAddress(g) + pixel_count_of_Joint * j_id;\n}\n\nint contactStartAddress(Globals g)\n{\n    return jointStartAddress(g) + g.n_joint * pixel_count_of_Joint;\n}\n\nint contactAddress(Globals g, int c_id)\n{\n    return contactStartAddress(g) + pixel_count_of_Contact * c_id;\n}\n\nint nContact(Globals g)\n{\n    return g.n_body * (g.n_body - 1); // one contact foreach pair of body\n}\n\nint jointMax() // linear space in memory\n{ \n    return 1000; \n}\n\nint bodyMax(ivec2 res) //  quadratic space in memory because of contacts\n{\n    float c = float(pixel_count_of_Globals+pixel_count_of_Joint*jointMax()-res.x*res.y);\n    float sb = float(pixel_count_of_Body);\n    float sc = float(pixel_count_of_Contact);\n    float sbc = sb - sc;\n    return int((sqrt(sbc*sbc-4.*sc*c)-(sbc))/(2.*sc));\n}\n\nGlobals loadGlobals(sampler2D buff)\n{\n    Globals g;\n    vec4 data0 = texelFetch(buff, bufferAddress2D(buff, 0), 0);\n    vec4 data1 = texelFetch(buff, bufferAddress2D(buff, 1), 0);\n    vec4 data2 = texelFetch(buff, bufferAddress2D(buff, 2), 0);\n    g.res = ivec2(data0.xy);\n    g.n_body = int(data0.z);\n    g.n_joint = int(data0.w);\n    g.time = data1.x;\n    g.t_added = data1.y;\n    g.n_funnel = int(data1.z);\n    g.funnel_b_id = int(data1.w);\n    g.mode = int(data2.x);\n    return g;\n}\n\nvoid storeGlobals(int buff_w, Globals g, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int fragAddr = address(buff_w, fragCoord);\n\n    if(fragAddr == 0) fragColor = vec4(g.res, g.n_body, g.n_joint);\n    if(fragAddr == 1) fragColor = vec4(g.time, g.t_added, g.n_funnel, g.funnel_b_id);\n    if(fragAddr == 2) fragColor = vec4(g.mode, -1, -1, -1);\n}\n\nBody loadBody(sampler2D buff, ivec2 res, int b_id)\n{\n    Body b;\n    \n    int addr = bodyAddress(b_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(res, addr+1), 0);\n    vec4 data2 = texelFetch(buff, address2D(res, addr+2), 0);\n    \n    b.pos = data0.xy;\n    b.vel = data0.zw;\n    \n    b.ang = data1.x;\n    b.ang_vel = data1.y;\n    \n    b.size = data1.zw;\n    b.inv_mass = data2.x;\n    b.inv_friction = data2.y;\n    b.inv_i = data2.z;\n    \n    return b;\n}\n\nBody loadBody(sampler2D buff, int b_id)\n{\n    return loadBody(buff, textureSize(buff, 0), b_id);\n}\n\nvoid storeBody(int res_x, int b_id, Body b, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = bodyAddress(b_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(b.pos, b.vel);\n    if(fragAddr == addr + 1) fragColor = vec4(b.ang, b.ang_vel, b.size);\n    if(fragAddr == addr + 2) fragColor = vec4(b.inv_mass, b.inv_friction, b.inv_i, -1);\n}\n\nfloat computeInvI(Body b)\n{\n    return 12. * b.inv_mass / dot2(b.size);\n}\n\nJoint loadJoint(sampler2D buff, Globals g, int j_id)\n{\n    Joint j;\n    \n    int addr = jointAddress(g, j_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(g.res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(g.res, addr+1), 0);\n    vec4 data2 = texelFetch(buff, address2D(g.res, addr+2), 0);\n    vec4 data3 = texelFetch(buff, address2D(g.res, addr+3), 0);\n    vec4 data4 = texelFetch(buff, address2D(g.res, addr+4), 0);\n    \n    j.b0_id = int(data0.x);\n    j.b1_id = int(data0.y);\n    j.loc_anc0 = data0.zw;\n    j.loc_anc1 = data1.xy;\n    j.bias_factor = data1.z;\n    j.softness = data1.w;\n    j.r0 = data2.xy;\n    j.r1 = data2.zw;\n    j.M = mat2(data3);\n    j.bias = data4.xy;\n    j.P = data4.zw;\n    \n    return j;\n}\n\nvoid storeJoint(int res_x, Globals g, int j_id, Joint j, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = jointAddress(g, j_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(float(j.b0_id), float(j.b1_id), j.loc_anc0);\n    if(fragAddr == addr + 1) fragColor = vec4(j.loc_anc1, j.bias_factor, j.softness);\n    if(fragAddr == addr + 2) fragColor = vec4(j.r0, j.r1);\n    if(fragAddr == addr + 3) fragColor = vec4(j.M);\n    if(fragAddr == addr + 4) fragColor = vec4(j.bias, j.P);\n}\n\nContact loadContact(sampler2D buff, Globals g, int c_id)\n{\n    Contact c;\n    \n    int addr = contactAddress(g, c_id);\n    \n    vec4 data0 = texelFetch(buff, address2D(g.res, addr), 0);\n    vec4 data1 = texelFetch(buff, address2D(g.res, addr+1), 0);\n    \n    c.pos = data0.xy;\n    c.normal = data0.zw;\n    c.sep = data1.x;\n\n    c.mass_n = data1.y;\n    c.mass_t = data1.z;\n    c.bias = data1.w;\n    \n    return c;\n}\n\nvoid storeContact(int res_x, Globals g, int c_id, Contact c, ivec2 fragCoord, inout vec4 fragColor)\n{\n    int addr = contactAddress(g, c_id);\n    int fragAddr = address(res_x, fragCoord);\n    \n    if(fragAddr == addr) fragColor = vec4(c.pos, c.normal);\n    if(fragAddr == addr + 1) fragColor = vec4(c.sep, c.mass_n, c.mass_t, c.bias);\n}\n\n#define INVALID_VALUE -10000.\nvoid setInvalidContact(inout Contact c)\n{\n    c.pos.x = INVALID_VALUE;\n}\n\nbool isContactValid(Contact c)\n{\n    return c.pos.x > INVALID_VALUE + 1.;\n}\n\n// overload so we don't have to sample the entire contact\nbool isContactValid(sampler2D buff, Globals g, int c_id)\n{\n    int addr = contactAddress(g, c_id);\n    float posx = texelFetch(buff, address2D(g.res, addr), 0).x;\n    return posx > INVALID_VALUE + 1.;\n}\n\nvoid getContactBodyIds(int c_id, out int b0_id, out int b1_id)\n{\n    c_id = c_id / 2; // 2 contacts per pair\n    \n    int i = int((1.+sqrt(1.+8.*float(c_id)))/2.);\n    int j = c_id - (i*(i-1))/2;\n    \n    b0_id = min(i, j);\n    b1_id = max(i, j);\n}\n\nint getContactId(int b0_id, int b1_id)\n{\n    if(b0_id < b1_id) return b0_id +(b1_id*(b1_id-1))/2;\n    return b1_id +(b0_id*(b0_id-1))/2;\n}\n\nvoid applyContactImpulse(inout Body b0, inout Body b1, inout Contact c)\n{\n    vec2 r0 = c.pos - b0.pos;\n    vec2 r1 = c.pos - b1.pos;\n\n    vec2 dv = b1.vel + cross2(b1.ang_vel, r1) - b0.vel - cross2(b0.ang_vel, r0);\n    float v_n = dot(dv, c.normal);\n    float dp_n = c.mass_n * (-v_n + c.bias); \n    dp_n = max(0., dp_n); \n\n    vec2 p_n = dp_n * c.normal;\n\n    // Normal impulse\n    b0.vel -= b0.inv_mass * p_n;\n    b0.ang_vel -= b0.inv_i * cross2(r0, p_n); \n\n    b1.vel += b1.inv_mass * p_n;\n    b1.ang_vel += b1.inv_i * cross2(r1, p_n); \n\n    dv = b1.vel + cross2(b1.ang_vel, r1) - b0.vel - cross2(b0.ang_vel, r0);\n    vec2 tangent = cross2(c.normal, 1.);\n    float v_t = dot(dv, tangent);\n    float dp_t = c.mass_t * (-v_t);\n    float friction = sqrt(b0.inv_friction * b1.inv_friction);\n    float max_friction = abs(friction * dp_n);\n    dp_t = clamp(dp_t, -max_friction, max_friction);\n\n    vec2 p_t = dp_t * tangent;\n\n    // Tangent impulse\n    b0.vel -= b0.inv_mass * p_t;\n    b0.ang_vel -= b0.inv_i * cross2(r0, p_t); \n\n    b1.vel += b1.inv_mass * p_t;\n    b1.ang_vel += b1.inv_i * cross2(r1, p_t);\n}\n\nvec2 computeJointImpulse(Body b0, Body b1, Joint j)\n{\n    vec2 dv = b1.vel + cross2(b1.ang_vel, j.r1) - b0.vel - cross2(b0.ang_vel, j.r0);\n    vec2 impulse = j.M * (j.bias - dv - j.softness * j.P);\n    return impulse;\n}\n\nvoid applyJointImpulse(inout Body b0, inout Body b1, inout Joint j)\n{\n    vec2 impulse = computeJointImpulse(b0, b1, j);\n    \n    b0.vel -= b0.inv_mass * impulse;\n    b0.ang_vel -= b0.inv_i * cross2(j.r0, impulse);\n\n    b1.vel += b1.inv_mass * impulse;\n    b1.ang_vel += b1.inv_i * cross2(j.r1, impulse);\n\n    j.P += impulse;\n}\n\nbool isInvisibleBody(int b_id)\n{\n    return (b_id >= 67 && b_id <= 69);\n}\n\nvoid initGlobals(ivec2 res, inout Globals g)\n{\n    g.res = res;\n    g.n_body = FACTORY_FIXED_BODIES + FACTORY_MOVING_BODIES;\n    g.n_joint = FACTORY_JOINTS;\n    g.time = 0.;\n    g.t_added = -1.;\n    g.n_funnel = 0;\n    g.funnel_b_id = -1;\n    g.mode = 2;\n}\n\n// Applying the impulses from contacts and joints\n// Theoretically, the more iterations the better, here we have 3, each in buffer B/C/D\n// Reference code uses 10 iterations and is single threaded, so each iteration uses updated bodies velocities\n// Here we can only use the velocities from previous iteration, and that's why stacking is not possible (i think)\n// Using accumulated impulses (as in reference) and multiple frames to reach ~12 iterations did not help\nvoid physicsIteration(out vec4 fragColor, vec2 fragCoord, vec2 iResolution, sampler2D prev_buff)\n{\n    fragColor = vec4(-1);\n    \n    Globals g = loadGlobals(prev_buff);\n\n    int res_x = int(iResolution.x);\n    int id = address(res_x, ivec2(fragCoord));\n    int g_id = id / pixel_count_of_Globals;\n    int b_id = (id - bodyStartAddress()) / pixel_count_of_Body;\n    int j_id = (id - jointStartAddress(g)) / pixel_count_of_Joint;\n    int c_id = (id - contactStartAddress(g)) / pixel_count_of_Contact;\n    if(g_id == 0) // Globals\n    {\n        // Copy\n        fragColor = texelFetch(prev_buff, ivec2(fragCoord), 0);\n    }\n    else if(b_id >= 0 && b_id < g.n_body) // Body\n    {\n        // Load\n        Body b = loadBody(prev_buff, b_id);\n\n        // Apply contact impulses\n        // Iterate contacts pointing to this body\n        for(int i = 0; i < g.n_body; i++) //\n        {\n            if(i == b_id) continue;\n            Body b_i = loadBody(prev_buff, i);\n\n            int c_id = getContactId(b_id, i);\n            for(int j = 0; j < 2; j++)\n            {\n                int c_ij_id = 2 * c_id + j;\n\n                if(!isContactValid(prev_buff, g, c_ij_id)) continue;\n                Contact c = loadContact(prev_buff, g, c_ij_id);\n\n                if(b_id > i)\n                {\n                    applyContactImpulse(b_i, b, c);\n                }\n                else\n                {\n                    applyContactImpulse(b, b_i, c);\n                }\n            }        \n        }\n       \n        // Apply joint impulses\n        // Iterate every joint pointing to this body\n        for(int joint_id = 0; joint_id < g.n_joint; joint_id++)\n        {\n            Joint j = loadJoint(prev_buff, g, joint_id);\n            if(j.b0_id == b_id)\n            {\n                Body b1 = loadBody(prev_buff, j.b1_id);\n                applyJointImpulse(b, b1, j);\n            }\n            else if(j.b1_id == b_id)\n            {\n                Body b0 = loadBody(prev_buff, j.b0_id);\n                applyJointImpulse(b0, b, j);\n            }\n        }\n       \n        // Store\n        storeBody(res_x, b_id, b, ivec2(fragCoord), fragColor);\n    }\n    else if(j_id >= 0 && j_id < g.n_joint) // Joint\n    {\n        // Load \n        Joint j = loadJoint(prev_buff, g, j_id);\n        \n        // Accumulate impulse\n        Body b0 = loadBody(prev_buff, j.b0_id);\n        Body b1 = loadBody(prev_buff, j.b1_id);\n        applyJointImpulse(b0, b1, j);\n        \n        // Store\n        storeJoint(res_x, g, j_id, j, ivec2(fragCoord), fragColor);\n    }\n    else if(c_id >= 0 && c_id < nContact(g)) // Contact\n    {\n        // Copy\n        fragColor = texelFetch(prev_buff, ivec2(fragCoord), 0);\n    }\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Physics Integration (and scene initialization)\n\nint clipSegmentToLine(vec2 p0, vec2 p1, vec2 normal, float offset,\n inout vec2 out_p0, inout vec2 out_p1)\n{\n    int out_n = 0;\n    \n    // Distance to plane\n    float dist0 = dot(normal, p0) - offset;\n    float dist1 = dot(normal, p1) - offset;\n    \n    // If points are behind the plane\n    if(dist0 <= 0.) { out_n += 1; out_p0 = p0;  }\n    if(dist1 <= 0.) { out_n += 1; if(out_n == 1) out_p0 = p1; else out_p1 = p1; }\n    \n    // If points are on different sides of the plane\n    if(dist0 * dist1 < 0.)\n    {\n        out_n += 1;\n        vec2 p = mix(p0, p1, dist0 / (dist0 - dist1)); \n        if(out_n == 1) out_p0 = p; else out_p1 = p;\n    }\n    \n    return out_n;\n}\n\nvoid computeIncidentEdge(vec2 h, vec2 pos, mat2 rot, mat2 rot_t, vec2 normal, \n inout vec2 clip_p0, inout vec2 clip_p1)\n{\n    vec2 n = -(rot_t * normal);\n    vec2 nAbs = abs(n);\n    if(nAbs.x > nAbs.y)\n    {\n        float s = 2.*step(0., n.x)-1.;\n        clip_p0 = vec2(s, -s) * h;\n        clip_p1 = s * h;\n    }\n    else\n    {\n        float s = 2.*step(0., n.y)-1.;\n        clip_p0 = s * h;\n        clip_p1 = vec2(-s, s) * h;\n    }\n    \n    clip_p0 = pos + rot * clip_p0; \n    clip_p1 = pos + rot * clip_p1; \n}\n\nvoid trySeparatingAxis(float face, float h, int axis, vec2 sc, float d,\n inout int sep_axis, inout float sep, inout vec2 normal) \n{\n    const float tol_rel = .95;\n    const float tol_abs = .1;\n    \n    if(face > tol_rel * sep + tol_abs * h)\n    {\n        sep_axis = axis;\n        sep = face;\n        normal = d > 0. ? sc : -sc;\n    }\n}\n\nbool ignoreCollision(int b0_id, int b1_id) // This assumes b0_id < b1_id\n{\n    if(isInvisibleBody(b1_id)) return true; // only check b1_id since invisible bodies are highest hand-placed ids\n    return false;\n}\n\nvoid collide(int c_id, int b0_id, Body b0, int b1_id, Body b1, inout Contact c)\n{\n    setInvalidContact(c);\n\n    if(b0.inv_mass == 0. && b1.inv_mass == 0.) return;\n    if(ignoreCollision(b0_id, b1_id)) return; \n\n    // Setup\n    vec2 h0 = b0.size;\n    vec2 h1 = b1.size;\n    \n    mat2 rot0 = rot(b0.ang);\n    mat2 rot1 = rot(b1.ang);\n    \n    mat2 rot0_t = transpose(rot0); // rot(-b0.ang)\n    mat2 rot1_t = transpose(rot1);\n\n    vec2 dp = b1.pos - b0.pos;\n    vec2 d0 = rot0_t * dp;\n    vec2 d1 = rot1_t * dp;\n\n    mat2 m = m_abs(rot0_t * rot1); \n    mat2 m_t = transpose(m);\n\n    vec2 face0 = abs(d0) - m * h1 - h0;\n    if(face0.x > 0. || face0.y > 0.) return;\n    \n    vec2 face1 = abs(d1) - m_t * h0 - h1;\n    if(face1.x > 0. || face1.y > 0.) return;\n    \n    // Find separating axis\n    int sep_axis = 0;\n    float sep = face0.x;\n    vec2 normal = d0.x > 0. ? rot0[0] : -rot0[0];\n    \n    trySeparatingAxis(face0.y, h0.y, 1, rot0[1], d0.y, sep_axis, sep, normal);\n    trySeparatingAxis(face1.x, h1.x, 2, rot1[0], d1.x, sep_axis, sep, normal);\n    trySeparatingAxis(face1.y, h1.y, 3, rot1[1], d1.y, sep_axis, sep, normal);\n    \n    vec2 ref_normal = vec2(-1);\n    float ref_side = -1.;\n    vec2 clip_normal = vec2(-1);\n    vec2 clip_sides = vec2(-1);\n    vec2 clip_p0 = vec2(-1);\n    vec2 clip_p1 = vec2(-1);\n    \n    // Setup clipping plane\n    if(sep_axis == 0)\n    {\n        ref_normal = normal;\n        ref_side = dot(b0.pos, ref_normal) + h0.x;\n        clip_normal = rot0[1];\n        float clip_side = dot(b0.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h0.y;\n        computeIncidentEdge(h1, b1.pos, rot1, rot1_t, ref_normal, clip_p0, clip_p1);\n    }\n    else if(sep_axis == 1)\n    {\n        ref_normal = normal;\n        ref_side = dot(b0.pos, ref_normal) + h0.y;\n        clip_normal = rot0[0];\n        float clip_side = dot(b0.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h0.x;\n        computeIncidentEdge(h1, b1.pos, rot1, rot1_t, ref_normal, clip_p0, clip_p1);\n    }\n    else if(sep_axis == 2)\n    {\n        ref_normal = -normal;\n        ref_side = dot(b1.pos, ref_normal) + h1.x;\n        clip_normal = rot1[1];\n        float clip_side = dot(b1.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h1.y;\n        computeIncidentEdge(h0, b0.pos, rot0, rot0_t, ref_normal, clip_p0, clip_p1);\n    }\n    else\n    {\n        ref_normal = -normal;\n        ref_side = dot(b1.pos, ref_normal) + h1.y;\n        clip_normal = rot1[0];\n        float clip_side = dot(b1.pos, clip_normal);\n        clip_sides = vec2(-clip_side, clip_side) + h1.x;\n        computeIncidentEdge(h0, b0.pos, rot0, rot0_t, ref_normal, clip_p0, clip_p1);\n    }\n    \n    // Clip\n    vec2 clip1_p0 = vec2(-1);\n    vec2 clip1_p1 = vec2(-1);\n    vec2 clip2_p0 = vec2(-1);\n    vec2 clip2_p1 = vec2(-1);\n    \n    int np = clipSegmentToLine(clip_p0, clip_p1, -clip_normal, clip_sides.x, clip1_p0, clip1_p1);\n    if(np < 2) return;\n    \n    np = clipSegmentToLine(clip1_p0, clip1_p1, clip_normal, clip_sides.y, clip2_p0, clip2_p1);\n    if(np < 2) return;\n\n    // Fill contact\n    vec2 c_p = (c_id % 2 == 0) ? clip2_p0 : clip2_p1;\n    float c_sep = dot(ref_normal, c_p) - ref_side;\n    if(c_sep <= 0.)\n    {\n        c.pos = c_p - c_sep * ref_normal;\n        c.normal = normal;\n        c.sep = c_sep;        \n    }\n}\n\n// Compute some values for the contact, maybe it's not worth losing 3 floats in the buffer if you want more bodies\nvoid preStepContact(float dt, Body b0, Body b1, inout Contact c)\n{\n    // because values are still from the previous frame we should integrated values (i don't see much difference)\n    \n    vec2 r0 = c.pos - (b0.pos + dt * b0.vel);\n    vec2 r1 = c.pos - (b1.pos + dt * b1.vel);\n    \n    float rn0 = dot(r0, c.normal);\n    float rn1 = dot(r1, c.normal);\n    \n    float k_normal = b0.inv_mass + b1.inv_mass + b0.inv_i * (dot2(r0) - rn0*rn0) + b1.inv_i * (dot2(r1) - rn1*rn1); \n    c.mass_n = 1. / k_normal;\n    \n    vec2 tangent = cross2(c.normal, 1.);\n    float rt0 = dot(r0, tangent);\n    float rt1 = dot(r1, tangent);\n    float k_tangent = b0.inv_mass + b1.inv_mass + b0.inv_i * (dot2(r0) - rt0*rt0) + b1.inv_i * (dot2(r1) - rt1*rt1); \n    c.mass_t = 1. / k_tangent;\n    \n    c.bias = -K_BIAS_FACTOR * (1. / dt) * min(0., c.sep + ALLOWED_PENETRATION);\n}\n\nvoid preStepJoint(Body b0, Body b1, float dt, inout Joint j)\n{\n    mat2 rot0 = rot(b0.ang);\n    mat2 rot1 = rot(b1.ang);\n    j.r0 = rot0 * j.loc_anc0;\n    j.r1 = rot1 * j.loc_anc1;\n\n    mat2 k1 = (b0.inv_mass + b1.inv_mass) * mat2(1, 0, 0, 1);\n    mat2 k2 = b0.inv_i * mat2(j.r0.y * j.r0.y, -j.r0.x * j.r0.y, - j.r0.x * j.r0.y, j.r0.x * j.r0.x);\n    mat2 k3 = b1.inv_i * mat2(j.r1.y * j.r1.y, -j.r1.x * j.r1.y, - j.r1.x * j.r1.y, j.r1.x * j.r1.x);\n    \n    mat2 k = k1 + k2 + k3 + mat2(j.softness, 0, 0, j.softness);\n    j.M = inverse(k);\n    \n    vec2 p0 = b0.pos + j.r0;\n    vec2 p1 = b1.pos + j.r1;\n    vec2 dp = p1 - p0;\n    j.bias = -j.bias_factor * (1. / dt) * dp; \n    \n    j.P = vec2(0);\n}\n\nvoid addBody(inout Body b)\n{\n    vec3 rnd = hash31(uint(iFrame+int(iMouse.x)));\n    b.pos = VIEW(iMouse);\n    b.ang = rnd.z;\n    b.vel = 3.*vec2(rnd.x-.5, rnd.y);\n    b.size = BOX_SIZE;\n    b.inv_mass = rcp(BOX_MASS);\n    b.inv_friction = rcp(BOX_FRICTION);\n    b.inv_i = computeInvI(b);\n}\n\nvec2 getForce(Globals g, int b_id, Body b)\n{\n    vec2 m_force = vec2(0.0);\n    if(iMouse.z > 0.5 && g.mode <= 1) \n    {\n        vec2 m = VIEW(iMouse.xy);\n        vec2 dir = ( b.pos - m);\n        m_force = -sign(float(g.mode)-.5) * .05 * dir / (dot2(dir)); // repulsive or attractive force\n    }\n\n    if(b_id == 21) m_force = 15.*vec2(sin(2.*g.time), 0.); // spring\n    if(b_id == 26) m_force = fract(g.time * .1) > .5 ? vec2(7,0) : vec2(0); // pinch\n    if(b_id == 27) m_force = fract(g.time * .1) > .5 ? vec2(-7,0) : vec2(0); // pinch\n\n    if(b.inv_mass > 0.)  return b.inv_mass * m_force + GRAVITY;\n    return vec2(0);\n   \n}\n\nfloat getTorque(Globals g, int b_id, Body b)\n{\n    float torque = 0.;\n    if(b_id >= 8 && b_id <= 9 && b.ang_vel < 2.) torque = 2.;\n    if(b_id >= 10 && b_id <= 16 && b.ang_vel < 7.) torque = 7.;\n    if(b_id == 23 && b.ang_vel < 2.) torque = 2.;\n    if(b_id == 25 && b.ang_vel > -3.) torque = -2.;\n    if(b_id >= 30 && b_id <= 36 && b.ang_vel > -7.) torque = -7.;\n    if(b_id >= 42 && b_id <= 43 && b.ang_vel < 2.) torque = 2.;\n    if(b_id >= 57 && b_id <= 62 && b.ang_vel > -5.) torque = -5.;\n    \n    if(b.inv_i == 0.) return torque;\n    return torque * b.inv_i;\n}\n\nvoid jointAnimation(Globals g, int j_id, inout Joint j)\n{\n    // Pinch\n    if(j_id == 11 || j_id == 12) j.softness = mix(20., .5, smoothsquare(g.time * .1, .1)); // vertical\n    if(j_id == 13 || j_id == 14) j.softness = mix(10., .5, smoothsquare(g.time * .1 + .1, .1)); // pinching\n\n    // Bottom-right spring\n    if(j_id >= 17 && j_id <= 20) j.softness = fract(g.time * .1 + .1) < .9 ? 50. : .2; \n}\n\n// Add some fun setting up a scene to showcase the capabilities of the system (slowing compilation though)\nvoid initBody(Globals g, int b_id, inout Body b)\n{\n    b = Body(vec2(0), vec2(0), 0., 0., vec2(0), 0., 0., 0.);\n\n    // Factory\n    vec2 p = vec2(0);\n    b.inv_friction = 0.1;\n    if(b_id <= 3) // Four walls 0 - 3\n    { \n        if      (b_id == 0) { b.pos = vec2(0,-2.15); b.size = vec2(1.8,1); }\n        else if (b_id == 1) { b.pos = vec2(0,2.1); b.size = vec2(3,1); }\n        else if (b_id == 2) { b.pos = vec2(-3,0); b.size = vec2(1,2); }\n        else                { b.pos = vec2(3,0); b.size = vec2(1,2); }\n    }\n    else if (b_id <= 7) // Funnel 4 - 7\n    {\n        p = vec2(-1.5, .5);\n        if      (b_id == 4) { b.pos = p+vec2(.3,0); b.size = vec2(.4,.02); b.ang = PI*.3; }\n        else if (b_id == 5) { b.pos = p+vec2(-.3,0); b.size = vec2(.4,.02); b.ang = -PI*.3; }\n        else if (b_id == 6) { b.pos = p+vec2(-.075,-.37); b.size = vec2(.02,.06); }\n        else                { b.pos = p+vec2(.075,-.37); b.size = vec2(.02,.06); }\n    }\n    else if (b_id <= 9) // Top Mill 8 - 9\n    {\n        b.pos = vec2(-1.5, .5);\n        b.size = (b_id == 9) ? vec2(.2,.02) : vec2(.02,.2);\n    }\n    else if (b_id <= 16) // Up treadmill 10 - 16\n    {\n        b.pos = vec2(-.8, .8) + float(b_id-10) * vec2(.2, -.1);\n        b.ang = (b_id % 2 == 0) ? 0. : PI*.25;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 21) // Spring 17 - 21\n    {\n        b.pos = vec2(-2.02, -.82) + vec2(float(b_id-17) *.15, 0);\n        b.size = (b_id == 21) ? vec2(.06,.1) : vec2(.02,.1);\n        b.inv_mass = (b_id == 17) ? 0. : rcp(10.);\n    }\n    else if (b_id <= 24) // Flipper 22 - 24\n    {\n        p = vec2(-2., -.82);\n        if      (b_id == 22) { b.pos = p+vec2(1.75,-.16); b.ang = -.05; b.size = vec2(.45,.04); b.inv_mass = rcp(20.); }\n        else if (b_id == 23) { b.pos = p+vec2(2.3,-.2); b.ang = 1.; b.size = vec2(.2, .02); }\n        else                 { b.pos = p+vec2(.2,-.5); b.size = vec2(1.1,.4); }// Bottom Edge\n    }\n    else if (b_id <= 29) // Pinch 25 - 29\n    {\n        p = vec2(1.,.2);\n        if      (b_id == 25) { b.pos = p+vec2(0,.5); b.size = vec2(.27, 0.03); }\n        else if (b_id == 26) { b.pos = p+vec2(.175,.2); b.ang = PI*.25; b.size = vec2(.2, .03); }\n        else if (b_id == 27) { b.pos = p+vec2(-.175,.2); b.ang = -PI*.25; b.size = vec2(.2, .03); }\n        else if (b_id == 28) { b.pos = p+vec2(-.34,.5); b.size = vec2(.06, .03); }\n        else                 { b.pos = p+vec2(.34,.5); b.size = vec2(.06, .03); }\n        b.inv_mass = b_id <= 27 ? rcp(10.) : rcp(1.);\n    }\n    else if (b_id <= 36) // Top treadmill 30 - 36\n    {\n        b.pos = vec2(-.8, 1.1) + vec2(float(b_id-30)*.2, 0);\n        b.ang = (b_id % 2 == 0) ? 0. : PI*.25;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 41) // Bottom basin 37 - 41\n    {\n        p = vec2(1.,-.8);\n        if      (b_id == 37) { b.pos = p; b.size = vec2(.14,.04); }\n        else if (b_id == 38) { b.pos = p+vec2(-.26, .16); b.ang = PI*.25; b.size = vec2(.04,.16); }\n        else if (b_id == 39) { b.pos = p+vec2(.26, .16); b.ang = -PI*.25; b.size = vec2(.04,.16); }\n        else if (b_id == 40) { b.pos = p+vec2(-.44, -.1); b.size = vec2(.04,.4); }\n        else                 { b.pos = p+vec2(.545, .05); b.size = vec2(.16,.25); }\n        b.inv_mass = (b_id <= 39) ? rcp(.5) : 0.;\n    }\n    else if (b_id <= 43) // Center Mill 42 - 43\n    {\n        b.pos = vec2(0., -.2);\n        b.size = (b_id == 42) ? vec2(.4,.02) : vec2(.02,.4);\n    }\n    else if (b_id <= 46) // Right spring 44 - 46\n    {\n        p = vec2(1.9, -1.28);\n        b.pos = p + vec2(0, float(b_id-44)*.3);\n        b.size = vec2(.09,.03);\n        b.inv_mass = (b_id == 44) ? 0. : rcp(40.);\n    }\n    else if (b_id <= 47) // Right trapdoor 47\n    {\n        b.pos = vec2(1.5,.92); b.size = vec2(.025,.09); b.inv_mass = rcp(.05);\n    }\n    else if (b_id <= 56) // Right pipe 48 - 56\n    {\n        if      (b_id == 48) { b.pos = vec2(1.65,-.15); b.size = vec2(.16,.85); }\n        else if (b_id == 49) { b.pos = vec2(2.48,1.13); b.ang = .4; b.size = vec2(.6,.6); }\n        else if (b_id == 50) { b.pos = vec2(3.29,1.37); b.ang = .8; b.size = vec2(.6,.4); }\n        else if (b_id == 51) { b.pos = vec2(2.,1.54); b.ang = 1.2; b.size = vec2(.6,.8); }\n        else if (b_id == 52) { b.pos = vec2(1.69,1.11); b.size = vec2(.2,.1); }\n        else if (b_id == 53) { b.pos = vec2(1.7,.69); b.ang = .52; b.size = vec2(.1,.05); }\n        else if (b_id == 54) { b.pos = vec2(1.68,.71); b.ang = 1.04; b.size = vec2(.1,.05); }\n        else if (b_id == 55) { b.pos = vec2(1.59,.74); b.size = vec2(.1,.08); }\n        else                 { b.pos = vec2(1.9,-1.45); b.size = vec2(.4,.2); }\n        b.inv_friction = .001;\n    }\n    else if (b_id <= 62) // Down treadmill 57 - 62\n    {\n        b.pos = vec2(.7, -1.2) + vec2(float(b_id-57)*.2,0);\n        b.ang = (b_id % 2 == 0) ? PI*.25 : 0.;\n        b.size = vec2(.04,.1);\n    }\n    else if (b_id <= 66) // Down ramps 63 - 66\n    {\n        p = vec2(-1.5, -.15);\n        if      (b_id == 63) { b.pos = p; b.ang = -PI*.05; b.size = vec2(.6,.02); }\n        else if (b_id == 64) { b.pos = p+vec2(.6,-.3); b.ang = PI*.05; b.size = vec2(.4,.02); }\n        else if (b_id == 65) { b.pos = p+vec2(1.,.15); b.size = vec2(.02,.4); }\n        else                 { b.pos = p+vec2(-.2,-.5); b.ang = -PI*.05; b.size = vec2(.3,.02); }\n        b.inv_friction = .001;\n    }\n    else if (b_id <= 69) // Invisible boxes 67 - 69 (to prevent boxes from being stuck)\n    {\n        if      (b_id == 67) { b.pos = vec2(-1.75,-.82); b.ang = -PI*.05; b.size = vec2(.32,.16); }\n        else if (b_id == 68) { b.pos = vec2(-.36,-1.18); b.ang = -PI*.1; b.size = vec2(.42,.12); }\n        else                 { b.pos = vec2(1.9,-1.25); b.size = vec2(.12,.1); }\n        b.inv_friction = .1;\n    }\n    else // Dynamic Boxes 70+\n    {\n        vec3 rnd = hash31(uint(b_id+INIT_SEED));\n        b.pos = vec2(3., 1.5)*(rnd.xy-vec2(.6,.4));\n        b.ang = rnd.z;\n        b.size = BOX_SIZE;\n        b.inv_mass = rcp(BOX_MASS);\n        b.inv_friction = rcp(BOX_FRICTION);\n    }     \n\n    b.inv_i = computeInvI(b); \n}\n\n// Some helpers for initializing joint (the anchor position is most of the time dependant on bodies positions)\nvoid initJoint(int b0_id, int b1_id, vec2 loc_anc0, vec2 loc_anc1, inout Joint j)\n{\n    if (b0_id <= b1_id)\n    {\n        j.b0_id = b0_id; j.loc_anc0 = loc_anc0;\n        j.b1_id = b1_id; j.loc_anc1 = loc_anc1;\n    }\n    else \n    {\n        j.b0_id = b1_id; j.loc_anc0 = loc_anc1;\n        j.b1_id = b0_id; j.loc_anc1 = loc_anc0;\n    }\n}\n\nvoid initJoint(Globals g, int b0_id, int b1_id, vec2 anchor, inout Joint j)\n{\n    Body b0; initBody(g, b0_id, b0);\n    Body b1; initBody(g, b1_id, b1);\n   \n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Mid(Globals g, int b0_id, int b1_id, vec2 offset, inout Joint j)\n{\n    Body b0; initBody(g, min(b0_id, b1_id), b0);\n    Body b1; initBody(g, max(b0_id, b1_id), b1);\n   \n    vec2 anchor = (b0.pos + b1.pos) * .5 + offset;\n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Mid(Globals g, int b0_id, int b1_id, inout Joint j)\n{\n    initJoint_Mid(g, b0_id, b1_id, vec2(0), j);\n}\n\nvoid initJoint_Second(Globals g, int b0_id, int b1_id, vec2 offset, inout Joint j)\n{\n    Body b0; initBody(g, b0_id, b0);\n    Body b1; initBody(g, b1_id, b1);\n   \n    vec2 anchor = b1.pos + offset;\n    vec2 loc_anc0 = transpose(rot(b0.ang)) * (anchor - b0.pos);\n    vec2 loc_anc1 = transpose(rot(b1.ang)) * (anchor - b1.pos);    \n    \n    initJoint(b0_id, b1_id, loc_anc0, loc_anc1, j);\n}\n\nvoid initJoint_Second(Globals g, int b0_id, int b1_id, inout Joint j)\n{\n    initJoint_Second(g, b0_id, b1_id, vec2(0), j);\n}\n\nvoid initJoint(Globals g, int j_id, inout Joint j)\n{\n    j = Joint(-1, -1, vec2(0), vec2(0), 0., 0., vec2(0), vec2(0), mat2(0), vec2(0), vec2(0));\n    if(j_id <= 7) // Spring 0 - 7\n    {\n        if      (j_id == 0) initJoint_Mid(g, 17, 18, vec2(0,.1), j);\n        else if (j_id == 1) initJoint_Mid(g, 17, 18, vec2(0,-.1), j);\n        else if (j_id == 2) initJoint_Mid(g, 18, 19, vec2(0,.1), j);\n        else if (j_id == 3) initJoint_Mid(g, 18, 19, vec2(0,-.1), j);\n        else if (j_id == 4) initJoint_Mid(g, 19, 20, vec2(0,.1), j);\n        else if (j_id == 5) initJoint_Mid(g, 19, 20, vec2(0,-.1), j);\n        else if (j_id == 6) initJoint_Mid(g, 20, 21, vec2(0,.1), j);\n        else                initJoint_Mid(g, 20, 21, vec2(0,-.1), j);\n        j.softness = 10.; \n        j.bias_factor = .5;\n    }\n    else if (j_id <= 9) // Flipper 8 - 9\n    {\n        if (j_id == 8) { initJoint_Second(g, 24, 22, vec2(-.4,.04), j); j.softness = .01; }\n        else           { initJoint_Second(g, 0, 22, vec2(0,-.2), j); j.softness = 3.; }\n        j.bias_factor = .5;\n    }\n    else if (j_id <= 16) // Pinch 10 - 16\n    {\n        if      (j_id == 10) initJoint_Second(g, 1, 25, j);\n        else if (j_id == 11) initJoint_Second(g, 26, 25, j);\n        else if (j_id == 12) initJoint_Second(g, 27, 25, j);\n        else if (j_id == 13) initJoint_Mid(g, 26, 27, vec2(0,.1), j);\n        else if (j_id == 14) initJoint_Mid(g, 26, 27, vec2(0,-.1), j);\n        else if (j_id == 15) initJoint_Second(g, 25, 28, vec2(.04,0), j);\n        else                 initJoint_Second(g, 25, 29, vec2(-.04,0), j);\n        j.bias_factor = .02;\n        j.softness = 0.; // will be overriden by JointAnimation\n    }\n    else if (j_id <= 20) // Bottom-right Spring 17 - 20\n    {\n        if      (j_id == 17) initJoint_Mid(g, 44, 45, vec2(-.1, 0), j);\n        else if (j_id == 18) initJoint_Mid(g, 44, 45, vec2(.1, 0), j);\n        else if (j_id == 19) initJoint_Mid(g, 45, 46, vec2(-.1, 0), j);\n        else                 initJoint_Mid(g, 45, 46, vec2(.1, 0), j);\n        j.bias_factor = .2;\n        j.softness = 10.; // will be overriden by JointAnimation\n    }\n    else if (j_id <= 21) // Top-right trapdoor 21\n    {\n        initJoint_Second(g, 52, 47, vec2(0,.1), j);\n        j.softness = 0.; j.bias_factor = .075;\n    }\n    else if (j_id <= 29) // Bottom Bassin 22 - 29\n    {\n        if      (j_id == 22) initJoint_Second(g, 0, 37, vec2(.15, -.35), j);\n        else if (j_id == 23) initJoint_Second(g, 0, 37, vec2(-.15, -.35), j);\n        else if (j_id == 24) initJoint_Second(g, 0, 38, vec2(.15, -.5), j);\n        else if (j_id == 25) initJoint_Second(g, 0, 38, vec2(-.15, -.5), j);\n        else if (j_id == 26) initJoint_Second(g, 0, 39, vec2(.15, -.5), j);\n        else if (j_id == 27) initJoint_Second(g, 0, 39, vec2(-.15, -.5), j);\n        else if (j_id == 28) initJoint_Mid(g, 37, 38, j);\n        else                 initJoint_Mid(g, 37, 39, j);\n        j.softness = 20.; j.bias_factor = .1;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(-1);\n \n    Globals g_prev = loadGlobals(iChannel0);\n\n    bool is_first_frame = (iFrame == 0);\n    if(is_first_frame) initGlobals(ivec2(iResolution), g_prev);\n\n    int res_x = int(iResolution.x);\n    bool is_buffer_smaller = (g_prev.res.x > res_x) || (g_prev.res.y > int(iResolution.y)); \n    bool is_init = is_first_frame || is_buffer_smaller;\n    bool is_body_added = !is_init \n     && (MOUSE_DOWN)\n     && (g_prev.mode == 2)\n     && (g_prev.n_body < bodyMax(ivec2(iResolution))) \n     && (g_prev.t_added + SPAWN_COOLDOWN < g_prev.time);\n\n    Globals g_next = g_prev;\n    if(is_init) initGlobals(ivec2(iResolution), g_next);\n    g_next.res = ivec2(iResolution);\n    if(is_body_added) \n    {\n        g_next.n_body += 1;\n        g_next.t_added = g_prev.time;\n    }\n\n    int id = address(res_x, ivec2(fragCoord));\n    int g_id = id / pixel_count_of_Globals;\n    int b_id = (id - bodyStartAddress()) / pixel_count_of_Body;\n    int j_id = (id - jointStartAddress(g_next)) / pixel_count_of_Joint;\n    int c_id = (id - contactStartAddress(g_next)) / pixel_count_of_Contact;\n    float dt = rcp(60.); // factory calibrated with 60 fps, using iTimeDelta is more correct \n\n    if(g_id == 0) // Globals\n    {\n        g_next.time += dt;\n        \n        // Factory example specific : update funnel counter and b_id \n        vec2 funnel_p = vec2(-1.5, .07);\n        Body funnel_b = loadBody(iChannel0, g_prev.funnel_b_id);\n        if(g_prev.funnel_b_id >= 0 && funnel_b.pos.y < funnel_p.y) g_next.n_funnel = g_prev.n_funnel + 1;\n        g_next.funnel_b_id = -1;\n        float funnel_d = FLT_MAX;\n        for(int i = 70; i < g_prev.n_body; i++) \n        {\n            Body b_i = loadBody(iChannel0, i);\n            if(b_i.pos.y < funnel_p.y) continue;\n            float b_d = dot2(b_i.pos - funnel_p);\n            if(b_d > .1) continue;\n            if(g_next.funnel_b_id < 0 || b_d < funnel_d)\n            {\n                g_next.funnel_b_id = i;\n                funnel_d = b_d;\n            }\n        }\n        \n        // Factory example specific : select mode\n        if(MOUSE_DOWN)\n        {\n            vec2 m = VIEW(iMouse);\n            if(length(m-vec2(-1.7, 1.3)) < .15) g_next.mode = 0; \n            if(length(m-vec2(-1.4, 1.3)) < .15) g_next.mode = 1; \n            if(length(m-vec2(-1.1, 1.3)) < .15) g_next.mode = 2; \n        }\n        \n        // Store\n        storeGlobals(res_x, g_next, ivec2(fragCoord), fragColor);\n    }\n    else if(b_id >= 0 && b_id < g_next.n_body) // Body\n    {\n        // Load\n        Body b = loadBody(iChannel0, g_prev.res, b_id);\n        if(is_init) initBody(g_next, b_id, b);\n        if(b_id >= g_prev.n_body) addBody(b);\n\n        // Limit velocities\n        if(length(b.vel) > MAX_VELOCITY) b.vel /= length(b.vel) * MAX_VELOCITY;\n        if(abs(b.ang_vel) > MAX_ANG_VELOCITY) b.ang_vel = clamp(b.ang_vel, -MAX_ANG_VELOCITY, MAX_ANG_VELOCITY);   \n\n        // Integrate velocities \n        b.pos += b.vel * dt;\n        b.ang += b.ang_vel * dt;\n\n        // Integrate forces\n        b.vel += getForce(g_next, b_id, b) * dt;\n        b.ang_vel += getTorque(g_next, b_id, b) * dt;\n\n        // Store\n        storeBody(res_x, b_id, b, ivec2(fragCoord), fragColor);\n    }\n    else if(j_id >= 0 && j_id < g_next.n_joint) // Joint\n    {\n        // Load\n        Joint j = loadJoint(iChannel0, g_prev, j_id);\n        if(is_init) initJoint(g_next, j_id, j);\n        jointAnimation(g_next, j_id, j);\n\n        // Load associated bodies\n        Body b0 = loadBody(iChannel0, g_prev.res, j.b0_id);\n        if(is_init) initBody(g_next, j.b0_id, b0);\n        if(j.b0_id >= g_prev.n_body) addBody(b0);\n\n        Body b1 = loadBody(iChannel0, g_prev.res, j.b1_id);\n        if(is_init) initBody(g_next, j.b1_id, b1);\n        if(j.b1_id >= g_prev.n_body) addBody(b1);\n\n        // Pre Step\n        preStepJoint(b0, b1, dt, j);\n\n        // Store\n        storeJoint(res_x, g_next, j_id, j, ivec2(fragCoord), fragColor);\n    }\n    else if(c_id >= 0 && c_id < nContact(g_next)) // Contact\n    {\n        // Load\n        Contact c = loadContact(iChannel0, g_prev, c_id);\n\n        // Load associated bodies\n        int b0_id = -1, b1_id = -1;\n        getContactBodyIds(c_id, b0_id, b1_id);\n\n        Body b0 = loadBody(iChannel0, g_prev.res, b0_id);\n        if(is_init) initBody(g_next, b0_id, b0);\n        if(b0_id >= g_prev.n_body) addBody(b0);\n\n        Body b1 = loadBody(iChannel0, g_prev.res, b1_id);\n        if(is_init) initBody(g_next, b1_id, b1);\n        if(b1_id >= g_prev.n_body) addBody(b1);\n\n        // Collide\n        collide(c_id, b0_id, b0, b1_id, b1, c);\n\n        // Pre Step\n        preStepContact(dt, b0, b1, c);\n\n        // Store\n        storeContact(res_x, g_next, c_id, c, ivec2(fragCoord), fragColor);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Physics Iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    physicsIteration(fragColor, fragCoord, iResolution.xy, iChannel0);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcdcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Spinor Bel abossard 509",
    "description": "Feynman belt trick to demonstrate that 3D rotations have a Z2 fundamental group, implying the existence of spinors. The magick is the cube can be rotated 720 without any of the attaching strings intersecting or tangling.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "math",
     "rotation",
     "physics",
     "quaternions",
     "belttrick",
     "spinors"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float gamma = 2.2;\nconst vec3 gamma_vec = gamma * vec3(1.,1.,1.);\nconst vec3 col_x = pow(vec3(209., 48., 107.)/255., gamma_vec);\nconst vec3 col_y = pow(vec3(52., 235., 186.)/255., gamma_vec);\nconst vec3 col_z = pow(vec3(125., 57., 219.)/255., gamma_vec);\nconst vec3 col_sky = pow(vec3(0.2,0.2,0.2),gamma_vec);\nconst vec3 col_core = pow(vec3(0.8,.8,.8), gamma_vec);\n\nvec2 rot2d(vec2 v, float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec2(\n        c*v.x - s*v.y, s*v.x + c*v.y\n    );\n}\n\nvec3 rot(vec3 v, float azimuth, float altitude){\n    vec3 u = v;\n    u.yz = rot2d(u.yz, altitude);\n    u.xz = rot2d(u.xz,azimuth);\n    return u;\n}\n\n\n// https://iquilezles.org/articles/smin/\nvec2 smin( float a, float b, float k )\n{\n    float h = 1.0 - min( abs(a-b)/(4.0*k), 1.0 );\n    float w = h*h;\n    float m = w*0.5;\n    float s = w*k;\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n\nfloat sdf_box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//multiply two vector quats\nvec4 imuli(vec3 v, vec3 w){\n    return vec4(cross(v,w),-dot(v,w));\n}\n\n//quat times vector quat\nvec4 qmuli(vec4 q, vec3 v){\n    return q.w * vec4(v,0.) + imuli(q.xyz, v);\n}\n\n\n//quat times quat\nvec4 qmulq(vec4 q, vec4 p){\n    return q * p.w + qmuli(q,p.xyz);\n}\n\nvec4 qconj(vec4 q){\n    return vec4(-q.xyz,q.w);\n}\n\nvec3 adjoint(vec4 q, vec3 x){\n    return qmulq(qmuli(q, x), qconj(q) ).xyz;\n}\n\n\nstruct Surface{\n    float sdf;\n    vec3 color;\n};\n\nSurface sunion(Surface a, Surface b){\n    if (a.sdf < b.sdf){\n        return a;\n    }\n    return b;\n}\n\nSurface smooth_union(Surface a, Surface b, float k){\n    vec2 smoothing = smin(a.sdf,b.sdf,k);\n    \n    return Surface(\n        smoothing.x,\n        mix(a.color, b.color, smoothing.y)\n    );\n}\n\n\nSurface sdf_axes(vec3 p){\n\n    \n    const float size = 0.5;\n    const vec3 b = vec3(40.,size, size);\n    const float r = 0.1;\n    return sunion(\n        Surface(sdf_box(p, b.xyz, r), col_x),\n        sunion(\n            Surface(sdf_box(p, b.yzx, r), col_y),\n            Surface(sdf_box(p, b.zxy, r), col_z)\n            )\n        );\n}\n\nconst float marker_distance = sqrt(2./0.03);\n\n//unused \nSurface markers(vec3 p){\n    vec3 q = abs(p);\n    \n    const vec3 marker_center = normalize(vec3(1.,1.,1.)) * marker_distance;\n    \n    return Surface(\n        length(q-marker_center) - 0.5,\n        \n        col_core\n    );\n}\n\nfloat rotation_angle_at_r2(float r2){\n    return 6.28318530718 * smoothstep(0.,1.,1. /(1.+0.01*r2));\n}\n\nvec4 quaternion_at_r2(float r2, float lambda){\n    float rangle =  rotation_angle_at_r2(r2);\n    float c = cos(rangle*0.5);\n    float s = sin(rangle*0.5);\n    \n    float cl = cos(lambda);\n    float sl = sin(lambda);\n\n    vec4 base_q = vec4(cl*s,sl,0.,cl*c);\n    vec4 q = base_q;\n    q.wy = rot2d(q.wy, -lambda);\n    return q;\n}\n\n\nSurface scene(vec3 pos){\n\n    float st = 2.*smoothstep(0.,1.,fract(0.65+0.1*iTime))-1.;\n    float lambda = 1.57079632679 * (st*st*st);\n    \n    \n    vec4 q = quaternion_at_r2(dot(pos,pos), lambda);\n    \n    vec3 x = adjoint(q,pos);\n    \n    \n    Surface box = Surface(sdf_box(x, vec3(1.,1.,1.), 0.2), col_core);\n    Surface axes = sdf_axes(x);\n    \n    Surface surf = smooth_union(box,axes,0.02);\n    \n    Surface sky = Surface( - (length(pos)-26.0), col_sky);\n    \n    surf = smooth_union(surf, sky,3.0);\n    \n    return surf;\n    \n}\n\nconst vec3 light = normalize(vec3(1.,-2.,0.3));\n\nvec3 march(vec3 cam, vec3 ray){\n    float t = 2.0;\n    int it=0;\n    float min_dist = 5000.0;\n    \n    for (it=0; it<1000; it++){\n        if (t > 100.){\n            break;\n        }\n        vec3 pos = cam + ray*t;\n        Surface surf = scene(pos);\n        float dist = surf.sdf;\n        \n        min_dist = min(dist, min_dist);\n        \n        if (dist < 0.01){\n            const float delta = 0.002;\n            float ndotl = (scene(pos-delta*light).sdf-dist)/delta;\n            float ao = pow(clamp(50./float(it),0.,1.),0.5);\n            vec3 shading = 0.7*vec3(1.1,1.1,1.)*smoothstep(-0.3,1.0,ndotl)+ ao*vec3(0.4,0.4,0.7);\n            \n            return surf.color * shading;\n        }\n        //unfortunately the sdf is highly imperfect,\n        //so we need to march very carefully and with a lot of iterations.\n        t += 0.2*dist;\n    }\n    \n    return vec3(1.,0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 viewport = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = vec3(0.,0.,-25.);\n    vec3 ray = normalize(vec3(viewport, 1.5));\n    \n    float azimuth = 0.7 + iTime * 0.0425;\n    float altitude = 0.4;\n    \n    cam = rot(cam, azimuth, altitude);\n    ray = rot(ray, azimuth, altitude);\n    \n    \n    vec3 col = march(cam,ray);\n    fragColor = vec4(pow(col,1./gamma * vec3(1.,1.,1.)),1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcdcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Multiscale abossard 511",
    "description": "A mipmap-based approach to multiscale fluid dynamics.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "simulation",
     "water",
     "fluid",
     "mipmap",
     "turbulence",
     "mip",
     "diffusion",
     "advection",
     "navier",
     "stokes",
     "eddy"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* \n\tCreated by Cornus Ammonis (2019)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n\tThis is a mipmap-based approach to multiscale fluid dynamics.\n\n\tCheck the Common tab for lots of configurable parameters.\n\n\tClick to interact with your mouse. I'd recommend turning off the \"pump\" by\n\tsetting PUMP_SCALE to 0.0 on line 113 of the Common tab to play around with\n\tjust mouse interaction.\n\n\tBuffer B is a multiscale method for computing turbulence along the lines of \n\tthe Large Eddy Simulation method; multiscale curl is also computed in Buffer B, \n    to be passed along to Buffer C.\n\t\n\tBuffer C is a fairly conventional Vorticity Confinement method, also multiscale, \n    using the curl computed in Buffer B. It probably makes more sense to compute \n    each curl scale separately before accumulating, but for the sake of efficiency \n    and simplicity (a larger kernel would be required), I haven't done that here.\n\n\tBuffer D is a multiscale Poisson solver, which converges rapidly but not to an \n    exact solution - this nonetheless works well for the purposes of divergence \n    minimization since we only need the gradient, with allowances for the choice of\n    scale weighting. \n\n\tBuffer A computes subsampled advection and velocity update steps, sampling\n    from Buffers B, C, and D with a variety of smoothing options.\n\n\tThere are a number of options included to make this run faster.\n\n\tUsing mipmaps in this way has a variety of advantages:\n\n\t1. The scale computations have no duplicative or dependent reads, we only need \n       that for advection.\n\t2. No randomness or stochastic sampling is involved.\n\t3. The total number of reads can be greatly reduced for a comparable level of \n       fidelity to some other methods.\n\t4. We can easily sample the entire buffer in one pass (on average).\n\t5. The computational complexity is deferred to mipmap generation (though with\n       a large coefficient), because: \n\t6. The algorithm itself is O(n) with a fixed number of scales (or we could \n       potentially do scale calculations in parallel with mipmap generation, \n       equalling mipmap generation complexity at O(nlogn))\n\n\tNotable downsides:\n\n\t1. Using mipmaps introduces a number of issues, namely:\n       a. Mipmaps can introduce artifacts due to interpolation and downsampling. \n          Using Gaussian pyramids, or some other lowpass filtering method would \n          be better. \n       b. Using higher-order sampling of the texture buffer (e.g. bicubic) would \n          also be better, but that would limit our performance gains. \n       c. NPOT textures are problematic (as always). They can introduce weird \n          anisotropy issues among other things.\n\t2. Stochastic or large-kernel methods are a better approximation to the true\n       sampling distribution approximated here, for a large-enough number of\n       samples.\n    3. We're limited in how we construct our scale-space. Is a power-of-two stride \n       length on both axes always ideal, even along diagonals? I'm not particularly \n       sure. There are clever wavelet methods out there for Navier-Stokes solvers, \n       and LES in particular, too.\n\n*/\n\n\n#define BUMP 3200.0\n\n#define D(d) -textureLod(iChannel1, fract(uv+(d+0.0)), mip).w\n\nvec2 diff(vec2 uv, float mip) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = float(1<<int(mip))*vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\nvec4 contrast(vec4 col, float x) {\n\treturn x * (col - 0.5) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 dxy = vec2(0);\n    float occ, mip = 0.0;\n    float d   = D();\n    \n    // blur the gradient to reduce appearance of artifacts,\n    // and do cheap occlusion with mipmaps\n    #define STEPS 10.0\n    #define ODIST 2.0\n    for(mip = 1.0; mip <= STEPS; mip += 1.0) {\t \n        dxy += (1.0/pow(2.0,mip)) * diff(uv, mip-1.0);\t\n    \tocc += softclamp(-ODIST, ODIST, d - D(),1.0)/(pow(1.5,mip));\n    }\n    dxy /= float(STEPS);\n    \n    // I think this looks nicer than using smoothstep\n    occ = pow(max(0.0,softclamp(0.2,0.8,100.0*occ + 0.5,1.0)),0.5);\n \n    vec3 avd;\n    vec3 ld = light(uv, BUMP, 0.5, dxy, iTime, avd);\n    \n    float spec = ggx(avd, vec3(0,1,0), ld, 0.1, 0.1);\n    \n    #define LOG_SPEC 1000.0\n    spec = (log(LOG_SPEC+1.0)/LOG_SPEC)*log(1.0+LOG_SPEC*spec);    \n    \n    #define VIEW_VELOCITY\n    \n    #ifdef VIEW_VELOCITY\n\t\tvec4 diffuse = softclamp(0.0,1.0,6.0*vec4(texture(iChannel0,uv).xy,0,0)+0.5,2.0);    \n    #elif defined(VIEW_CURL)\n\t\tvec4 diffuse = mix(vec4(1,0,0,0),vec4(0,0,1,0),softclamp(0.0,1.0,0.5+2.0*texture(iChannel2,uv).w,2.0));    \n    #elif defined(VIEW_ADVECTION)\n\t\tvec4 diffuse = softclamp(0.0,1.0,0.0004*vec4(texture(iChannel0,uv).zw,0,0)+0.5,2.0); \n    #elif defined(VIEW_GRADIENT)\n    \tvec4 diffuse = softclamp(0.0,1.0,10.0*vec4(diff(uv,0.0),0,0)+0.5,4.0); \n    #else // Vorticity confinement vectors\n    \tvec4 diffuse = softclamp(0.0,1.0,4.0*vec4(texture(iChannel3,uv).xy,0,0)+0.5,4.0);\n    #endif\n    \n    \n    fragColor = (diffuse + 4.0*mix(vec4(spec),1.5*diffuse*spec,0.3));\n    fragColor = mix(1.0,occ,0.7) * (softclamp(0.0,1.0,contrast(fragColor,4.5),3.0));\n    \n    //fragColor = vec4(occ);\n    //fragColor = vec4(spec);\n    //fragColor = diffuse;\n    //fragColor = vec4(diffuse+(occ-0.5));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define TURBULENCE_SAMPLER iChannel3\n#define CONFINEMENT_SAMPLER iChannel2\n#define POISSON_SAMPLER iChannel1\n#define VELOCITY_SAMPLER iChannel0\n\n#define V(d) texture(TURBULENCE_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_turbulence(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    V( t.ww); vec2 d_n =  V( t.wy); vec2 d_e =  V( t.xw);\n    vec2 d_s =  V( t.wz); vec2 d_w =  V(-t.xw); vec2 d_nw = V(-t.xz);\n    vec2 d_sw = V(-t.xy); vec2 d_ne = V( t.xy); vec2 d_se = V( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define C(d) texture(CONFINEMENT_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_confinement(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    C( t.ww); vec2 d_n =  C( t.wy); vec2 d_e =  C( t.xw);\n    vec2 d_s =  C( t.wz); vec2 d_w =  C(-t.xw); vec2 d_nw = C(-t.xz);\n    vec2 d_sw = C(-t.xy); vec2 d_ne = C( t.xy); vec2 d_se = C( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define D(d) texture(POISSON_SAMPLER, fract(uv+d)).x\n\nvec2 diff(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\n#define N(d) texture(VELOCITY_SAMPLER, fract(uv+(d+0.)))\n\nvec4 gaussian_velocity(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\nvec2 vector_laplacian(vec2 uv) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return (_K0 * d + _K1 * (d_e + d_w + d_n + d_s) + _K2 * (d_ne + d_nw + d_se + d_sw)).xy;\n}\n\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 tx = 1.0/iResolution.xy;\n\n    \n    vec2 turb, confine, div, delta_v, offset, lapl = vec2(0);\n    vec4 vel, adv = vec4(0);\n    vec4 init = N();\n\n    #ifdef RECALCULATE_OFFSET\n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            #ifdef BLUR_TURBULENCE\n            turb = gaussian_turbulence(uv + tx * offset);\n            #else\n            turb = V(tx * offset);\n            #endif\n\n            #ifdef BLUR_CONFINEMENT\n            confine = gaussian_confinement(uv + tx * offset);\n            #else\n            confine = C(tx * offset);\n            #endif\n\n            #ifdef BLUR_VELOCITY\n            vel = gaussian_velocity(uv + tx * offset);\n            #else\n            vel = N(tx * offset);\n            #endif\n\n            // an alternative, but seems to give less smooth results:\n            // offset += (1.0 / float(ADVECTION_STEPS)) * ...\n            offset = (float(i+1) / float(ADVECTION_STEPS)) * - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n\n            div = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n\n            lapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n\n            adv += N(tx * offset);\n\n            delta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n        }\n        adv /= float(ADVECTION_STEPS);\n        delta_v /= float(ADVECTION_STEPS);\n    #else\n        #ifdef BLUR_TURBULENCE\n        turb = gaussian_turbulence(uv);\n        #else\n        turb = V();\n        #endif\n\n        #ifdef BLUR_CONFINEMENT\n        confine = gaussian_confinement(uv);\n        #else\n        confine = C();\n        #endif\n\n        #ifdef BLUR_VELOCITY\n        vel = gaussian_velocity(uv);\n        #else\n        vel = N();\n        #endif\n    \n    \toffset = - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n        \n    \tdiv = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n        \n    \tlapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n    \t\n    \tdelta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n    \n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            adv += N((float(i+1) / float(ADVECTION_STEPS)) * tx * offset);   \n        }   \n        adv /= float(ADVECTION_STEPS);\n    #endif\n    \n\n    \n    // define a pump, either at the center of the screen,\n    // or alternating at the sides of the screen.\n    vec2 pq = 2.0*(uv*2.0-1.0) * vec2(1,tx.x/tx.y);\n    #ifdef CENTER_PUMP\n    \tvec2 pump = sin(PUMP_CYCLE*iTime)*PUMP_SCALE*pq.xy / (dot(pq,pq)+0.01);\n    #else\n    \tvec2 pump = vec2(0);\n    \t#define AMP 15.0\n    \t#define SCL -50.0\n        float uvy0 = exp(SCL*pow(pq.y,2.0));\n        float uvx0 = exp(SCL*pow(uv.x,2.0));\n        pump += -AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx0*uvy0,0);\n    \n    \tfloat uvy1 = exp(SCL*pow(pq.y,2.0));\n        float uvx1 = exp(SCL*pow(1.0 - uv.x,2.0));\n        pump += AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx1*uvy1,0);\n\n        float uvy2 = exp(SCL*pow(pq.x,2.0));\n        float uvx2 = exp(SCL*pow(uv.y,2.0));\n        pump += -AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx2*uvy2);\n    \n    \tfloat uvy3 = exp(SCL*pow(pq.x,2.0));\n        float uvx3 = exp(SCL*pow(1.0 - uv.y,2.0));\n        pump += AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx3*uvy3);\n    #endif\n    \n    fragColor = mix(adv + vec4(VELOCITY_SCALE * (delta_v + pump), offset), init, UPDATE_SMOOTHING);\n    \n    if (iMouse.z > 0.0) {\n        vec4 mouseUV = iMouse / iResolution.xyxy;\n        vec2 delta = normz(mouseUV.zw - mouseUV.xy);\n        vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n        float amp = exp(max(-12.0,-dot(md,md)/MOUSE_RADIUS));\n        fragColor.xy += VELOCITY_SCALE * MOUSE_AMP * clamp(amp * delta,-1.0,1.0);\n    }\n    \n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define TURB_CH xy\n#define TURB_SAMPLER iChannel0\n#define DEGREE TURBULENCE_SCALES\n\n#define D(d) textureLod(TURB_SAMPLER, fract(uv+d), mip).TURB_CH\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvoid turbulence(vec2 fragCoord, inout vec2 turb, inout float curl)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    mat3 turb_xx = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125,  0.25, 0.125,\n       -0.25,  -0.5, -0.25,\n        0.125,  0.25, 0.125\n    );\n\n    mat3 turb_yy = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125, -0.25, 0.125,\n        0.25,  -0.5,  0.25,\n        0.125, -0.25, 0.125\n    );\n\n    mat3 turb_xy = TURB_ISOTROPY * mat3(\n       0.25, 0.0, -0.25,  \n       0.0,  0.0,  0.0,\n      -0.25, 0.0,  0.25\n    );\n    \n    const float norm = 8.8 / (4.0 + 8.0 * CURL_ISOTROPY);  // 8.8 takes the isotropy as 0.6\n    float c0 = CURL_ISOTROPY;\n    \n    mat3 curl_x = mat3(\n        c0,   1.0,  c0,\n        0.0,  0.0,  0.0,\n       -c0,  -1.0, -c0\n    );\n\n    mat3 curl_y = mat3(\n        c0, 0.0, -c0,\n       1.0, 0.0, -1.0,\n        c0, 0.0, -c0\n    );\n    \n    mat3 mx, my;\n    vec2 v = vec2(0);\n    float turb_wc, curl_wc = 0.0;\n    curl = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, i);\n        float turb_w = TURB_W_FUNCTION;\n        float curl_w = CURL_W_FUNCTION;\n    \tv += turb_w * vec2(reduce(turb_xx, mx) + reduce(turb_xy, my), reduce(turb_yy, my) + reduce(turb_xy, mx));\n        curl += curl_w * (reduce(curl_x, mx) + reduce(curl_y, my));\n        turb_wc += turb_w;\n        curl_wc += curl_w;\n    }\n\n    turb = float(DEGREE) * v / turb_wc;\n    curl = norm * curl / curl_wc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 turb;\n    float curl;\n    turbulence(fragCoord, turb, curl);\n    fragColor = vec4(turb,0,curl);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "#define CURL_CH w\n#define CURL_SAMPLER iChannel0\n#define DEGREE VORTICITY_SCALES\n\n#define CURL(d) textureLod(CURL_SAMPLER, fract(uv+(d+0.0)), mip).CURL_CH\n#define D(d) abs(textureLod(CURL_SAMPLER, fract(uv+d), mip).CURL_CH)\n\nvoid tex(vec2 uv, inout mat3 mc, inout float curl, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    mc =  mat3(d_nw, d_n, d_ne,\n               d_w,  d,   d_e,\n               d_sw, d_s, d_se);\n    \n    curl = CURL();\n    \n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 confinement(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = CONF_ISOTROPY;\n    float k1 = 1.0 - 2.0*(CONF_ISOTROPY);\n\n    mat3 conf_x = mat3(\n       -k0, -k1, -k0,\n        0.0, 0.0, 0.0,\n        k0,  k1,  k0\n    );\n\n    mat3 conf_y = mat3(\n       -k0,  0.0,  k0,\n       -k1,  0.0,  k1,\n       -k0,  0.0,  k0\n    );\n    \n    mat3 mc;\n    vec2 v = vec2(0);\n    float curl;\n    \n    float cacc = 0.0;\n    vec2 nacc = vec2(0);\n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mc, curl, i);\n        float w = CONF_W_FUNCTION;\n        vec2 n = w * normz(vec2(reduce(conf_x, mc), reduce(conf_y, mc)));\n        v += curl * n;\n        cacc += curl;\n        nacc += n;\n        wc += w;\n    }\n\n    #ifdef PREMULTIPLY_CURL\n        return v / wc;\n    #else\n    \treturn nacc * cacc / wc;\n    #endif\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(confinement(fragCoord),0,0);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "#define VORT_CH xy\n#define VORT_SAMPLER iChannel0\n#define POIS_SAMPLER iChannel1\n#define POIS_CH x\n#define DEGREE POISSON_SCALES\n\n#define D(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).VORT_CH\n#define P(d) textureLod(POIS_SAMPLER, fract(uv+d), mip).POIS_CH\n\nfloat laplacian_poisson(vec2 fragCoord) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    vec4 t = vec4(texel, -texel.y, 0);\n    float mip = 0.0;\n\n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    return _K0 * p + _K1 * (p_e + p_w + p_n + p_s) + _K2 * (p_ne + p_nw + p_se + p_sw);\n}\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, inout mat3 mp, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n    \n    mp =  mat3(p_nw, p_n, p_ne,\n               p_w,  p,   p_e,\n               p_sw, p_s, p_se);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 pois(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = POIS_ISOTROPY;\n    float k1 = 1.0 - 2.0*(POIS_ISOTROPY);\n    \n    mat3 pois_x = mat3(\n        k0,  0.0, -k0,\n        k1,  0.0, -k1,\n        k0,  0.0, -k0\n    );\n     \n    mat3 pois_y = mat3(\n       -k0,  -k1,  -k0,\n        0.0,  0.0,  0.0,\n        k0,   k1,   k0\n    );\n\n    mat3 gauss = mat3(\n       0.0625, 0.125, 0.0625,  \n       0.125,  0.25,  0.125,\n       0.0625, 0.125, 0.0625\n    );\n    \n    mat3 mx, my, mp;\n    vec2 v = vec2(0);\n    \n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, mp, i);\n        float w = POIS_W_FUNCTION;\n        wc += w;\n    \tv += w * vec2(reduce(pois_x, mx) + reduce(pois_y, my), reduce(gauss, mp));\n    }\n\n    return v / wc;\n\n}\n\n#define V(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = pois(fragCoord);\n    #ifdef USE_PRESSURE_ADVECTION\n        float mip = 0.0;\n        vec2 tx = 1.0 / iResolution.xy;\n        vec2 uv = fragCoord * tx;\n        float prev = P(0.0002 * PRESSURE_ADVECTION * tx * V(vec2(0)));\n        fragColor = vec4(mix(p.x + p.y, prev + PRESSURE_LAPLACIAN * laplacian_poisson(fragCoord), PRESSURE_UPDATE_SMOOTHING));\n    #else\n    \tfragColor = vec4(p.x + p.y);\n    #endif\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*\n\tNumber of scales to use in computation of each value. Lowering these will change the \n    result drastically, also note that the heightmap is used for rendering, so changing \n    POISSON_SCALES will alter the appearance of lighting/shadows. Weighting functions\n    for each scale are defined below.\n*/\n#define TURBULENCE_SCALES 11\n#define VORTICITY_SCALES 11\n#define POISSON_SCALES 11\n\n\n\n// If defined, recalculate the advection offset at every substep. Otherwise, subdivide the offset.\n// Leaving this undefined is much cheaper for large ADVECTION_STEPS but yields worse results; this\n// can be improved by defining the BLUR_* options below.\n#define RECALCULATE_OFFSET\n// Number of advection substeps to use. Useful to increase this for large ADVECTION_SCALE. Must be >= 1\n#define ADVECTION_STEPS 3\n// Advection distance multiplier.\n#define ADVECTION_SCALE 40.0\n// Scales the effect of turbulence on advection.\n#define ADVECTION_TURBULENCE 1.0\n// Scales the effect of turbulence on velocity. Use small values.\n#define VELOCITY_TURBULENCE 0.0000\n// Scales the effect of vorticity confinement on velocity.\n#define VELOCITY_CONFINEMENT 0.01\n// Scales diffusion.\n#define VELOCITY_LAPLACIAN 0.02\n// Scales the effect of vorticity confinement on advection.\n#define ADVECTION_CONFINEMENT 0.6\n// Scales the effect of divergence on advection.\n#define ADVECTION_DIVERGENCE  0.0\n// Scales the effect of velocity on advection.\n#define ADVECTION_VELOCITY -0.05\n// Amount of divergence minimization. Too much will cause instability.\n#define DIVERGENCE_MINIMIZATION 0.1\n// If 0.0, compute the gradient at (0,0). If 1.0, compute the gradient at the advection distance.\n#define DIVERGENCE_LOOKAHEAD 1.0\n// If 0.0, compute the laplacian at (0,0). If 1.0, compute the laplacian at the advection distance.\n#define LAPLACIAN_LOOKAHEAD 1.0\n// Scales damping force.\n#define DAMPING 0.0001\n// Overall velocity multiplier\n#define VELOCITY_SCALE 1.0\n// Mixes the previous velocity with the new velocity (range 0..1).\n#define UPDATE_SMOOTHING 0.0\n\n\n\n// These control the (an)isotropy of the various kernels\n#define TURB_ISOTROPY 0.9  // [0..2.0]\n#define CURL_ISOTROPY 0.6  // >= 0\n#define CONF_ISOTROPY 0.25 // [0..0.5]\n#define POIS_ISOTROPY 0.16 // [0..0.5]\n\n\n\n// If defined, multiply curl by vorticity, then accumulate. If undefined, accumulate, then multiply.\n#define PREMULTIPLY_CURL\n\n\n\n// These apply a gaussian blur to the various values used in the velocity/advection update. More expensive when defined.\n//#define BLUR_TURBULENCE\n//#define BLUR_CONFINEMENT\n//#define BLUR_VELOCITY\n\n\n\n// These define weighting functions applied at each of the scales, i=0 being the finest detail.\n//#define TURB_W_FUNCTION 1.0/float(i+1)\n#define TURB_W_FUNCTION 1.0\n//#define TURB_W_FUNCTION float(i+1)\n\n//#define CURL_W_FUNCTION 1.0/float(1 << i)\n#define CURL_W_FUNCTION 1.0/float(i+1)\n//#define CURL_W_FUNCTION 1.0\n\n//#define CONF_W_FUNCTION 1.0/float(i+1)\n#define CONF_W_FUNCTION 1.0\n//#define CONF_W_FUNCTION float(i+1)\n//#define CONF_W_FUNCTION float(1 << i)\n\n//#define POIS_W_FUNCTION 1.0\n#define POIS_W_FUNCTION 1.0/float(i+1)\n//#define POIS_W_FUNCTION 1.0/float(1 << i)\n//#define POIS_W_FUNCTION float(i+1)\n//#define POIS_W_FUNCTION float(1 << i)\n\n\n\n// These can help reduce mipmap artifacting, especially when POIS_W_FUNCTION emphasizes large scales.\n//#define USE_PRESSURE_ADVECTION\n// Scales pressure advection distance.\n#define PRESSURE_ADVECTION 0.0002 // higher values more likely to cause blowup if laplacian > 0.0\n// Pressure diffusion.\n#define PRESSURE_LAPLACIAN 0.1 // [0..0.3] higher values more likely to cause blowup\n// Mixes the previous pressure with the new pressure.\n#define PRESSURE_UPDATE_SMOOTHING 0.0 // [0..1]\n\n\n\n// Scales mouse interaction effect\n#define MOUSE_AMP 0.05\n// Scales mouse interaction radius\n#define MOUSE_RADIUS 0.001\n\n\n\n// If defined, \"pump\" velocity in the center of the screen. If undefined, alternate pumping from the sides of the screen.\n//#define CENTER_PUMP\n// Amplitude and cycle time for the \"pump\" at the center of the screen.\n#define PUMP_SCALE 0.001\n#define PUMP_CYCLE 0.2\n\n\nvec4 normz(vec4 x) {\n\treturn x.xyz == vec3(0) ? vec4(0,0,0,x.w) : vec4(normalize(x.xyz),0);\n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n\n// Only used for rendering, but useful helpers\nfloat softmax(float a, float b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nfloat softmin(float a, float b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nvec4 softmax(vec4 a, vec4 b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nvec4 softmin(vec4 a, vec4 b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nfloat softclamp(float a, float b, float x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(vec4 a, vec4 b, vec4 x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(float a, float b, vec4 x, float k) {\n\treturn (softmin(vec4(b),softmax(vec4(a),x,k),k) + softmax(vec4(a),softmin(vec4(b),x,k),k)) / 2.0;    \n}\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n// End Noby's GGX\n\n\n// Modified from Shane's Bumped Sinusoidal Warp shadertoy here:\n// https://www.shadertoy.com/view/4l2XWK\nvec3 light(vec2 uv, float BUMP, float SRC_DIST, vec2 dxy, float iTime, inout vec3 avd) {\n    vec3 sp = vec3(uv-0.5, 0);\n    vec3 light = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -SRC_DIST);\n    vec3 ld = light - sp;\n    float lDist = max(length(ld), 0.001);\n    ld /= lDist;\n    avd = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));\n    return ld;\n}\n// End Shane's bumpmapping section\n\n\n// The MIT License\n// Copyright  2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));   \n}\n// End IQ's integer hash",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfdcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork A Funny At abossard 514",
    "description": "Refer to the video : https://www.youtube.com/watch?v=LavXSS5Xtbg",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "simulation",
     "physical"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float sdfCircle(vec2 pos,vec2 uv, float size){\n    return length(pos - uv) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float r1 = 0.06;\n    float r2 = 0.1;\n    float r3 = 0.04;\n    float r4 = 0.03;\n    \n    vec2 pos1 = vec2(1.2,0.6);\n    vec2 pos2 = vec2(0.3,0.6);\n    vec2 pos3 = vec2(0.8,0.3);\n    vec2 pos4 = vec2(0.9,0.5);\n    \n    pos1 += vec2(sin(iTime)*0.1,cos(iTime)*0.1);\n    pos2 += vec2(sin(iTime)*-0.3,cos(iTime)*0.3);\n    pos3 += vec2(sin(iTime)*0.2,cos(iTime)*0.1);\n    pos3 += 0.0;\n    \n    \n    if(sdfCircle(pos1,uv,r1)>0.0 && sdfCircle(pos2,uv,r2)>0.0 && sdfCircle(pos3,uv,r3)>0.0&& sdfCircle(pos4,uv,r4)>0.0)\n    {\n        \n        \n        vec2 p = uv;\n        vec2 v = vec2(0);\n        float dt = 0.01;\n        for(int i=0;i<10000;i++){\n            vec2 dir1 = normalize(pos1-p) ;\n            vec2 dir2 = normalize(pos2-p);\n            vec2 dir3 = normalize(pos3-p);\n            vec2 dir4 = normalize(pos4-p);\n            \n            float dist1 =max(length(p-pos1),0.001) ;\n            float dist2 = max(length(p-pos2),0.001);\n            float dist3 = max(length(p-pos3),0.001);\n            float dist4 = max(length(p-pos4),0.001);\n            \n            float force1 = r1/(dist1*dist1);\n            float force2 = r2/(dist2*dist2);\n            float force3 = r3/(dist3*dist3);\n            float force4 = r4/(dist4*dist4);\n            \n            \n            vec2 acc = dir1 * force1 + dir2 * force2 + dir3 * force3+ dir4 * force4;\n            v += acc * dt;\n            p += v * dt;\n        \n            if(sdfCircle(pos1,p,r1)<0.0){\n                col = vec3(pos1,1);\n                break;\n            }\n        \n            if(sdfCircle(pos2,p,r2)<0.0){\n                col = vec3(1,pos2);\n                break;\n            }\n        \n            if(sdfCircle(pos3,p,r3)<0.0){\n                col = vec3(pos3,1);\n                break;\n            }\n            if(sdfCircle(pos4,p,r4)<0.0){\n                col = vec3(1,pos4);\n                break;\n            }\n            \n        }\n    }\n    \n    \n\n    \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfdcD7",
    "date": "0",
    "viewed": 0,
    "name": "Fork Rectangula abossard 517",
    "description": "The same domain coloring algorithm as https://www.shadertoy.com/view/tlcGzf, except rectangular.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "math",
     "complex",
     "domaincoloring"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n * Rectangular domain coloring\n * Copyright 2019 Ricky Reusser. MIT License.\n *\n * See Common tab for cubehelix license: \n * https://github.com/d3/d3-color\n * Copyright 2010-2016 Mike Bostock *\n * Features:\n *\n * Based on https://www.shadertoy.com/view/tlcGzf except with rectangular\n * domain coloring instead of polar.\n *\n */\n\n// Available functions: cadd, csub, cmul, cdiv, cinv, csqr, cconj,\n// csqrt, cexp, cpow, clog, csin, ccos, ctan, ccot, ccsc, csec, casin,\n// cacos, catan, csinh, ccosh, ctanh, ccoth, ccsch, csech, casinh,\n// cacosh, catanh\nvec2 f (vec2 z, float t, vec2 mouse) {\n    vec2 a = vec2(sin(t), 0.5 * sin(2.0 * t));\n    vec2 b = vec2(cos(t), 0.5 * sin(2.0 * (t - HALF_PI)));\n    vec2 m = mouse;\n\n    // Try a different equation:\n    // return csin((cmul(z - a, z - b, z - m)));\n\n    return cdiv(cmul(z - a, m - b), cmul(z - b, m - a));\n\n    z *= 0.6;\n    z.x -= 0.5;\n    vec2 sum = z;\n    for (int i = 0; i < 10; i++) {\n        sum = csqr(sum) + z;\n    }\n    return sum;\n}\nconst bool animate = true;\nconst bool grid = true; // (when not animating)\n\nconst int octaves = 4;\n\n// Grid lines:\nconst float lineWidth = 1.0;\nconst float lineFeather = 1.0;\nconst vec3 gridColor = vec3(0);\n\n// Power of contrast ramp function\n\nvec2 pixelToXY (vec2 point) {\n  \tvec2 aspect = vec2(1, iResolution.y / iResolution.x);\n    return (point / iResolution.xy - 0.5) * aspect * 5.0;\n}\n\n// Select an animation state\nfloat selector (float time) {\n    const float period = 10.0;\n    float t = fract(time / period);\n    return smoothstep(0.4, 0.5, t) * smoothstep(1.0, 0.9, t);\n}\n\nvec3 colorscale (float phase) {\n    return rainbow(phase / 2.0 - 0.25);\n}\n\nvec2 complexContouringGridFunction (vec2 x) {\n  return 2.0 * abs(fract(x - 0.5) - 0.5);\n}\n\nfloat checkerboard (vec2 xy) {\n  vec2 f = fract(xy * 0.5) * 2.0 - 1.0;\n  return f.x * f.y > 0.0 ? 1.0 : 0.0;\n}\n\nvec4 rectangularDomainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 baseScale,\n                     vec2 gridOpacity,\n                     float shadingOpacity,\n                     float lineWidth,\n                     float lineFeather,\n                     vec3 gridColor,\n                     float phaseColoring\n) {\n  float cmagRecip = 1.0 / hypot(f_df.xy);\n  baseScale *= 10.0;\n\n  vec2 znorm = f_df.xy * cmagRecip;\n  float cmagGradientMag = hypot(vec2(dot(znorm, f_df.zw), dot(vec2(znorm.y, -znorm.x), f_df.zw)));\n\n  float xContinuousScale = log2(cmagGradientMag) / log2(steps.x);\n  float xDiscreteScale = floor(xContinuousScale);\n  float xScalePosition = 1.0 - (xContinuousScale - xDiscreteScale);\n\n  float yContinuousScale = log2(cmagGradientMag) / log2(steps.y);\n  float yDiscreteScale = floor(yContinuousScale);\n  float yScalePosition = 1.0 - (yContinuousScale - yDiscreteScale);\n\n  vec2 scalePosition = 1.0 - vec2(xContinuousScale, yContinuousScale) + vec2(xDiscreteScale, yDiscreteScale);\n  vec2 scaleBase = vec2(pow(steps.x, -xDiscreteScale), pow(steps.y, -yDiscreteScale)) / baseScale;\n\n  float width1 = max(0.0, lineWidth - lineFeather);\n  float width2 = lineWidth + lineFeather;\n\n  float totalWeight = 0.0;\n  float shading = 0.0;\n  vec2 invSteps = 1.0 / steps;\n  vec2 octaveScale = vec2(1.0);\n  vec2 grid = vec2(0.0);\n  vec2 gridScaleBase = vec2(\n    pow(steps.x, xScalePosition),\n    pow(steps.y, yScalePosition)\n  );\n\n  for(int i = 0; i < octaves; i++) {\n    float w0 = i == 0 ? 1e-4 : 1.0 + float(i);\n    float w1 = i == octaves - 1 ? 1e-4 : 1.0 + float(i + 1);\n    float w = mix(w0, w1, xScalePosition);\n    totalWeight += w;\n    vec2 value = f_df.xy * scaleBase * octaveScale;\n\n    vec2 gridSlope = baseScale * gridScaleBase / octaveScale / steps;\n    //float t = 0.01;\n    //float gridStrength = smoothstep(2.0 / t, 1.0 / t, 1.0 / value.x);\n    vec2 xygrid = complexContouringGridFunction(value) * gridSlope;\n\n    grid += w * vec2(smoothstep(width2, width1, xygrid.x), smoothstep(width2, width1, xygrid.y));\n\n    shading += w * checkerboard(value);\n    \n    octaveScale *= invSteps;\n  }\n\n  shading = shading / totalWeight;\n  grid /= totalWeight;\n  grid *= gridOpacity;\n\n  float carg = atan(f_df.y, f_df.x) * HALF_PI_INV * 2.0;\n  vec3 color = mix(vec3(1.0), clamp(colorscale(carg), 0.0, 1.0), phaseColoring);\n\n  const float gamma = 0.454;\n  color.r = pow(color.r, gamma);\n  color.g = pow(color.g, gamma);\n  color.b = pow(color.b, gamma);\n    \n  color = mix(vec3(1), color, 0.97);\n\n  float mixedGrid = max(grid.x, grid.y);\n  float shade = mix(1.0, shading, shadingOpacity);\n  vec3 result = clamp(mix(color * shade, gridColor, mixedGrid), vec3(0), vec3(1));\n\n  result.r = pow(result.r, 1.0 / gamma);\n  result.g = pow(result.g, 1.0 / gamma);\n  result.b = pow(result.b, 1.0 / gamma);\n  \n  return vec4(result, 1);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = pixelToXY(fragCoord);\n    vec2 mouse = pixelToXY(iMouse.xy);\n\n    vec2 fz = f(xy, iTime * 0.2, mouse);\n    \n    // fwidth(fz) works, but it adds ugly anisotropy in the width of lines near zeros/poles.\n    // Insead, we compute the magnitude of the derivatives separately.\n    //\n    // Also *NOTE* that this is a very important place in which we use `hypot` instead of an\n    // algebraically equivalent built-in `length`. Floating point is limited and we lose lots\n    // of our floating point domain if we're not careful about over/underflow.\n    vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n   \tfloat select = animate ? selector(iTime) : (grid ? 1.0 : 0.0);\n\n    fragColor = rectangularDomainColoring(\n        fdf,\n        vec2(8.0), // steps\n        vec2(1.0), // scale\n        mix(vec2(0.4), vec2(1.0), select), // grid opacity\n        mix(0.2, 0.0, select),       // shading opacity\n        lineWidth,\n        lineFeather,\n        gridColor,\n        mix(1.0, 0.0, select)        // phase coloring\n    );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n\n// https://github.com/d3/d3-color\n// Copyright 2010-2016 Mike Bostock\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n// \n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n// \n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// \n// * Neither the name of the author nor the names of contributors may be used to\n//   endorse or promote products derived from this software without specific prior\n//   written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nvec3 cubehelix(vec3 c) {\n  vec2 sc = vec2(sin(c.x), cos(c.x));\n  return c.z * (1.0 + c.y * (1.0 - c.z) * (\n    sc.x * vec3(0.14861, 0.29227, -1.97294) + \n    sc.y * vec3(1.78277, -0.90649, 0.0)\n  ));\n}\n\nvec3 rainbow(float t) {\n  return cubehelix(vec3(\n    TWO_PI * t - 1.74533,\n    (0.25 * cos(TWO_PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n  ));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3f3cRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Voxel Edge abossard 429",
    "description": "Correct edge detection for voxels. The marching function is fb39ca4's DDA, but using floating point operations instead of integers. The most interesting bits are probably the exact 3D intersector, the occlusion and the edge detection code.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raymarching",
     "voxel",
     "occlusion",
     "dda"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot\n// host, display, distribute or share this Work neither as\n// is or altered, in any form including physical and\n// digital. You cannot use this Work in any commercial or\n// non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it. You\n// cannot use this Work to train AI models. I share this\n// Work for educational purposes, you can link to it as\n// an URL, proper attribution and unmodified screenshot,\n// as part of your educational material. If these\n// conditions are too restrictive please contact me.\n\n// Shading technique explained here:\n//\n// https://iquilezles.org/articles/voxellines\n\n\n\n// consider replacing this by a proper noise function\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nconst vec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n        \n        // dda\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = raycast( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = vec3(0.5);\n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion (https://iquilezles.org/articles/voxellines/)\n        vec2 st = 1.0 - uv;\n        // edges\n        vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n        // corners\n        vec4 wb = vec4(uv.x*uv.y,\n                       st.x*uv.y,\n                       st.x*st.y,\n                       uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n        occ = wa.x + wa.y + wa.z + wa.w +\n              wb.x + wb.y + wb.z + wb.w;\n           \n           \n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*exp( -0.04*t );;\n        float mi = cos(-0.7+0.5*iTime);\n        mi = smoothstep( 0.70, 0.75, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    \n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tvec2 q = fragCoord / iResolution.xy;\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf3cRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Rainforest abossard 435",
    "description": "Another terrain, with cheap trees made of ellipsoids and noise. It computes analytic normals for the terrain and clouds. The art composed to camera as usual. Making-of Tutorial: [url]https://www.youtube.com/watch?v=BFld4EBO2RE[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raymarching",
     "reprojection"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot\n// host, display, distribute or share this Work neither as\n// is or altered, in any form including physical and\n// digital. You cannot use this Work in any commercial or\n// non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it. You\n// cannot use this Work to train AI models. I share this\n// Work for educational purposes, you can link to it as\n// an URL, proper attribution and unmodified screenshot,\n// as part of your educational material. If these\n// conditions are too restrictive please contact me.\n\n// A rainforest landscape.\n//\n// Tutorial on Youtube : https://www.youtube.com/watch?v=BFld4EBO2RE\n// Tutorial on Bilibili: https://www.bilibili.com/video/BV1Da4y1q78H\n//\n// Buy a metal or paper print: https://www.redbubble.com/shop/ap/39843511\n//\n// Normals are analytical (true derivatives) for the terrain and for the\n// clouds, including the noise, the fbm and the smoothsteps.\n//\n// Lighting and art composed for this shot/camera. The trees are really\n// ellipsoids with noise, but they kind of do the job in distance and low\n// image resolutions Also I used some basic reprojection technique to \n// smooth out the render.\n//\n// See here for more info: \n//  https://iquilezles.org/articles/fbm\n//  https://iquilezles.org/articles/morenoise\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n  //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define LOWQUALITY\n\n//==========================================================================================\n// general utilities\n//==========================================================================================\n#define ZERO (min(iFrame,0))\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p/r.xyx);\n    float k1 = length(p/(r.xyx*r.xyx));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//==========================================================================================\n// hashes (low quality, do NOT use in production)\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\n//==========================================================================================\n// specifics to the actual painting\n//==========================================================================================\n\n\n//------------------------------------------------------------------------------------------\n// global\n//------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 4.8;\nconst float kMaxHeight = 840.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.00025*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); // 0.55\n}\n\n//------------------------------------------------------------------------------------------\n// clouds\n//------------------------------------------------------------------------------------------\n\nvec4 cloudsFbm( in vec3 pos )\n{\n    return fbmd_8(pos*0.0015+vec3(2.0,1.1,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\n\nvec4 cloudsMap( in vec3 pos, out float nnd )\n{\n    float d = abs(pos.y-900.0)-40.0;\n    vec3 gra = vec3(0.0,sign(pos.y-900.0),0.0);\n    \n    vec4 n = cloudsFbm(pos);\n    d += 400.0*n.x * (0.7+0.3*gra.y);\n    \n    if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    nnd = -d;\n    d = min(-d/100.0,0.25);\n    \n    //gra += 0.1*n.yzw *  (0.7+0.3*gra.y);\n    \n    return vec4( d, gra );\n}\n\nfloat cloudsShadowFlat( in vec3 ro, in vec3 rd )\n{\n    float t = (900.0-ro.y)/rd.y;\n    if( t<0.0 ) return 1.0;\n    vec3 pos = ro + rd*t;\n    return cloudsFbm(pos).x;\n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint );\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px )\n{\n    vec4 sum = vec4(0.0);\n\n    // bounding volume!!\n    float tl = ( 600.0-ro.y)/rd.y;\n    float th = (1200.0-ro.y)/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl ); else return sum;\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    float t = tmin;\n    //t += 1.0*hash1(gl_FragCoord.xy);\n    float lastT = -1.0;\n    float thickness = 0.0;\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float nnd;\n        vec4  denGra = cloudsMap( pos, nnd ); \n        float den = denGra.x;\n        float dt = max(0.2,0.011*t);\n        //dt *= hash1(px+float(i));\n        if( den>0.001 ) \n        { \n            float kk;\n            cloudsMap( pos+kSunDir*70.0, kk );\n            float sha = 1.0-smoothstep(-200.0,200.0,kk); sha *= 1.5;\n            \n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            float occ = 0.2+0.7*max(1.0-kk/200.0,0.0) + 0.1*(1.0-den);\n            // lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*occ;\n                 lin += vec3(0.10,0.40,0.20)*1.0*(0.5-0.5*nor.y)*occ;\n                 lin += vec3(1.00,0.95,0.85)*3.0*dif*occ + 0.1;\n\n            // color\n            vec3 col = vec3(0.8,0.8,0.8)*0.45;\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            // front to back blending    \n            float alp = clamp(den*0.5*0.125*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;            \n        }\n        else \n        {\n            dt = abs(den)+0.2;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    \n    //resT = min(resT, (150.0-ro.y)/rd.y );\n    if( lastT>0.0 ) resT = min(resT,lastT);\n    //if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    sum.xyz += max(0.0,1.0-0.0125*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n//------------------------------------------------------------------------------------------\n// terrain\n//------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    float e = fbm_9( p/2000.0 + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); // flag high-slope areas (-0.25, 0.0)\n    e = 600.0*e + 600.0;\n    \n    // cliff\n    e += 90.0*smoothstep( 552.0, 594.0, e );\n    //e += 90.0*smoothstep( 550.0, 600.0, e );\n    \n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n    vec3 e = fbmd_9( p/2000.0 + vec2(1.0,-2.0) );\n    e.x  = 600.0*e.x + 600.0;\n    e.yz = 600.0*e.yz;\n\n    // cliff\n    vec2 c = smoothstepd( 550.0, 600.0, e.x );\n\te.x  = e.x  + 90.0*c.x;\n\te.yz = e.yz + 90.0*c.y*e.yz;     // chain rule\n    \n    e.yz /= 2000.0;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 || pos.y>kMaxHeight ) break;\n        t += clamp( hei, 2.0+t*0.1, 100.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 || pos.y>kMaxHeight  ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    // bounding plane\n    float tp = (kMaxHeight+kMaxTreeHeight-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    // raymarch\n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        // tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)/(dis2-odis2); // linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        // terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); // slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)/(dis-odis); // linear interpolation for better accuracy\n    \n    return vec2(t,t2);\n}\n\n//------------------------------------------------------------------------------------------\n// trees\n//------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.0;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float bb = fbm_4(p.xz*0.075);\n\n    float d = 20.0;\n    vec2 n = floor( p.xz/2.0 );\n    vec2 f = fract( p.xz/2.0 );\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n + g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.5 + 0.2*v.x + 0.3*v.y;\n\n        if( bb<0.0 ) width *= 0.5; else height *= 0.7;\n        \n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        \n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            oMat = 0.5*hash1(n+g+111.0);\n            if( bb>0.0 ) oMat += 0.5;\n            oHei = (p.y - base)/height;\n            oHei *= 0.5 + 0.5*length(q) / width;\n        }\n    }\n\n    // distort ellipsoids to make them look like trees (works only in the distance really)\n    if( rt<1200.0 )\n    {\n        p.y -= 600.0;\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        float att = 1.0-smoothstep(100.0,1200.0,rt);\n        d += 4.0*s*att;\n        oDis = s*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<64; i++ )\n    {\n        float kk1, kk2, kk3;\n        vec3 pos = ro + rd*t;\n        float h = treesMap( pos, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h/t );\n        t += h;\n        if( res<0.001 || t>50.0 || pos.y>kMaxHeight+kMaxTreeHeight ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\n//------------------------------------------------------------------------------------------\n// sky\n//------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    //vec3 col = vec3(0.45,0.6,0.85)/0.85 - rd.y*vec3(0.4,0.36,0.4);\n    //vec3 col = vec3(0.4,0.6,1.1) - rd.y*0.4;\n    vec3 col = vec3(0.42,0.62,1.1) - rd.y*0.4;\n\n    // clouds\n    float t = (2500.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.00104 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.12*dl );\n    }\n    \n\t// sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n//------------------------------------------------------------------------------------------\n// main image making function\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( vec2(iFrame,1) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/ iResolution.y;\n    \n    //----------------------------------\n    // setup\n    //----------------------------------\n\n    // camera\n    float time = iTime;\n    vec3 ro = vec3(0.0, 401.5, 6.0);\n    vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z );\n    \n    //ro += vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time))\n    \n    ro.x -= 80.0*sin(0.01*time);\n    ta.x -= 86.0*sin(0.01*time);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,1.5));\n\n\tfloat resT = 2000.0;\n\n    //----------------------------------\n    // sky\n    //----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n\n\n    //----------------------------------\n    // raycast terrain and tree envelope\n    //----------------------------------\n    {\n    const float tmax = 2000.0;\n    int   obj = 0;\n    vec2 t = raymarchTerrain( ro, rd, 15.0, tmax );\n    if( t.x>0.0 )\n    {\n        resT = t.x;\n        obj = 1;\n    }\n\n    //----------------------------------\n    // raycast trees, if needed\n    //----------------------------------\n    float hei, mid, displa;\n    \n    if( t.y>0.0 )\n    {\n        float tf = t.y;\n        float tfMax = (t.x>0.0)?t.x:tmax;\n        for(int i=ZERO; i<64; i++) \n        { \n            vec3  pos = ro + tf*rd; \n            float dis = treesMap( pos, tf, hei, mid, displa); \n            if( dis<(0.000125*tf) ) break;\n            tf += dis;\n            if( tf>tfMax ) break;\n        }\n        if( tf<tfMax )\n        {\n            resT = tf;\n            obj = 2;\n        }\n    }\n\n    //----------------------------------\n    // shade\n    //----------------------------------\n    if( obj>0 )\n    {\n        vec3 pos  = ro + resT*rd;\n        vec3 epos = pos + vec3(0.0,4.8,0.0);\n\n        float sha1  = terrainShadow( pos+vec3(0,0.02,0), kSunDir, 0.02 );\n        //sha1 *= smoothstep(-0.3,0.0,cloudsShadowFlat(epos, kSunDir));\n        sha1 *= smoothstep(-0.325,-0.075,cloudsShadowFlat(epos, kSunDir));\n        \n        #ifndef LOWQUALITY\n        float sha2  = treesShadow( pos+vec3(0,0.02,0), kSunDir );\n        #endif\n\n        vec3 tnor = terrainNormal( pos.xz );\n        vec3 nor;\n        \n        vec3 speC = vec3(1.0);\n        //----------------------------------\n        // terrain\n        //----------------------------------\n        if( obj==1 )\n        {\n            // bump map\n            nor = normalize( tnor + 0.8*(1.0-abs(tnor.y))*0.8*fbmd_7( (pos-vec3(0,600,0))*0.15*vec3(1.0,0.2,1.0) ).yzw );\n\n            col = vec3(0.18,0.12,0.10)*.85;\n\n            col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.2, smoothstep(0.7,0.9,nor.y) );      \n            float dif = clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            #ifndef LOWQUALITY\n            dif *= sha2;\n            #endif\n\n            float bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );\n            float foc = clamp( (pos.y/2.0-180.0)/130.0, 0.0,1.0);\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.1),vec3(0.7,0.9,1.5)*3.0,dom)*foc;\n                  lin += 1.0*8.5*vec3(1.0,0.9,0.8)*dif;        \n                  lin += 1.0*0.27*vec3(1.1,1.0,0.9)*bac*foc;\n            speC = vec3(4.0)*dif*smoothstep(20.0,0.0,abs(pos.y/2.0-310.0)-20.0);\n\n            col *= lin;\n        }\n        //----------------------------------\n        // trees\n        //----------------------------------\n        else //if( obj==2 )\n        {\n            vec3 gnor = treesNormal( pos, resT );\n            \n            nor = normalize( gnor + 2.0*tnor );\n\n            // --- lighting ---\n            vec3  ref = reflect(rd,nor);\n            float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*displa,3.0);\n            float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            if( dif>0.0001 )\n            {\n                float a = clamp( 0.5+0.5*dot(tnor,kSunDir), 0.0, 1.0);\n                a = a*a;\n                a *= occ;\n                a *= 0.6;\n                a *= smoothstep(60.0,200.0,resT);\n                // tree shadows with fake transmission\n                #ifdef LOWQUALITY\n                float sha2  = treesShadow( pos+kSunDir*0.1, kSunDir );\n                #endif\n                dif *= a+(1.0-a)*sha2;\n            }\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            float bac = clamp( 0.5+0.5*dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );                 \n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            //float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*(0.2+0.8*pow(fre,5.0))*occ;\n\n            // --- lights ---\n            vec3 lin  = 12.0*vec3(1.2,1.0,0.7)*dif*occ*(2.5-1.5*smoothstep(0.0,120.0,resT));\n                 lin += 0.55*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n                 lin += 0.07*vec3(1.0,1.0,0.9)*bac*occ;\n                 lin += 1.10*vec3(0.9,1.0,0.8)*pow(fre,5.0)*occ*(1.0-smoothstep(100.0,200.0,resT));\n            speC = dif*vec3(1.0,1.1,1.5)*1.2;\n\n            // --- material ---\n            float brownAreas = fbm_4( pos.zx*0.015 );\n            col = vec3(0.2,0.2,0.05);\n            col = mix( col, vec3(0.32,0.2,0.05), smoothstep(0.2,0.9,fract(2.0*mid)) );\n            col *= (mid<0.5)?0.65+0.35*smoothstep(300.0,600.0,resT)*smoothstep(700.0,500.0,pos.y):1.0;\n            col = mix( col, vec3(0.25,0.16,0.01)*0.825, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,tnor.y) );\n            col *= 1.0-0.5*smoothstep(400.0,700.0,pos.y);\n            col *= lin;\n        }\n\n        // spec\n        vec3  ref = reflect(rd,nor);            \n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float spe = 3.0*pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*(0.05+0.95*pow(fre,5.0));\n        col += spe*speC;\n\n        col = fog(col,resT);\n    }\n    }\n\n\n\n    float isCloud = 0.0;\n    //----------------------------------\n    // clouds\n    //----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, resT, resT, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n        isCloud = res.w;\n    }\n\n    //----------------------------------\n    // final\n    //----------------------------------\n    \n    // sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(0.8,0.4,0.2)*pow( sun, 4.0 );\n \n\n    // gamma\n    //col = sqrt( clamp(col,0.0,1.0) );\n    col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n\n    // contrast\n    col = col*col*(3.0-2.0*col);            \n    \n    // color grade    \n    col = pow( col, vec3(1.0,0.92,1.0) );   // soft green\n    col *= vec3(1.02,0.99,0.9 );            // tint red\n    col.z = col.z+0.1;                      // bias blue\n    \n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel0,ivec2(0,0), 0),\n                            texelFetch(iChannel0,ivec2(1,0), 0),\n                            texelFetch(iChannel0,ivec2(2,0), 0) );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam); // note inverse multiply\n    // ndc space\n    vec2 npos = 1.5 * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= o/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1+0.8*isCloud );\n    }\n\n    //----------------------------------\n    ivec2 ip = ivec2(fragCoord);\n\tif( ip.y==0 && ip.x<=2 )\n    {\n        fragColor = vec4( ca[ip.x], -dot(ca[ip.x],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cccRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Base warp  abossard 441",
    "description": "Base for warp fBM (Fractional Brownian Motion) implemented from articles from @iq https://iquilezles.org/articles/warp/warp.htm\nWith transform_rose colormap from colormap-shaders",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "fbm",
     "warp",
     "cineshader"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n// https://iquilezles.org/articles/warp\n/*float noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}*/\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Base warp fBM\",\n\t\"description\": \"Noise but Pink\",\n\t\"model\": \"person\"\n}\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcccRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Lover 2 abossard 446",
    "description": "Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3  \ntrying to mimic Karthik Dondeti https://twitter.com/d0ndeti/status/1479814051366539264 series.\n\n- A:use close curve, starting as circle. k partics\n- I: basic drawing\nstill, there are crossings.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "paper",
     "reproduction",
     "dondeti"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  Q = B( U ).zzzz; }\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 R; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R = iResolution.xy; I = iFrame;\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat G1 (float w, float s) {\n    return 0.3989422804*exp(-.5*w*w/s/s)/(s);\n}\nfloat heart (vec2 u) {\n    u -= vec2(.5,.4)*R;\n    u.y -= 10.*sqrt(abs(u.x));\n    u.y *= 1.;\n    u.x *= .8;\n    if (length(u)<.35*R.y) return 1.;\n    else return 0.;\n}\n\nfloat _12(vec2 U) {\n\n    return clamp(floor(U.x)+floor(U.y)*R.x,0.,R.x*R.y);\n\n}\n\nvec2 _21(float i) {\n\n    return clamp(vec2(mod(i,R.x),floor(i/R.x))+.5,vec2(0),R);\n\n}\n\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\tfloat l = (length(p-a-(b-a)*i));\n    return l;\n}\n\nfloat hash (vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    float \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nfloat fbm (vec2 p) {\n    float o = 0.;\n    for (float i = 0.; i < 3.; i++) {\n        o += noise(.1*p)/3.;\n        o += .2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.;\n        p *= 2.;\n    }\n    return o;\n}\nvec2 grad (vec2 p) {\n    float \n    n = fbm(p+vec2(0,1)),\n    e = fbm(p+vec2(1,0)),\n    s = fbm(p-vec2(0,1)),\n    w = fbm(p-vec2(1,0));\n    return vec2(e-w,n-s);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n#define  k ( .02 * R.x*R.y )\nMain \n    float i = _12(U);\n    Q = A(U);\n    \n    vec2 f = vec2(0);\n    \n    if ( i < k ) {\n    for (float j = -20.; j <= 20.; j++) \n        if (j!=0.) {//  && j+i>=0. && j+i<R.x*R.y) {\n        vec4 a = A(_21(mod(i+j,k)));\n        //if (j!=0. && j+i>=0. && j+i<R.x*R.y) {\n        //vec4 a = A(_21(i+j));\n        vec2 r = a.xy-Q.xy;\n        float l = length(r);\n        f += 50.*r/sqrt(l)*(l-abs(j))*(G1(j,10.)+2.*G1(j,5.));\n    }\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 d = D(Q.xy+u);\n        f -= 100.*d.w*u;\n    }\n    if (length(f)>.1) f = .1*normalize(f);\n    Q.zw += f-.03*Q.zw;\n    Q.xy += f+1.5*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    vec4 m = .5*( A(_21(i-1.)) + A(_21(i+1.)) );\n    Q.zw = mix(Q.zw,m.zw,0.1);\n    Q.xy = mix(Q.xy,m.xy,0.01);\n    if (Q.x>R.x)Q.y=.5*R.y,Q.z=-10.;\n    if (Q.x<0.)Q.y=.5*R.y,Q.z=10.;\n    }\n     if (iFrame < 1 || keyClick(32)) {\n        if ( i > k ) \n          Q = vec4(R+i,0,0); \n        else\n          Q = vec4(.5*R + .25*R.y* cos( 6.28*i/k + vec2(0,1.57)), 0,0 );\n    //  Q = vec4(i-.5*R.x*R.y,.5*R.y,0,0);\n    }\n    \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    XY(U,Q,vec4(Q.x-3.));\n    XY(U,Q,vec4(Q.x+3.));\n    XY(U,Q,vec4(Q.x-7.));\n    XY(U,Q,vec4(Q.x+7.));\n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    if (I<1) Q = vec4(_12(U));\n    \n    vec4 a1 = A(_21(Q.x));\n    vec4 a2 = A(_21(Q.x+1.));\n    vec4 a3 = A(_21(Q.x-1.));\n    float l1 = sg(U,a1.xy,a2.xy);\n    float l2 = sg(U,a1.xy,a3.xy);\n    float l = min(l1,l2);\n    Q.z = Q.w = smoothstep(2.,1.,l);\n    Q.w -= .2*heart(U);\n    \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "Main \n    Q = vec4(0);\n    for (float x = -30.; x <= 30.; x++)\n        Q += G1(x,10.)*B(U+vec2(x,0)).w;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "Main \n    Q = vec4(0);\n    for (float y = -30.; y <= 30.; y++)\n        Q += G1(y,10.)*C(U+vec2(0,y)).w;\n        \n    Q = mix(Q,D(U),.5);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fccRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Protean cl abossard 449",
    "description": "Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.\n\nFeaturing simple mouse interaction.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "fast",
     "volumetric"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarily rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfccRS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Fractal La abossard 452",
    "description": ":D",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fractal",
     "cartoon"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rn",
       "filepath": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n// There are no lights and no AO, only color by normals and dark edges.\n\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n//#define SHOWONLYEDGES\n#define NYAN \n#define WAVES\n#define BORDER\n\n#define RAY_STEPS 150\n\n#define BRIGHTNESS 1.2\n#define GAMMA 1.4\n#define SATURATION .65\n\n\n#define detail .001\n#define t iTime*.5\n\n\nconst vec3 origin=vec3(-1.,.7,0.);\nfloat det=0.0;\n\n\n// 2D rotation function\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// \"Amazing Surface\" fractal\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\t\tp.y-=.25;\n\t\tp.xy*=rot(radians(35.));\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\n// Distance function\nfloat de(vec3 pos) {\n#ifdef WAVES\n\tpos.y+=sin(pos.z-t*6.)*.15; //waves!\n#endif\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n\tpos.z=abs(.25-mod(pos.z,.5));\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n\tfloat d=min(fr,ro);\n\treturn d;\n}\n\n\n// Camera path\nvec3 path(float ti) {\n\tti*=1.5;\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\n\treturn p;\n}\n\n// Calc normals, and here is edge detection, set to variable \"edge\"\n\nfloat edge=0.;\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\tfloat d=de(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.55)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n\n// Used Nyan Cat code by mu6k, with some mods\n\nvec4 rainbow(vec2 p)\n{\n\tfloat q = max(p.x,-0.1);\n\tfloat s = sin(p.x*7.0+t*70.0)*0.08;\n\tp.y+=s;\n\tp.y*=1.1;\n\t\n\tvec4 c;\n\tif (p.x>0.0) c=vec4(0,0,0,0); else\n\tif (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\n\tif (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\n\tif (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\n\tif (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\n\tif (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\n\tif (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\n\tif (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n\tif (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\n\t\tc=vec4(0,0,0,0);\n\tc.a*=.8-min(.8,abs(p.x*.08));\n\tc.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\n\treturn c;\n}\n\nvec4 nyan(vec2 p)\n{\n\tvec2 uv = p*vec2(0.4,1.0);\n\tfloat ns=3.0;\n\tfloat nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\n\tfloat ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\n\tvec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,1.-.5+uv.y+ny));\n\tif (uv.x<-0.3) color.a = 0.0;\n\tif (uv.x>0.2) color.a=0.0;\n\tif (uv.y>.3) color.a=0.0;\n\tif (uv.y<-.3) color.a=0.0;\n\treturn color;\n}\n\n\n// Raymarching and 2D graphics\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tedge=0.;\n\tvec3 p, norm;\n\tfloat d=100.;\n\tfloat totdist=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<25.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d; \n\t\t}\n\t}\n\tvec3 col=vec3(0.);\n\tp-=(det-d)*dir;\n\tnorm=normal(p);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(edge); // show wireframe version\n#else\n\tcol=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\n#endif\t\t\n\ttotdist=clamp(totdist,0.,26.);\n\tdir.y-=.02;\n\tfloat sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*5.; // responsive sun size\n\tfloat an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\t\n\t// set up background with sky and sun\n\tvec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n\t\t backg+=vec3(1.,.9,.1)*s;\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\n\t\n\tcol=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\n\tif (totdist>25.) col=backg; // hit background\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\n\tcol=mix(vec3(length(col)),col,SATURATION);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(length(col));\n#else\n\tcol*=vec3(1.,.9,.85);\n#ifdef NYAN\n\tdir.yx*=rot(dir.x);\n\tvec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\n\tvec4 ncat=nyan(ncatpos*5.);\n\tvec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\n\tif (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\n\tif (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\n#endif\n#endif\n\treturn col;\n}\n\n// get camera position\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 oriuv=uv;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\n\tfloat fov=.9-max(0.,.7-iTime*.3);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\t#ifdef BORDER\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n\t#endif\n\tfragColor = vec4(color,1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( in int samp,float time)\n{\n    time=mod(time-5.,12.);\n\treturn vec2( fract(sin(6.2831*440.0*time)*100.)*exp(-1.0*time))*min(1.,time);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wc3yzS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Orbital Fl abossard 944",
    "description": "Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n\nIt is meant to be slow pace / viewed at normal speed, but right arrow lets you fast forward.\n\n",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "clouds",
     "earth",
     "space",
     "planet",
     "atmosphere",
     "keplerorbit"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sfGRn",
       "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Orbital Flight by Jerome Liard, August 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4lVGRy\n\n// Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n// It is meant to be slow pace, but right arrow lets you fast forward.\n\n// Some camera paths are kepler orbits, others are just lookats.\n// Atmosphere sections of the shader could be way faster using buffers, but I just brute forced instead.\n// Disclaimer: important physical constants use garbage values, also there is no gamma correction.\n\n// The shader tries to make the most of shadertoy's mushroom texture using layering,\n// tiling, bombing of vortex distortions and silly exaggerations to make clouds shine more in the penumbra zone.\n\n//#define FORCE_CAMERA 2.0 // force camera, int values in [0,CAMERA_NUM[\n#define CAMERA_TIME_RESET // make camera predictable by resetting\n#define CAMERA_PERIOD 30.0 // time we stay on each camera, in seconds\n#define GLOBALTIME (iTime+0.0) // offset sets initial view\n//#define GLOBALTIME (CAMERA_PERIOD*0.0+25.0)\n\n#define CAMERA_NUM 8.0\n\n// set camera order\n#define CAMERA_SPECULAR_CLOSE   0.0\n#define CAMERA_CLOUDS           1.0\n#define CAMERA_TAKE_OFF_BLUE    2.0\n#define CAMERA_ORBITING_FAR     3.0\n#define CAMERA_SPECULAR_FAR     4.0\n#define CAMERA_TAKE_OFF_SUNRISE 5.0\n#define CAMERA_ORBITING_CLOSE   6.0\n#define CAMERA_MOON_WIP         7.0 // moon has no surface shader yet...\n\n#define CLOUD_FLOW\n#define EARTH_ROTATION\n//#define HD_BLACK_BANDS\n//#define SUPER_SAMPLE_HORIZON\n//#define NO_EXPOSE\n\n#define PI\t\t\t3.141592654\n#define FLT_MAX\t\t1000000.0\n\n#define RED\t\t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE\t\tvec3(0,0,1)\n#define WHITE\t\tvec3(1,1,1)\n#define BLACK\t\tvec3(0,0,0)\n#define MAGENTA\t\tvec3(1,0,1)\n#define YELLOW\t\tvec3(1,1,0)\n#define CYAN\t\tvec3(0,1,1)\n#define GREY50\t\tvec3(0.5,0.5,0.5)\n\n#define R01         vec2( 0.999847695, 0.017452406 )\n\n#define const\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\nfloat hash11( float p )\n{\n\tvec2 p2 = fract( vec2( p * 5.3983, p * 5.4427 ) );\n\tp2 += dot( p2.yx, p2.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( p2.x * p2.y * 95.4337 );\n}\n\nvec3 hash32( vec2 p )\n{\n\tp  = fract( p * vec2( 5.3983, 5.4427 ) );\n\tp += dot( p.yx, p.xy +  vec2( 21.5351, 14.3137 ) );\n\treturn fract( vec3( p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365 ) );\n}\n\nvec4 xyz1( vec3 v ) { return vec4( v, 1. ); }\nvec4 xyz0( vec3 v ) { return vec4( v, 0. ); }\nvec3 xy0( vec2 v ) { return vec3( v, 0. ); }\nvec4 xy01( vec2 v ) { return vec4( v, 0., 1. ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat smoothstep_unchecked_6( float x ) { return x * x * x * x * x * ( 6.0 - 5.0 * x ); }\nfloat smoothbump( float c, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - c ), r ) / r ); }\nfloat remap( float x, float a, float b ) { return clamp( ( x - a ) / ( b - a ), 0., 1. ); }\nfloat tri( float x, float spacing ) { return spacing - ( abs( ( spacing * fract( x / spacing ) - spacing * 0.5 ) ) + spacing * 0.5 ); }\nfloat tri( float x ) { return 1.0 - abs( fract( x * 0.5 ) - 0.5 ) * 2.0; }\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow3( float x ) { return x * x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow3( vec4 x ) { return x * x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat soft_max( float x, float y, float k ) { return log( exp( k * x ) + exp( k * y ) ) / k; }\nfloat soft_max( float x, float y, float z, float k ) { return log( exp( k * x ) + exp( k * y ) + exp( k * z ) ) / k; }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ));\n}\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nmat4 zup_spherical_lookat2( float theta, float phi )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ));\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi )\n{\n\treturn zup_spherical_coords_to_vector( theta, phi ).yzx;\n}\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ));\n}\n\nmat4 z_rotation( float angle )\n{\n\tvec2 v = unit_vector2( angle );\n\treturn mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// use with constants...\n#define POW0(x) 1.0\n#define POW1(x) (x)\n#define POW2(x) (POW1(x)*(x))\n#define POW3(x) (POW2(x)*(x))\n#define POW4(x) (POW3(x)*(x))\n#define POW5(x) (POW4(x)*(x))\n#define POW6(x) (POW5(x)*(x))\n\n// project this on line (O,d), d is assumed to be unit length\nvec3 project_on_line1( vec3 P, vec3 O, vec3 d ) { return O + d * dot( P - O, d ); }\n\n#define layered5_pass_scale(func,p,a)((func(p,POW0(2.0),a)*POW1(0.5)+func(p,POW1(2.0),a)*POW2(0.5)+func(p,POW2(2.0),a)*POW3(0.5)+func(p,POW3(2.0),a)*POW4(0.5)+func(p,POW4(2.0),a)*POW5(0.5))*(1.0/(1.0-POW5(0.5))))\n\nstruct NoiseTiledParams\n{\n\tvec3 eye, n, p;\n\tfloat bias;\n};\n\nvec2 grid3( vec2 x, vec2 r ) { return smoothstep( r, vec2( 1.0 ), abs( ( fract( x ) - vec2( 0.5 ) ) * 2.0 ) ); }\n\nfloat tile_tex( in vec2 uv, float s, NoiseTiledParams ntp )\n{\n\tuv *= s;\n\n\tfloat bias = 0.0;\n\n\tfloat edge = 1.0 - dot( normalize( ntp.eye - ntp.p ), ntp.n );\n\tbias = -1.2 * edge; // bias the mipmap blur horror on edges\n\n\tbias += ntp.bias;\n\n\t// make the texture tilable\n\tfloat a0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.0 ), bias ).x; // main image\n\tfloat b0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.5 ), bias ).x; // fill seams\n\t// it's ok to fract on the seam filling lookups\n\t// without fract we are smooth tiled everywhere but at mipmap horror line\n\tfloat a1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.0 ), bias ).x; // fill seams\n\tfloat b1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.5 ), bias ).x; // fill seams\n\n\tfloat r = 1.0 - 0.2; // note: don't divide by s... 0,1 here\n\tuv = grid3( uv, vec2( r ) );\n\treturn mix( mix( a0, b0, uv.y ), mix( a1, b1, uv.y ), uv.x );\n}\n\nfloat fbm5_tiled_clouds( vec2 p, NoiseTiledParams ntp ) { return layered5_pass_scale( tile_tex, p, ntp ); }\n\n// just return the delta\nvec3 vortex( vec2 q, float max_twist, float aa_scale )\n{\n\tvec2 c = vec2( 0.5, 0.5 );\n\tfloat r0 = 0.5;\n\tvec2 v = ( q - c );\n\tfloat r = length( v );\n\tfloat x = min( r / r0, 1.0 );\n\tfloat aa = pow2( 1.0 - x );\n\treturn vec3( c + rotate_with_angle( q - c, aa * max_twist ) - q, aa * aa_scale );\n}\n\nvec3 vortex_bombing( vec2 p, float scale, float max_twist, float aa_scale, float probability )\n{\n\tp *= scale;\n\tvec2 pi = floor( p );\n\tvec2 pf = fract( p );\n\tvec3 x = vec3( 0.0, 0.0, 0.0 );\n\tfor ( int i = -1; i <= 1; ++i )\n\t{\n\t\tfor ( int j = -1; j <= 1; ++j )\n\t\t{\n\t\t\tvec2 o = vec2( float( i ), float( j ) );\n\t\t\tvec2 pj = pi + o;\n\t\t\tpj.x = mod( pj.x, scale ); // we are mapping a sphere so want same distortion at the u=0, u=1 limit\n\t\t\tvec3 rj = hash32( pj );\n\t\t\tif ( rj.z <= probability ) x += vortex( pf - o - rj.xy, max_twist * rj.z, aa_scale * rj.z ); //p - ( pj + rj.xy ) == ( pi + pf ) - ( pj + rj.xy ) == pf - o - rj.xy\n\t\t}\n\t}\n\treturn x;\n}\n\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\n\nvec2 sphere_trace( Ray ray, float radius, vec3 C )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec3 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n#define earth_center vec3(0.0,0.0,0.0)\n//const float atm_scale=1e+3f; // 1=1m\n#define atm_scale 1.0 // 1=1km\n#define sun_direction vec3(0.0,1.0,0.0) // normalized please\nconst float earth_angular_velocity = ( 2.0 * PI / ( 24.0 * 60.0 * 60.0 ) );\nconst float earth_radius = 6378.15 * atm_scale;\nconst float sun_radius = 6.955e+5 * atm_scale; // for render only\n#define sun_dist (1.49e+8*atm_scale) // for render only\nconst float sun_cos = 0.999989; // for render only\nconst float sun_solid_angle = 0.0093355;  // sun view angle\nconst vec3 sun_center = earth_center + sun_direction * sun_dist;\n//const vec3 moon_direction=sun_direction; // full sun eclipse\n#define moon_direction /*normalize(*/vec3(1.0,0.0,0.0)/*)*/\t// moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.01f,1.0,0.0)); // moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.015f,1.0,-0.02f));\t// moon close to sun, a bit far appart\n//const vec3 moon_direction=normalize(vec3(0.0,-1.0,0.0)); // moon fully occluded\n//const vec3 moon_direction=normalize(vec3(0.016f,-1.0,0.0)); // half moon\nconst float moon_radius = 1738.14 * atm_scale;\n#define moon_dist (384400.0*atm_scale)\nconst float moon_cos = 0.99999;\nconst vec3 moon_center = earth_center + moon_direction * moon_dist;\nconst float H0_r = 0.7994 * atm_scale; // normally this is 8km\nconst float H0_m = 1.2 * atm_scale;\nconst float atm_max = 20.0 * atm_scale; // as small as possible, large enough to accomodate H0_ values\nconst vec3 beta_r = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // fudge factor & account for km\nconst vec3 beta_m = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // beta_m is normally a scalar (2.10e-005/m in \"Precomputed Atmospheric Scattering\" Fig7), but I tweaked this shader before fixing the constants\nconst vec3 Is = vec3( 1.0, 1.0, 1.0 ) * 35.0;\nconst vec3 earth_diffuse_reflection = vec3( 0.2 );\nconst float cloud_start = 1.0 * atm_scale;\nconst float cloud_end = 10.0 * atm_scale;\nconst float ie_cost_min = -0.3420; //110deg\n\nfloat sunh( float viewdist )\n{\n\treturn viewdist * ( sun_radius / sun_dist );\n//\treturn viewdist * tan( sun_solid_angle * 0.5 );\n}\n\n// params for Ie term manual fit\nstruct IeApproxS\n{\n\tfloat a;\n\tfloat k;\n\tfloat sx;\n\tfloat sy;\n\tfloat last_bit;\n};\n\nIeApproxS ie_params_r;\nIeApproxS ie_params_g;\nIeApproxS ie_params_b;\n\nvec2 calc_rho( float h ) { return exp( -vec2( h ) / vec2( H0_r, H0_m ) ); }\n\nstruct vec6 { vec3 r; vec3 m; };\n\nvec6 mkvec6( vec2 s ) { vec6 val; val.r = vec3( s.x ); val.m = vec3( s.y ); return val; }\nvec6 mkvec6( float s ) { return mkvec6( vec2( s, s ) ); }\n\nvoid add_vec6( inout vec6 od, vec6 value, float ds )\n{\n\tod.r += value.r * beta_r * ds;\n\tod.m += value.m * beta_m * ds;\n}\n\nvec6 opticalDepth( Ray ray, float t, float t2 )\n{\n\tvec6 ret = mkvec6( 0.0 );\n\t#define num_segments 20\n\tfloat dt = ( t2 - t ) / float( num_segments );\n\tfor ( int i = 0; i < num_segments + 1; ++i )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\tadd_vec6( ret, mkvec6( rho ), dt * ( ( i == 0 || i == num_segments ) ? 0.5 : 1.0 ) );\n\t\tt += dt;\n\t}\n\treturn ret;\n}\n\n// http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\nfloat CornetteSingleScatteringPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return 3.0 * ( 1.0 - g2 ) * ( 1.0 + pow2( cos_theta ) ) / ( 2.0 * ( 2.0 + g2 ) * pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ) ); }\n\n// == CornetteSingleScatteringPhaseFunction( cos_theta, 0.0 )\nfloat RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }\n\n// https://www.astro.umd.edu/~jph/HG_note.pdf HG, g in [-1,1]\nfloat HenyeyGreensteinPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return ( 1.0 / ( 4.0 * PI ) ) * ( 1.0 - g2 ) / pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ); }\n\nfloat calc_Fr_r( float cos_theta ) { return RayleighScattering( cos_theta  ); }\nfloat calc_Fr_m( float cos_theta, float g ) { return CornetteSingleScatteringPhaseFunction( cos_theta, g ); }\n\nbool in_earth_shadow( vec3 p )\n{\n\treturn ( dot( p, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius );\n}\n\nbool in_moon_shadow( vec3 p )\n{\n\treturn ( dot( p - moon_center, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, moon_center, sun_direction ) ) < moon_radius * moon_radius );\n}\n\n// this is a manual fit of the offline precalculated Ie 1d table (with various wrong physical constant) for each r,g,b, plus slight tweaks\nfloat ie_approx_S( float cos_alpha, IeApproxS params )\n{\n\tfloat y =\n\t\tsoft_max( cos_alpha * params.sx, params.a, params.k ) * params.sy\n\t\t- soft_max( 0.0, params.a, params.k ) * params.sy;\n\n\tfloat c = 0.98;\n\tif ( cos_alpha > c ) y *= ( 1.0 + params.last_bit * ( cos_alpha - c ) / ( 1.0 - c ) );\n\treturn max( 0.0, y );\n}\n\nvoid Ie_ie_params_init()\n{\n\tie_params_r.a = 1.07143104;\n\tie_params_r.k = 0.578571617;\n\tie_params_r.sx = 12.857152938;\n\tie_params_r.sy = 2.785715818;\n\tie_params_r.last_bit = 0.042857192;\n\n\tie_params_g.a = 5.250002384;\n\tie_params_g.k = 0.385714441;\n\tie_params_g.sx = 24.000009536;\n\tie_params_g.sy = 1.357144474;\n\tie_params_g.last_bit = 0.126428619;\n\n\tie_params_b.a = 7.285716533;\n\tie_params_b.k = 0.435714453;\n\tie_params_b.sx = 13.285723686;\n\tie_params_b.sy = 2.928573131;\n\tie_params_b.last_bit = 0.300000011;\n}\n\nvec3 calc_Ie_shaderfunc( float cos_alpha )\n{\n\tIe_ie_params_init();\n\tfloat bleed = 0.02; //0.0 means no bleed, sunset cameras need enough bleeding to look interesting\n\tcos_alpha = 1.0 + ( cos_alpha - 1.0 ) * ( 1.0 - bleed ); // exaggerate Ie bleed a little bit\n\tcos_alpha = clamp( cos_alpha, ie_cost_min, 1.0 - 0.019 ); // cos alpha=1 has a weird blob, clamp a bit...\n\treturn vec3( ie_approx_S( cos_alpha, ie_params_r ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_g ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_b ) );\n}\n\nstruct LameTweaks\n{\n\tfloat earth_rot_time;\n\tfloat cloud_flow_time;\n\t// no PBR no life\n\tfloat specular_hack;\n\tvec3 cloud_hack;\n};\n\nfloat cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )\n{\n\tvec2 p0 = p;\n\n\tfloat pole = 0.1;\n\tp.y = ( p.y - pole ) / ( 1.0 - 2.0 * pole );\n\n\t// p0 is in x 0,1\n\t// q0 is in x 0,2\n\n\tvec3 q = vec3( p * vec2( 2, 1 ), 0.0 );\n\n\tvec3 q0 = q;\n\n//\tq += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); // 1\n//\tq += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); // 2\n//\tq += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); // 3\n\tq += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); // 4\n//\tq += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); // 5\n\tq += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); // 6\n//\tq += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); // 7\n\n\tvec2 qoff = vec2( 0.0, 0 );\n#ifdef CLOUD_FLOW\n\tqoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; //cloud flow (doesn't fix black line)\n#endif\n\n\tNoiseTiledParams ntp;\n\tntp.eye = camera[3].xyz;\n\tntp.n = n;\n\tntp.p = n * earth_radius;\n\tntp.bias = bias;\n\n\tfloat a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );\n\n\ta *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); // would like to do better than that...\n\n\tfloat a0 = a;\n\n\t{\n\t\t//increase density on areas that have vortices\n\t\ta += length( q - q0 ) * 0.5;\n\t\ta += q.z * q.z * 5.0;\n\t}\n\n\t// add a little bit more oompf detail, helps overall + on cloud close ups\n\ta += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;\n\n\ta = contrast( a + 0.05, 2.75 ); // higher contrast = deeper blue if we keep negative cloud\n\ta = soft_max( a, 0.0, 15.0 );\n\treturn a;\n}\n\nfloat cloudMap( vec3 n, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tvec3 n0 = n;\n#ifdef EARTH_ROTATION\n\tn.xy = rotate_with_angle( n.xy, lame_tweaks.earth_rot_time * earth_angular_velocity );\n#endif\n\tfloat theta = acos( n.z );\n\tfloat phi = calc_angle( n.xy ) + PI; // assume range 0,1\n\n\treturn cloudSphereMap( vec2( phi * 0.5, theta ) * ( 1.0 / PI ), camera, n0, bias, lame_tweaks );\n}\n\nstruct CloudOut\n{\n\tvec3 sphere_point, sphere_normal;\n\tfloat cloud;\n\tbool hit;\n};\n\n// just one sphere lookup\nCloudOut cloudTraceFlat( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\tfloat cloud_height = mix( cloud_start, cloud_end, 0.5 ); // cloud alt should be a number in 0-1\n//\tfloat cloud_height = mix( cloud_start, cloud_end, 10.0 ); // over the top shadow... fun\n\tvec2 tb = sphere_trace( ray, earth_radius, earth_center );\n\tvec2 tc = sphere_trace( ray, earth_radius + cloud_height, earth_center );\n\tif ( tc.x == FLT_MAX ) return ret; // no intersection with cloud sphere\n\tif ( tc.x < 0.0 && tb.x != FLT_MAX && tb.x >= 0.0 ) return ret;\n\tvec3 p = ray.o + ( tc.x < 0.0 ? tc.y : tc.x ) * ray.d;\n\tret.sphere_point = p;\n\tret.sphere_normal = normalize( p - earth_center );\n\tret.cloud = cloudMap( ret.sphere_normal, camera, bias, lame_tweaks );\n\tret.hit = true;\n\treturn ret;\n}\n\n// get a bit of volume\nCloudOut cloudTrace( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\n\tfloat hcs = mix( cloud_start, cloud_end, 0.55 );\n\tfloat hce = mix( cloud_start, cloud_end, 0.8 );\n\tvec2 ts = sphere_trace( ray, earth_radius + hcs, earth_center ); // start\n\tvec2 te = sphere_trace( ray, earth_radius + hce, earth_center ); // end\n\tif ( te.x == FLT_MAX ) return ret; // ray line doesn't intersect a (and therefore, b since b is inside a)\n\tif ( te.y <= 0.0 ) return ret; // ray line intersects a(atm) but behind us\n\tvec2 range;\n\tif ( ts.x == FLT_MAX )\n\t{\n\t\t// inside cloud altitude range, looking at upper cloud shell\n\t\t// ray line intersects a\n\t\t// ray line doesn't intersect b\n\t\trange.x = max( 0.0, te.x );\n\t\trange.y = te.y;\n\t}\n\telse\n\t{\n\t\t// ray line intersects a\n\t\t// ray line intersects b\n\t\tif ( te.x > 0.0 )\n\t\t{\n\t\t\t// hitting clouds from above\n\t\t\t// ray hitting a from outside\n\t\t\trange.x = te.x;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse if ( ts.x > 0.0 )\n\t\t{\n\t\t\t// below lower cloud layer, looking at lower cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// between cloud layers, looking at upper cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = te.y;\n\t\t}\n\t}\n\n\tfloat t = range.x;\n\tfloat dt = ( range.y - range.x ) * ( 1.0 / 8.0 );\n\tfloat min_dist = FLT_MAX;\n\tfloat hcdv = 1.0 / ( hce - hcs );\n\n\tfor ( int i = 0; i < 8; ++i )\n\t{\n\t\tvec3 p = ray.o + t * ray.d;\n\t\tfloat hr = length( p - earth_center );\n\t\tfloat hp = hr - earth_radius;\n\t\tvec3 n = ( p - earth_center ) / hr;\n\n\t\tfloat c = cloudMap( n, camera, bias, lame_tweaks );\n\t\tfloat hc = hcs + ( hce - hcs ) * saturate( c );\n\n\t\tfloat dh = hp - hc;\n\n\t\tif ( abs( dh ) < 0.4 && t <= range.y )\n\t\t{\n\t\t\tret.cloud = c;\n\t\t\tret.sphere_normal = n;\n\t\t\tret.hit = true;\n\n\t\t\tt += dt * 0.5; // note: don't break, keep homing\n\t\t}\n\t\telse t += dt;\n\t}\n\n\treturn ret;\n}\n\n// fade shadow term based on distance\nfloat shadow_falloff( vec3 pa, vec3 pb )\n{\n\tvec3 d = ( pa - pb );\n\treturn 1.0 / ( 1.0 + lensqr( d ) * 0.00005 );\n}\n\n// losely based on http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n\nstruct AtmOut\n{\n\tvec3 vod_attn; //view ray atm scattering\n\tvec3 earth_p;\n\tvec3 earth_n;\n\tbool earth_surface;\n\tvec3 Iv;\n};\n\nvec3 calc_Iv( Ray view_ray, inout AtmOut atm_out, mat4 camera, LameTweaks lame_tweaks )\n{\n\tvec2 te = sphere_trace( view_ray, earth_radius, earth_center );\n\tvec2 ta = sphere_trace( view_ray, earth_radius + atm_max, earth_center );\n\n\tatm_out.earth_surface = ( te.x > 0.0 && te.x != FLT_MAX );\n\tatm_out.vod_attn = vec3( 1.0 );\n\tatm_out.Iv = vec3( 0.0 );\n\n//\tvec3 spacecolor = MAGENTA; // debug\n\tvec3 spacecolor = BLACK;\n\n\tif ( ta.x == FLT_MAX ) return spacecolor; // view_ray line doesn't intersect a (and therefore, e since e is inside a)\n\tif ( ta.y <= 0.0 ) return spacecolor; // return mix(SPACECOLOR,WHITE,0.7);\t// view_ray line intersects a(atm) but behind us\n\tif ( te.x <= 0.0 && te.y >= 0.0 ) return GREEN; // inside (e)earth\n\n\tvec2 range; // range segment we integrate things on along view_ray\n\t\n\tif ( te.x == FLT_MAX ) range = vec2( max( 0.0, ta.x ), ta.y ); // view_ray line intersects a, doesn't intersect e\n\t// view_ray line intersects a and e\n\telse if ( ta.x > 0.0 ) range = vec2( ta.x, te.x ); // ray hitting a from outside atm\n\telse if ( te.x > 0.0 ) range = vec2( 0.0, te.x ); // ray hitting e from inside atm\n\telse range = vec2( 0.0, ta.y ); // ray hitting a from inside atm\n\t\n\tRay sun_ray;\n\tsun_ray.d = sun_direction;\n\n\tfloat tp = range.x;\n\n\t#define num_view_ray_segments 50 // we have to bump this number quite a bit to get decent integration\n\tfloat dl = ( range.y - range.x ) / float( num_view_ray_segments );\n\tif ( dl < 0.0 )\treturn YELLOW;\n\t\n\tvec3 p;\n\tvec6 tppc = mkvec6( 0.0 ); // the last of those is a earth hit -> sun ray when earth_surface is true\n\tvec6 tppa = mkvec6( 0.0 ); // the last of those is a earth hit -> eye ray when earth_surface is true\n\tvec6 Iv_sum = mkvec6( 0.0 );\n\tfor ( int i = 0; i < num_view_ray_segments + 1; ++i )\n\t{\n\t\tp = view_ray.o + view_ray.d * tp;\n\t\tp = earth_center + normalize( p ) * max( earth_radius * 1.00001, length( p ) ); // make sure we don't start inside the earth when P is a hit point\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\ttppc = mkvec6( 0.0 );\n\t\tif ( !in_earth_shadow( p ) )\n//\t\tif ( !in_moon_sun_shadow( p ) )\n\t\t{\n\t\t\tsun_ray.o = p;\n\t\t\tvec2 ta_sun = sphere_trace( sun_ray, earth_radius + atm_max, earth_center );\n\t\t\ttppc = opticalDepth( sun_ray, 0.0/*p*/, ta_sun.y/*pc*/ ); // note: ta_sun.y > 0.0\n\t\t\tvec6 tmp;\n\t\t\t#if 1\n\t\t\t// note: this is not the correct way to combine the r,m transmittance at all, but too late to fix\n\t\t\ttmp.r = rho.x * exp( -tppc.r - tppa.r );\n\t\t\ttmp.m = rho.y * exp( -tppc.m - tppa.m );\n\t\t\t#else\n\t\t\t// normally attenuation should affect both\n\t\t\tvec3 tr = exp( -tppc.r - tppa.r - tppc.m - tppa.m );\n\t\t\ttmp.r = rho.x * tr;\n\t\t\ttmp.m = rho.y * tr;\n\t\t\t#endif\n\t\t\tadd_vec6( Iv_sum, tmp, dl * ( ( i == 0 || i == num_view_ray_segments ) ? 0.5 : 1.0 ) );\n\t\t}\n\t\tadd_vec6( tppa, mkvec6( rho ), dl );\n\t\ttp += dl;\n\t}\n\n\tfloat cos_theta = dot( sun_direction, view_ray.d );\n\tvec3 Iv = Is *\n\t\t( ( Iv_sum.r / ( 4.0 * PI ) ) * calc_Fr_r( cos_theta ) + \n\t\t  ( Iv_sum.m / ( 4.0 * PI ) ) * calc_Fr_m( cos_theta, 0.8 ) );\n\n\tatm_out.Iv = Iv;\n\n\tvec3 Ie = vec3( 0, 0, 0 );\n\tvec6 tPaPb = mkvec6( 0.0 );\n\n\tfloat cloud_shadow = 0.0;\n\tfloat specular = 0.0;\n\n\tif ( atm_out.earth_surface )\n\t{\n\t\t//return RED; // check earth pixel\n\t\tp = view_ray.o + view_ray.d * te.x; // note: we shouldn't need to update p here\n\t\tvec3 n = normalize( p - earth_center );\n\t\tfloat cos_alpha = dot( sun_direction, n );\n\t\tIe = calc_Ie_shaderfunc( cos_alpha );\n//\t\ttPaPb = opticalDepth( view_ray, range.x/*Pa*/, te.x/*Pb*/ );\n\t\ttPaPb = tppa; // tppa already has the value\n\n\t\tatm_out.earth_p = p;\n\t\tatm_out.earth_n = n;\n\n\t\tRay cloud_shadow_ray;\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcloud_shadow_ray.o = p + n * max( 1.00001, cloud_start * 0.5 ); //anything smaller than cloud_start and greater than a separation epsilon\n\n\t\tvec3 tangent = cross( sun_direction, n );\n\t\tvec3 np = normalize( cross( tangent, sun_direction ) );\n\n//\t\tvec2 acs = unit_vector2( radians( 5.0 ) );\n\t\tvec2 acs = R01;\n\t\tfloat w1 = 1.0;\n\t\tfloat w2 = 0.5;\n\n\t\tCloudOut cs;\n\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w1 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x + np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x - np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow *= ( 1.0 / ( w1 + w2 * 2.0 ) );\n\n\t\tvec3 l = sun_direction;\n\t\tvec3 e = -view_ray.d;\n\t\tvec3 h = normalize( e + l );\n\t\tfloat dp = dot( n, l );\n\n\t\tfloat specular_power = 75.0;\n\n\t\tspecular = pow( max( dot( n, h ), 0.0 ), specular_power )\n\t\t\t* ( ( specular_power + 8.0 ) / ( 8.0 * PI ) )\n\t\t\t* max( 0.0, dp );\n\t}\n\n\tCloudOut co = cloudTrace( view_ray, camera, 0.0, lame_tweaks );\n\tfloat cloud = co.cloud;\n\n\tatm_out.vod_attn = exp( -tppa.r ); // for sun attn\n\n\tfloat dp = dot( co.sphere_normal, sun_direction );\n\n\tfloat s = ( 1.0 - saturate( cloud_shadow * ( 1.0 - cloud ) ) );\n\n//\treturn vec3( ( 1.0 - s ) * 3.0, cloud, 0.0 );\n\n\tfloat earth_diffuse = 0.008;  // controls blue depth\n\n\treturn ( 0.0\n\t\t\t + earth_diffuse * s\n\t\t\t + specular * ( 1.0 - saturate( cloud ) ) * lame_tweaks.specular_hack * s * s\n\t\t\t + cloud\n\t\t\t * // this add specks of gold to the clouds in the penumbra zone\n\t\t\t ( 1.0\n\t\t\t   + smoothstep( -0.02, 0.012, dp )\n\t\t\t   * exp( ( cloud - cloud_shadow ) * lame_tweaks.cloud_hack.x )\n\t\t\t   * lame_tweaks.cloud_hack.y ) * lame_tweaks.cloud_hack.z\n\n\t\t\t) * Ie * exp( -tPaPb.r - tPaPb.m )\n\n\t\t   + Iv * ( 2.4 - ( 1.0 - s ) * 0.7 );\n}\n\n// linearly remap nl, cut is the value of nl that maps to 0\nfloat warp_nl( float nl, float cut ) { return max( 0.0, ( nl - cut ) ) / ( 1.0 - cut ); }\n\nfloat noise1s( in float x )\n{\n\tx -= 0.5;\n\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\n\treturn mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n}\n\nfloat calcFallOff( float sd, float r, float p1, float p2 )\n{\n\tfloat sd_last = sun_cos - r; //length of rays\n\tfloat g = 1.0 - saturate( max( sun_cos - sd, 0.0 ) / ( sun_cos - sd_last ) );\n\treturn powerful_scurve( g, p1, p2 );\n}\n\nvec3 earthShader( Ray view_ray, mat4 camera, LameTweaks lame_tweaks, float exposure )\n{\n\tAtmOut atm_out;\n\n\tvec3 ret = calc_Iv( view_ray, atm_out, camera, lame_tweaks );\n\n\tvec3 sun_color = atm_out.vod_attn * vec3( 1.0, 0.85, 0.71 );\n\tfloat sun_intensity = 0.0;\n\n\tfloat sd = dot( normalize( view_ray.d ), sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\n\tbool long_sun_flare = true;\n\tbool thin_flares = true;\n\tbool sun_glare = true;\n\tbool earth_clamped_sun_glare = true;\n\n\tif ( !atm_out.earth_surface )\n\t{\n\t\tvec2 tm = sphere_trace( view_ray, moon_radius, moon_center );\n\t\tif ( tm.x != FLT_MAX && tm.x > 0.0 )\n\t\t{\n\t\t\tvec3 moon_P = view_ray.o + view_ray.d * tm.x;\n\t\t\tfloat moon_sun_shadow = warp_nl( dot( normalize( moon_P - moon_center ), sun_direction ), -0.01 );\n\t\t\tfloat earth_sun_shadow = in_earth_shadow( moon_P ) ? 0.0 : 1.0; // fixme: don't want sharp... precalc or fit something\n\n\t\t\tret += vec3( 0.04 );\n\t\t\tret += min( pow( moon_sun_shadow, 0.57 ), earth_sun_shadow ) * atm_out.vod_attn * 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( earth_clamped_sun_glare )\n\t\t\t{\n\t\t\t\tfloat gs = calcFallOff( sd, 0.01, 1.4, 0.05 );\n\t\t\t\tsun_intensity += 16.0 * gs;\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat theta = acos( clamp( sd, -1., 1. ) );\n\tfloat phi = calc_angle( view_ray.d.zx );\n\tvec2 phi_vec = unit_vector2( phi );\n\n\tfloat sun_visibility = 0.0;\n\tvec3 ep_sv = view_ray.o + sun_direction * dot( earth_center - view_ray.o, sun_direction );\n\t{\n\t\tfloat sh = sunh( length( ep_sv - view_ray.o ) );\n\t\tfloat h = length( ep_sv - earth_center );\n\t\tsun_visibility = saturate( smoothstep( -sh, sh, h - earth_radius ) );\n//\t\tfloat darkness = saturate( smoothstep( 0, earth_radius - sh, h ) );\n//\t\tif ( sun_visibility != 0.0 ) ret += RED;\n\t}\n\n\tfloat xsum = 0.0;\n\n\tif ( long_sun_flare )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-3 * 12., 1.2, 0.07 );\n\n\t\tfloat spacing = 2.0 * PI / 6.0;\n\t\tfor ( int i = 0; i < 6; ++i )\n\t\t{\n\t\t\tvec2 v = unit_vector2( float( i ) * spacing + 0.4 );\n\t\t\tfloat vv = abs( dot( phi_vec * theta, v ) );\n\t\t\tvv /= PI;\n\t\t\tvv *= 0.4;\n\t\t\txsum += exp( -vv * 1500.0 ) * gs * 0.8;\n\t\t}\n\t}\n\n\tif ( thin_flares )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-5 * 4.0, 1.4, 0.3 );\n\n\t\t// thin flares\n\t\tfor ( int i = 0; i < 5; ++i )\n\t\t{\n\t\t\tfloat fi = float( i );\n\t\t\tfloat x = noise1s( phi * 3.5 + fi * 3.0 + 0.5 * sin( GLOBALTIME + fi ) );\n\t\t\tx = pow4( x );\n\t\t\tx = max( 0.0, contrast( x, 1.1 ) );\n\t\t\tx = gs * mix( 0.0, 1.0, x );\n\t\t\txsum += x * 2.0 * gs;\n\t\t}\n\t}\n\n\tret += xsum * ( atm_out.earth_surface ? 0.0 : 1.0 ) * pow( sun_visibility, 0.15 );\n\n\tif ( sun_glare )\n\t{\n\t\t// diffuse fall off\n\t\tsun_intensity += exp( -theta / PI * ( atm_out.earth_surface ? 70.0 : 27.0 ) ) * pow( sun_visibility, 0.20 );\n\t}\n\n\tret += sun_intensity * sun_color;\n\n//\tfloat scene_luminance = 0.0;\n//\tscene_luminance = max( 0.0, dot( view_ray.d, sun_direction ) );\n\n#ifndef NO_EXPOSE\n//\tret = 1.0 - exp( -mix( 0.85, 0.05, scene_luminance/**sun_visibility*/ ) * ret );\n\tret = 1.0 - exp( -exposure * ret );\n#endif\n\treturn ret;\n}\n\n// https://en.wikipedia.org/wiki/Kepler%27s_equation\nfloat kepler_eq_solve( float M, float e/*,float& err*/ )\n{\n\tfloat En = M;\n\tif ( e > 0.8 ) En = PI;\n\tfor ( int i = 0; i < 3; ++i ) En = En - ( En - e * sin( En ) - M ) / ( 1.0 - e * cos( En ) );\n//\terr = max( fabsf( ( En - e * sin( En ) - M ) ), err );\n\treturn En;\n}\n\n// n = mean motion n https://en.wikipedia.org/wiki/Mean_motion (consider this as the \"angular speed\")\n// n = 2pi/period\n// p,e see https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion\n// p is the scale of the trajectory\n// e the eccentricity, 0 for circle\n// becomes ellipsoid (and smaller, so compensate by increasing p) as we get closer to 1\n// above 0.8 kepler_eq_solve needs more iterations\n// rmin=p/(1+e) closest distance to focus...perihelion\n// rmax=p/(1-e) farthest distance to focus..aphelion\nvec2 kepler_orbit( float t, float p, float e, float n/*, float& err*/ )\n{\n\tfloat M = n * t;\n\tfloat E = kepler_eq_solve( M, e/*,err*/ );\n\tfloat a = p / ( 1.0 - e * e );\n\tfloat b = p / sqrt( 1.0 - e * e );\n\tfloat x = a * ( cos( E ) - e );\n\tfloat y = b * sin( E );\n\treturn vec2( x, y );\n}\n\n// calculate p given rmin\nfloat kepler_orbit_calc_p( float rmin, float e )\n{\n\treturn rmin * ( 1.0 + e );\n}\n\nstruct KeplerOrbit\n{\n\tfloat rmin; // min radius\n\tfloat period;\n\tfloat e; // ellipse eccentricity\n};\n\nstruct KeplerOrbitRetval\n{\n\tvec3 orbit_position;\n\tvec3 orbit_plane_normal;\n};\n\nKeplerOrbitRetval get_earth_camera_path_kepler( float t, in KeplerOrbit ko )\n{\n\tKeplerOrbitRetval ret;\n\t// you can can play with highly elliptical orbits here, see\n\t// http://www.polaris.iastate.edu/EveningStar/Unit4/unit4_sub3.htm\n\tfloat n = 2.0 * PI / ko.period;\n\tvec2 p = kepler_orbit( t, kepler_orbit_calc_p( ko.rmin, ko.e ), ko.e, n );\n\tp = perp( p ); // start on y, where the sun is, symmetry more convenient to tweak orbit period\n#if 1\n\t// define trajectory plane here (theta must be non zero if you want an inclination)\n//\tmat4 rep = zup_spherical_lookat2( radians( 90.0 ), radians( 90.0 ) ); // circle around penumbra zone\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tret.orbit_plane_normal = rep[2].xyz;\n\tret.orbit_position = ( rep * xy01( p ) ).xyz;\n#else\n\tret.orbit_plane_normal = vec3( 0, 0, 1 );\n\tret.orbit_position = xy0( xx );\n#endif\n\treturn ret;\n}\n\nvec3 get_earth_camera_path_iss( float t, inout vec3 up )\n{\n\t// needs high fov values\n\tfloat h = 340.0; //ISS\n\tfloat er = earth_radius / atm_scale;\n\tfloat dtheta = t * ( 27.6e+3 / 3600.0 ) / ( er + h ); //27.6km/h\n\tvec2 xx = unit_vector2( dtheta ) * ( er + h );\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tup = rep[2].xyz;\n\treturn ( rep * xy01( xx ) ).xyz;\n}\n\nstruct TangentView\n{\n\tvec3 target_vector; // sphere center -> target unit vector\n\tvec3 tangent_disk_center;\n\tfloat tangent_disk_radius;\n};\n\nTangentView get_tangent_view( vec3 p, vec3 c, float r )\n{\n\tTangentView ret;\n\tret.target_vector = p - c;\n\tfloat dt = length( ret.target_vector );\n\tret.target_vector /= dt;\n\tfloat e = ( r * r ) / dt;\n\tret.tangent_disk_radius = sqrt( r * r - e * e );\n\tret.tangent_disk_center = c + ret.target_vector * e;\n\treturn ret;\n}\n\n// set view center on tangent of a sphere c,r\nvec3 get_tangent_point( vec3 p, vec3 c, float r, vec3 up )\n{\n\tTangentView tv = get_tangent_view( p, c, r );\n\treturn tv.tangent_disk_center +\n\t\t   tv.tangent_disk_radius * normalize( cross( tv.target_vector, cross( up, tv.target_vector ) ) );\n}\n\n// reflect is builtin so use different name\nfloat myreflect( float x, float a ) { return a + ( a - x ); }\n\n// bounce time to make sure we are always travelling above the lit face of the earth\nfloat bounce_time( float t, float period, inout float fade )\n{\n\tt = mod( t, period );\n\tif ( t > period * 0.5 ) t -= period; // want mirrored time values\n\tfloat r = period * 0.005;\n\tfloat a = period * 0.25;\n\tfade *= 1.0 - smoothbump( a + r, r, clamp( abs( t ), a, a + r + r ) );\n\tif ( abs( t ) > ( a + r ) ) t = myreflect( t, ( ( t < 0.0 ) ? -1.0 : 1.0 ) * period * 0.25 );\n\treturn t;\n}\n\nvec3 rotate_around( vec3 c, vec3 z, vec3 p, float angle )\n{\n\tvec3 v = p - c;\n\tvec3 pp = project_on_line1( p, c, z );\n\tvec3 x = normalize( p - pp );\n\tvec3 y = cross( z, x );\n\tvec2 v2 = vec2( dot( v, x ), dot( v, y ) );\n\tv2 = rotate_with_angle( v2, angle );\n\treturn pp + v2.x * x + v2.y * y;\n}\n\n// can't find the source shadertoy for those functions...\n#define KEY_SPACE 32.\n#define KEY_RIGHT 39.\nbool key_toggle( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.75 ) ).x > 0.); }\nbool key_state( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.25 ) ).x > 0.); }\n\nmat4 get_earth_camera( inout float tan_half_fovy\n\t\t\t\t\t   , inout float fade\n\t\t\t\t\t   , float time\n\t\t\t\t\t   , out LameTweaks lame_tweaks\n\t\t\t\t\t   , inout float exposure )\n{\n\tvec3 eye = vec3( 0, 0, 2.0 );\n\tvec3 center = vec3( 0, 0, 0 );\n\n\tfloat roll = 0.0;\n\n#define IS_NEXT_INDEX(nn) ( abs( camera_index - nn ) < 0.01 )\n\n#ifdef FORCE_CAMERA\n\tfloat camera_index = FORCE_CAMERA;\n#else\n\tfloat camera_index = mod( floor( time / CAMERA_PERIOD ), CAMERA_NUM );\n#endif\n\tfade = pow2( saturate( tri( time, CAMERA_PERIOD ) ) );\n\n\tfloat camera_time = mod( time, CAMERA_PERIOD );\n\n\tfloat earth_rot_time_scale = 1.0;\n\tfloat earth_rot_time_offset = 0.0;\n\tfloat cloud_flow_time_scale = 1.0;\n\tfloat cloud_flow_time_offset = 0.0;\n\tlame_tweaks.specular_hack = 0.25;\n\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.5 );\n\n#ifdef CAMERA_TIME_RESET\n\ttime = camera_time;\n#endif\n\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, 0.0 );\n\n\tfloat x = camera_time * ( 1.0 / CAMERA_PERIOD );\n\tfloat xs6 = smoothstep_unchecked_6( x );\n\n\tif ( IS_NEXT_INDEX( CAMERA_ORBITING_CLOSE ) )\n\t{\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 180.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 20.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\t// time = 0; // eye should be on y=0,1,0 at time=0\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tvec3 up = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.98, up );\n\t\ttan_half_fovy = 0.09;\n\t\troll = time * 0.02;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 2000.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 1.5;\n\t\tmm_offset = vec2( 0.0, 0.0 );\n//\t\texposure = 0.45;\n\t\tlame_tweaks.cloud_hack.z = 0.35;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_ORBITING_FAR ) )\n\t{\n\t\tvec3 up = vec3( 0, 0,  1 );\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 25.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 10.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tup = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.965, up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = 0.3; // 0.3 for sphere\n//\t\troll = time*0.02;\n\t\troll = PI * 3.0 / 4.0;\n\t\tearth_rot_time_scale = 12.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 12.0;\n\t\tcloud_flow_time_offset = -10.0;\n\t\tmouse_ctrl = 0.6;\n\t\tmm_offset = vec2( 0.37, -0.08 );\n\t\texposure = 0.75;\n\t\tlame_tweaks.specular_hack = 0.07;\n\t\tlame_tweaks.cloud_hack = vec3( 4.2, 0.12, 0.27 ); // too much decal\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_BLUE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.382552146, 3.343272924, -0.757502257 ) * cam_scale;\n\t\tvec3 n = normalize( eye );\n\t\tvec3 up = sun_direction;\n\t\teye += n * 500.0 * xs6;\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * mix( 1.0, 0.96, xs6 ), up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = mix( 0.2, 0.09, xs6 );\n\t\troll = PI * mix( 0.25, -0.02, 1.0 - exp( -x * 2.0 ) );\n\t\tearth_rot_time_scale = 198.0;\n\t\tearth_rot_time_offset = 39.9;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tlame_tweaks.specular_hack = 0.25;\n\t\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.3 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_CLOUDS ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( -5.704154491, -0.459553778, -3.58820796 ) * cam_scale;\n\t\tcenter = vec3( -5.828063488, -0.007100194, -2.705070018 ) * cam_scale;\n\t\tcenter = eye + ( center - eye ) * mix( 0.8, 0.8, x );\n\t\teye = rotate_around( center, normalize( center ), eye, x * PI * 0.12 );\n\t\ttan_half_fovy = 0.05;\n\t\troll = mix( -0.2, -0.3, x ) * PI;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = -1600.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = -900.0;\n\t\tmouse_ctrl = 2.5;\n\t\texposure = 0.8;\n\t\tlame_tweaks.cloud_hack = vec3( 4.0, 0.12, 0.6 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_FAR ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat rt = 0.25;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * rt );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * rt );\n\t\ttan_half_fovy = 0.62;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 20.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 100.0;\n\t\tmouse_ctrl = 0.26;\n\t\tmm_offset = vec2( -0.5, -0.29 );\n\t\tlame_tweaks.specular_hack = 150.0;\n\t\tlame_tweaks.cloud_hack = vec3( 4.5, 0.15, 1.0 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_CLOSE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat r = 0.0603;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * r );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * r );\n\t\ttan_half_fovy = 0.3;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 22.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 0.9;\n\t\tmm_offset = vec2( -0.84, -0.28 );\n\t\tlame_tweaks.specular_hack = 100.0;\n\t\tlame_tweaks.cloud_hack = vec3( 3.4, 0.15, 0.9 );\n\t\texposure = 0.5;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_SUNRISE ) )\n\t{\n\t\tfloat at1 = exp( -x * 10.0 ); // anim time 1: approach\n\t\tfloat at2 = smoothstep_unchecked_6( remap( x, 0.3, 1.0 ) ); // anim time 2: ascension\n\t\tfloat r = earth_radius + cloud_start * 5.0 + atm_max * at2 * 200.0;\n\t\tvec3 up = vec3( 0, 0, 0 ); up.zx = unit_vector2( -PI * 0.56 );\n\t\tvec3 sun_pos = sun_dist * sun_direction;\n\t\tvec3 tangent_point = get_tangent_point( sun_pos, earth_center, r, up );\n\t\tcenter = tangent_point;\n\t\tvec3 rail = normalize( sun_pos - tangent_point );\n\t\tfloat d0 = earth_radius * 0.08; // distance to tangent point is d\n\t\tfloat d1 = earth_radius * 0.03;\n\t\teye = tangent_point + rail * mix( -d0, d1, x ); //\n\t\tvec3 end_center = get_tangent_point( eye, earth_center, earth_radius * 0.984, sun_direction );\n\t\tcenter = eye + rail;\n\t\tcenter = mix( center, end_center, at2 );\n\t\ttan_half_fovy = 0.15;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 90.0;\n\t\texposure = mix( 0.4, 0.75, xs6 );\n\t\tlame_tweaks.cloud_hack = vec3( 3.0, 0.12, 0.65 );\n\t\tmm_offset = vec2( 0.0, -0.1 * xs6 );\n\t\tmouse_ctrl = 1.2;\n\t\troll = PI * 0.0;\n\t\tlame_tweaks.specular_hack = 0.1;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_MOON_WIP ) )\n\t{\n\t\tfloat d = earth_radius * 0.5; // distance to tangent point is d\n\t\tfloat r = earth_radius + 4.0 * atm_max;\n\t\tvec3 moon_pos = moon_dist * moon_direction * 1.0;\n\t\tvec3 tangent_point = get_tangent_point( moon_pos, earth_center, r, vec3( 0, 1, 0 ) );\n\t\tcenter = tangent_point;\n\t\teye = tangent_point + d * normalize( tangent_point - moon_pos ); //\n\t\ttan_half_fovy = 0.045;\n\t\tearth_rot_time_scale = 30.0;\n\t\tearth_rot_time_offset = 1700.0;\n\t\tcloud_flow_time_scale = 3.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\troll = -PI * 0.5;\n\t\tlame_tweaks.cloud_hack = vec3( 2.6, 0.12, 0.22 );\n\t\tmouse_ctrl = 0.5;\n\t\tmm_offset = vec2( -0.07, 0.018 );\n\t}\n\n\tvec3 up = normalize( eye ); // horizontal views\n\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n//\tcamera_time = GLOBALTIME; // comment to always show the same time slice\n\tlame_tweaks.cloud_flow_time = ( cloud_flow_time_offset + camera_time ) * cloud_flow_time_scale;\n\tlame_tweaks.earth_rot_time = ( earth_rot_time_offset + camera_time ) * earth_rot_time_scale;\n\n\treturn lookat( eye, center, up ) * z_rotation( roll ) * yup_spherical_offset( mm.y, mm.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 pixel = fragCoord.xy;\n\tfragColor = vec4( 0., 0., 0., 1 );\n\n#ifdef HD_BLACK_BANDS\n\tfloat aspect = ( 16.0 / 9.0 ); // the ratio we want\n\tif ( iResolution.x < aspect * iResolution.y )\n\t{\n\t\tresolution.y = resolution.x * ( 1.0 / aspect );\n\t\tpixel.y -= ( iResolution.y - resolution.y ) * 0.5;\n\t\tif ( abs( pixel.y * 2.0 - resolution.y ) > resolution.y ) return;\n\t}\n\telse\n\t{\n\t\tresolution.x = resolution.y * aspect;\n\t\tpixel.x -= ( iResolution.x - resolution.x ) * 0.5;\n\t\tif ( abs( pixel.x * 2.0 - resolution.x ) > resolution.x  ) return;\n\t}\n#else\n\tfloat aspect = ( resolution.x / resolution.y );\n#endif\n\tvec2 uv = pixel / resolution.xy;\n\n\tfloat fade = 1.0;\n\tfloat tan_half_fovy = 0.06; // so we can see then sun\n\tfloat znear = 0.1;\n\tLameTweaks lame_tweaks;\n\tfloat exposure = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tmat4 camera;\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\tcamera[3].xyz *= 1e+3 * atm_scale;\n#else\n\tfloat fast_forward = ( key_state( KEY_RIGHT ) ? 5.0 : 1.0 );\n\tmat4 camera = get_earth_camera( tan_half_fovy, fade, GLOBALTIME * fast_forward, lame_tweaks, exposure );\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0 ) ).xyz;\n\n#ifdef SUPER_SAMPLE_HORIZON\n\t// do SS on edge pixels... still expensive\n\tfloat ss = vec3( 1 - exp( -abs( length( project_on_line1( earth_center, view_ray.o, view_ray.d ) - earth_center ) - earth_radius ) * 0.1 ) );\n\tfragColor = vec4( ss, ss, ss, 1.0 );\n\tif ( ss < 0.7 )\n\t{\n\t\tvec2 pmin = ( pixel + vec2( 0.0, 0.0 ) ) / resolution.xy;\n\t\tvec2 pmax = ( pixel + vec2( 1.0, 1.0 ) ) / resolution.xy;\n\n\t\tfragColor.rgb = vec3( 0 );\n\t\tfor ( int i = 0; i < 2; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 2; j++ )\n\t\t\t{\n\t\t\t\tvec2 uv2 = pmin + ( pmax - pmin )\n\t\t\t\t\t* vec2(\n\t\t\t\t\t0.5 + float( i ) / 2.0,\n\t\t\t\t\t0.5 + float( j ) / 2.0 );\n\t\t\t\tRay subray = get_view_ray( ( uv2 - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\t\t\t\tsubray.o = camera[3].xyz; // make sure all rays have same origin! we don't really care about havnig a znear here\n\t\t\t\tsubray.d = ( camera * vec4( subray.d, 0 ) ).xyz;\n\t\t\t\tfragColor.rgb += earthShader( subray, camera, lame_tweaks, exposure );\n\t\t\t}\n\t\t}\n\t\tfragColor.rgb /= 4.0;\n\t\treturn;\n\t}\n#endif\n\n\tfragColor.rgb = earthShader( view_ray, camera, lame_tweaks, exposure ) * fade;\n\treturn;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf3yzS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Tiny Plane abossard 958",
    "description": "Earth-like planet with exaggerated features. A fbm value-noise implicit surface with shallow + deep water wave simulation, clouds, trees, mountains, desert, beaches, snow, polar caps, denoising, bloom, atmospheric scattering, and star field.\n",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "waves",
     "clouds",
     "planet",
     "implicitsurface"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Bloom shader\n// by Morgan McGuire, @CasualEffects, http://casual-effects.com\n\nfloat square(int x) { return float(x * x); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const int   blurRadius    = 5;\n    const float blurVariance  = 0.1 * float(blurRadius * blurRadius);    \n    vec2        invResolution = 1.0 / iResolution.xy;\n    \n    // Center tap\n    vec4 sum = vec4(texture(iChannel0, fragCoord.xy * invResolution).rgb * 13.0, 13.0);\n    \n    for (int dx = -blurRadius; dx < blurRadius; dx += 2) {\n        for (int dy = -blurRadius; dy < blurRadius; dy += 2) {\n            // Bilinear taps at pixel corners\n\t        vec3 src = texture(iChannel0, (fragCoord.xy + vec2(dx, dy) + 0.5) * invResolution).rgb;\n            float weight = exp2(-(square(dx) + square(dy)) / blurVariance);\n            sum += vec4(src, 1.0) * weight;\n        }\n    }\n    \n\tfragColor.xyz = pow(sum.rgb / sum.a, Color3(0.65));    \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsX3zn",
       "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Planet implicit surface ray tracer\n// by Morgan McGuire, @CasualEffects, http://casual-effects.com\n//\n// Prototype for a new Graphics Codex programming project.\n//\n// The key functions are the scene() distance estimator in Buf A and\n// the renderClouds() shading in Buf B. Everything else is relatively \n// standard ray marching infrastructure.\n\nmat3 planetRotation;\n\nconst Material ROCK = Material(Color3(0.50, 0.35, 0.15), 0.0, 0.0);\nconst Material TREE = Material(Color3(0.05, 1.15, 0.10), 0.2, 0.1);\nconst Material SAND = Material(Color3(1.00, 1.00, 0.85), 0.0, 0.0);\nconst Material ICE  = Material(Color3(0.85, 1.00, 1.20), 0.2, 0.6);\n\n/**\n Conservative distance estimator for the entire scene. Returns true if\n the surface is closer than distance. Always updates distance and material.\n The material code compiles out when called from a context that ignores it.\n*/\nbool scene(Point3 X, inout float distance, inout Material material, const bool shadow) { \n    Material planetMaterial;\n    \n    // Move to the planet's reference frame (ideally, we'd just trace in the \n    // planet's reference frame and avoid these operations per distance\n    // function evaluation, but this makes it easy to integrate with a\n    // standard framework)\n    X = planetRotation * (X - planetCenter);\n    Point3 surfaceLocation = normalize(X);\n    \n    // Compute t = distance estimator to the planet surface using a spherical height field, \n    // in which elevation = radial distance\n    //\n\t// Estimate *conservative* distance as always less than that to the bounding sphere\n    // (i.e., push down). Work on range [0, 1], and then scale by planet radius at the end\n    \n\tfloat mountain = clamp(1.0 - fbm6(surfaceLocation * 4.0) + (max(abs(surfaceLocation.y) - 0.6, 0.0)) * 0.03, 0.0, 1.0);\n    mountain = pow3(mountain) * 0.25 + 0.8;\n    \n    const float water = 0.85;\n    float elevation = mountain;    \n    \n    Vector3 normal = normalize(cross(dFdx(surfaceLocation * mountain), dFdy(surfaceLocation * mountain)));\n    \n    // Don't pay for fine details in the shadow tracing pass\n\tif (! shadow) {\n        if (elevation < water) {\n            float relativeWaterDepth = min(1.0, (water - mountain) * 30.0);\n            const float waveMagnitude = 0.0014;\n            const float waveLength = 0.01;\n\n            // Create waves. Shallow-water waves conform to coasts. Deep-water waves follow global wind patterns.\n            const Color3 shallowWaterColor = Color3(0.4, 1.0, 1.9);\n            // How much the waves conform to beaches\n            const float shallowWaveRefraction = 4.0;        \n            float shallowWavePhase = (surfaceLocation.y - mountain * shallowWaveRefraction) * (1.0 / waveLength);\n\n            const Color3 deepWaterColor = Color3(0, 0.1, 0.7);\n            float deepWavePhase    = (atan(surfaceLocation.z, surfaceLocation.x) + noise(surfaceLocation * 15.0) * 0.075) * (1.5 / waveLength);\n\n            // This is like a lerp, but it gives a large middle region in which both wave types are active at nearly full magnitude\n            float wave =  (cos(shallowWavePhase + time * 1.5) * sqrt(1.0 - relativeWaterDepth) + \n                           cos(deepWavePhase + time * 2.0) * 2.5 * (1.0 - abs(surfaceLocation.y)) * square(relativeWaterDepth)) *\n                waveMagnitude;\n\n            elevation = water + wave;\n\n            // Set material, making deep water darker\n            planetMaterial = Material(mix(shallowWaterColor, deepWaterColor, pow(relativeWaterDepth, 0.4)), 0.5 * relativeWaterDepth, 0.7);\n\n            // Lighten polar water color\n            planetMaterial.color = mix(planetMaterial.color, Color3(0.7, 1.0, 1.2), square(clamp((abs(surfaceLocation.y) - 0.65) * 3.0, 0.0, 1.0)));            \n        } else {\n            float materialNoise = noise(surfaceLocation * 200.0);\n\n            float slope = clamp(2.0 * (1.0 - dot(normal, surfaceLocation)), 0.0, 1.0);\n\n            bool iceCap     = abs(surfaceLocation.y) + materialNoise * 0.2 > 0.98; \n            bool rock       = (elevation + materialNoise * 0.1 > 0.94) || (slope > 0.3);\n            bool mountainTop = (elevation + materialNoise * 0.05 - slope * 0.05) > (planetMaxRadius * 0.92);\n\n            // Beach\n            bool sand        = (elevation < water + 0.006) && (noise(surfaceLocation * 8.0) > 0.3);\n\n            // Equatorial desert\n            sand = sand || (elevation < 0.89) && \n                (noise(surfaceLocation * 1.5) * 0.15 + noise(surfaceLocation * 73.0) * 0.25 > abs(surfaceLocation.y));\n\n            if (rock) {\n                // Rock\n                planetMaterial = ROCK;\n            } else {\n                // Trees\n                planetMaterial = TREE;\n            }\n\n            if (iceCap || mountainTop) {\n                // Ice (allow to slightly exceed physical conservation in the blue channel\n                // to simulate subsurface effects)\n                planetMaterial = ICE;\n            } else if (! rock && sand) {\n                planetMaterial = SAND;\n            } else if (! rock && (iResolution.x > 420.0)) {\n                // High frequency bumps for trees when in medium resolution\n                elevation += noise(surfaceLocation * 150.0) * 0.02;\n            }\n\n            // Add high-frequency material detail\n            if (! sand && ! iceCap) {\n                planetMaterial.color *= mix(noise(surfaceLocation * 256.0), 1.0, 0.4);\n            }\n\n        }\n    }\n        \n    elevation *= planetMaxRadius;\n    \n    float sampleElevation = length(X);\n    float t = sampleElevation - elevation;\n    \n    // Be a little more conservative because a radial heightfield is not a great\n    // distance estimator.\n    t *= 0.8;\n        \n    // Compute output variables\n    bool closer = (t < distance);       \n    distance = closer ? t : distance;    \n    if (closer) { material = planetMaterial; }\n    return closer;    \n}\n\n\n// Version that ignores materials\nbool scene(Point3 X, inout float distance) {\n    Material ignoreMaterial;\n    return scene(X, distance, ignoreMaterial, true); \n}\n\nfloat distanceEstimator(Point3 X) {\n    float d = inf;\n    Material ignoreMaterial;\n    scene(X, d, ignoreMaterial, false);\n    return d;\n}\n\n// Weird structure needed because WebGL does not support BREAK in a FOR loop\nbool intersectSceneLoop(Ray R, float minDist, float maxDist, inout Surfel surfel) {\n    const int maxIterations = 75;\n    \n    // Making this too large causes bad results because we use\n    // screen-space derivatives for normal estimation.\n    \n    const float closeEnough = 0.0011;\n    const float minStep = closeEnough;\n    float closest = inf;\n    float tForClosest = 0.0;\n    float t = minDist;\n    \n    for (int i = 0; i < maxIterations; ++i) {\n        surfel.position = R.direction * t + R.origin;\n\n        float dt = inf;\n        scene(surfel.position, dt);\n        if (dt < closest) {            \n\t        closest = dt;\n            tForClosest = t;            \n        }\n        \n        t += max(dt, minStep);\n        if (dt < closeEnough) {\n            return true;\n        } else if (t > maxDist) {\n            return false;\n        }\n    }    \n\n    // \"Screen space\" optimization from Mercury for shading a reasonable\n    // point in the event of failure due to iteration count\n    if (closest < closeEnough * 5.0) {\n        surfel.position = R.direction * tForClosest + R.origin;\n        return true;\n    }\n    \n    return false;\n}\n\n\nbool intersectScene(Ray R, float minDist, float maxDist, inout Surfel surfel) {\n    if (intersectSceneLoop(R, minDist, maxDist, surfel)) {\n        const float eps = 0.0001;\n        \n        float d = inf;\n        scene(surfel.position, d, surfel.material, false);\n        surfel.normal =\n            normalize(Vector3(distanceEstimator(surfel.position + Vector3(eps, 0, 0)), \n                              distanceEstimator(surfel.position + Vector3(0, eps, 0)), \n                              distanceEstimator(surfel.position + Vector3(0, 0, eps))) - \n                              d);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nbool shadowed(Ray R, float minDist, float maxDist) {\n    const int maxIterations = 30;    \n    const float closeEnough = 0.0011 * 4.0;\n    const float minStep = closeEnough;\n    float t = 0.0;\n    \n    for (int i = 0; i < maxIterations; ++i) {\n        float dt = inf;\n        scene(R.direction * t + R.origin, dt);        \n        t += max(dt, minStep);\n        if (dt < closeEnough) {\n            return true;\n        } else if (t > maxDist) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n\n\nvoid computeReflectivities(Material material, out Color3 p_L, out Color3 p_G, out float glossyExponent) {\n\tp_L = mix(material.color, Color3(0.0), material.metal);\n\tp_G = mix(Color3(0.04), material.color, material.metal);\n\tglossyExponent = exp2(material.smoothness * 15.0);\n}\n\n\nRadiance3 shade(Surfel surfel, Vector3 w_i, Vector3 w_o, Biradiance3 B_i) {\n\tVector3 n   = surfel.normal;\n    \n    float cos_i = dot(n, w_i);\n    if (cos_i < 0.0) {\n        // Backface, don't bother shading or shadow casting\n        return Radiance3(0.0);\n    }\n    \n    // Cast a shadow ray\n    Ray shadowRay = Ray(surfel.position + (surfel.normal + w_o) * 0.003, w_i);\n    float shadowDist, ignore;\n    // Find the outer bounding sphere on the atmosphere and trace shadows up to it\n    intersectSphere(planetCenter, planetMaxRadius, shadowRay, shadowDist, ignore);\n    if (shadowed(shadowRay, 0.0, shadowDist)) {\n        return Radiance3(0.0);\n    }\n    \n\tColor3 p_L, p_G;\n\tfloat glossyExponent;\n\tcomputeReflectivities(surfel.material, p_L, p_G, glossyExponent);\n\n\t// Compute the light contribution from the directional source\n\tVector3 w_h = normalize(w_i + w_o);\n\treturn cos_i * B_i * \n\t\t// Lambertian\n\t\t(p_L * (1.0 / pi) + \n\n\t\t// Glossy\n        pow(max(0.0, dot(n, w_h)), glossyExponent) * p_G * (glossyExponent + 8.0) / (14.0 * pi));\n}\n\n\n/** Returns true if the world-space ray hits the planet */\nbool renderPlanet(Ray eyeRay, float minDistanceToPlanet, float maxDistanceToPlanet, inout Radiance3 L_o, inout Point3 hitPoint) {    \n    Surfel surfel;\n    \n    if (intersectScene(eyeRay, minDistanceToPlanet, maxDistanceToPlanet, surfel)) {\n        // Render the planet\n        Radiance3 L_directOut = shade(surfel, w_i, -eyeRay.direction, B_i);\n\n        // Clouds vary fairly slowly in elevation, so we can just measure at the\n        // surface as an estimate of the density above the surface\n        float cloudShadow = pow4(1.0 - clamp(cloudDensity(surfel.position, time), 0.0, 1.0));\n        \n        // \"Ambient\"\n        Irradiance3 E_indirectIn = max(Irradiance3(0), Irradiance3(0.4) - 0.4 * Irradiance3(surfel.normal.yxx)); \n        Radiance3 L_indirectOut = \n            mix(E_indirectIn * surfel.material.color,\n                mix(Color3(1.0), surfel.material.color, surfel.material.metal) * texture(iChannel0, reflect(w_i, surfel.normal)).rgb * 2.7, surfel.material.smoothness) * (1.0 / pi);\n        \n        hitPoint = surfel.position;\n        L_o = (L_directOut + L_indirectOut) * cloudShadow;\n\n        if (debugMaterials) {\n            L_o = surfel.material.color;\n        }\n            \n        return true;\n    } else {\n        // Missed the bounding sphere or final ray-march\n        return false;\n    }    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Rotate over time\n\tfloat yaw   = -((iMouse.x / iResolution.x) * 2.5 - 1.25) + (autoRotate ? -time * 0.015 : 0.0);\n\tfloat pitch = ((iMouse.y > 0.0 ? iMouse.y : iResolution.y * 0.3) / iResolution.y) * 2.5 - 1.25;\n \tplanetRotation = \n    \tmat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n    \tmat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n\n    \n    Vector2 invResolution = 1.0 / iResolution.xy;\n\t\n\t// Outgoing light\n\tRadiance3 L_o;\n\t\n\tSurfel surfel;\t\n\t\n\tRay eyeRay = Ray(Point3(0.0, 0.0, 5.0), normalize(Vector3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / (-2.0 * tan(verticalFieldOfView / 2.0)))));\n\t    \n    Point3 hitPoint;    \n    float minDistanceToPlanet, maxDistanceToPlanet;\n        \n    bool hitBounds = (showClouds || showPlanet) && intersectSphere(planetCenter, planetMaxRadius, eyeRay, minDistanceToPlanet, maxDistanceToPlanet);\n\n    Color3 shadowedAtmosphere = shadowedAtmosphereColor(fragCoord, iResolution, 0.5);\n    \n    if (hitBounds && renderPlanet(eyeRay, minDistanceToPlanet, maxDistanceToPlanet, L_o, hitPoint)) {\n        // Tint planet with atmospheric scattering\n        L_o = mix(L_o, shadowedAtmosphere, min(0.8, square(1.0 - (hitPoint.z - planetCenter.z) * (1.0 / planetMaxRadius))));\n        // Update distance\n        maxDistanceToPlanet = min(maxDistanceToPlanet, dot(eyeRay.direction, hitPoint - eyeRay.origin));\n    } else if (showBackground) {\n        // Background starfield\n        float galaxyClump = (pow(noise(fragCoord.xy * (30.0 * invResolution.x)), 3.0) * 0.5 +\n            pow(noise(100.0 + fragCoord.xy * (15.0 * invResolution.x)), 5.0)) / 1.5;\n        L_o = Color3(galaxyClump * pow(hash(fragCoord.xy), 1500.0) * 80.0);\n        \n        // Color stars\n        L_o.r *= sqrt(noise(fragCoord.xy) * 1.2);\n        L_o.g *= sqrt(noise(fragCoord.xy * 4.0));\n        \n        // Twinkle\n        L_o *= noise(time * 0.5 + fragCoord.yx * 10.0);\n        vec2 delta = (fragCoord.xy - iResolution.xy * 0.5) * invResolution.y * 1.1;\n        float atmosphereRadialAttenuation = min(1.0, 0.06 * pow8(max(0.0, 1.0 - (length(delta) - 0.9) / 0.9)));\n        \n        // Gradient around planet\n        float radialNoise = mix(1.0, noise(normalize(delta) * 40.0 + iTime * 0.5), 0.14);\n        L_o += radialNoise * atmosphereRadialAttenuation * shadowedAtmosphere;\n    }   \n        \n\tfragColor.xyz = L_o;\n    fragColor.a   = maxDistanceToPlanet;\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Cloud ray-march shader\n// by Morgan McGuire, @CasualEffects, http://casual-effects.com\n\n\n/** Computes the contribution of the clouds on [minDist, maxDist] along eyeRay towards net radiance \n    and composites it over background */\nRadiance4 renderClouds(Ray eyeRay, float minDist, float maxDist, Color3 shadowedAtmosphere) {    \n    const int    maxSteps = 80;\n    const float  stepSize = 0.012;\n    const Color3 cloudColor = Color3(0.95);\n    const Radiance3 ambient = Color3(0.9, 1.0, 1.0);\n\n    // The planet should shadow clouds on the \"bottom\"...but apply wrap shading to this term and add ambient\n    float planetShadow = clamp(0.4 + dot(w_i, normalize(eyeRay.origin + eyeRay.direction * minDist)), 0.25, 1.0);\n\n    Radiance4 result = Radiance4(0.0);\n    \n    // March towards the eye, since we wish to accumulate shading.\n    float t = maxDist;\n    for (int i = 0; i < maxSteps; ++i) {\n        if (t > minDist) {\n            Point3 X = ((eyeRay.direction * t + eyeRay.origin) - planetCenter) * (1.0 / planetMaxRadius);\n            // Sample the clouds at X\n            float density = cloudDensity(X, time);\n            \n            if (density > 0.0) {\n\n                // Shade cloud\n                // Use a directional derivative https://iquilezles.org/articles/derivative\n                // for efficiency in computing a directional term             \n                const float eps = stepSize;\n                float wrapShading = clamp(-(cloudDensity(X + w_i * eps, time) - density) * (1.0 / eps), -1.0, 1.0) * 0.5 + 0.5;\n\n                // Darken the portion of the cloud facing towards the planet\n                float AO = pow8((dot(X, X) - 0.5) * 2.0);\n                Radiance3 L_o = cloudColor * (B_i * planetShadow * wrapShading * mix(1.0, AO, 0.5) + ambient * AO);\n                \n                // Atmosphere tinting\n\t\t        L_o = mix(L_o, shadowedAtmosphere, min(0.5, square(max(0.0, 1.0 - X.z))));\n\n                // Fade in at the elevation edges of the cloud layer (do this *after* using density for derivative)\n                density *= square(1.0 - abs(2.0 * length(X - planetCenter) - (cloudMinRadius + planetMaxRadius)) * (1.0 / (planetMaxRadius - cloudMinRadius)));\n                \n                // Composite over result as premultiplied radiance\n                result = mix(result, Radiance4(L_o, 1.0), density);\n                \n                // Step more slowly through empty space\n\t            t += stepSize * 2.0;\n            } \n            \n            t -= stepSize * 3.0;\n        } else {\n            return result;\n        }\n    }\n    \n    return result;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    \n    // Run at 1/3 resolution\n    fragCoord.xy = (fragCoord.xy - 0.5) * 3.0 + 0.5;\n    if ((fragCoord.x > iResolution.x) || (fragCoord.y > iResolution.y)) { return; }\n    \n    Ray eyeRay = Ray(Point3(0.0, 0.0, 5.0), normalize(Vector3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / (-2.0 * tan(verticalFieldOfView / 2.0)))));\n\n    float minDistanceToPlanet, maxDistanceToPlanet;\n    if (showClouds && intersectSphere(planetCenter, planetMaxRadius, eyeRay, minDistanceToPlanet, maxDistanceToPlanet)) {\n        // This ray hits the cloud layer, so ray march the clouds\n        \n        // Find the hit point on the planet or back of cloud sphere and override\n        // the analytic max distance with it.\n    \tmaxDistanceToPlanet = texture(iChannel0, fragCoord.xy / iResolution.xy).a;\n        \n        Color3 shadowedAtmosphere = 1.1 * shadowedAtmosphereColor(fragCoord, iResolution, 0.08);\n        fragColor = renderClouds(eyeRay, minDistanceToPlanet, maxDistanceToPlanet, shadowedAtmosphere);   \n    }\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Composite and temporal blur shader\n// by Morgan McGuire, @CasualEffects, http://casual-effects.com\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mouseDeltaX = iMouse.x - texture(iChannel2, vec2(0, 0)).a; \n    \n    // Increase blur constants when small because the screen-space derivatives\n    // will be unstable at that scale. Both are on [0, 1]\n    float hysteresis    = (abs(mouseDeltaX) > 1.0) ? 0.05 : \n        (iResolution.x > 800.0) ? 0.8 : 0.9;\n    float spatialBlur   = (iResolution.x > 900.0) ? 0.70 : 0.90;\n\n    vec2 invResolution = 1.0 / iResolution.xy;\n    vec3 planet = texture(iChannel0, (fragCoord.xy + spatialBlur * 0.5) * invResolution).rgb;\n    // Upsample clouds from 1/2 resolution\n    vec4 clouds = texture(iChannel1, ((fragCoord.xy - 0.5) / 3.0 + 0.5) * invResolution);\n    vec3 dst    = texture(iChannel2, fragCoord.xy * invResolution).rgb;\n    \n\t// Hide clouds\n   \t// clouds = vec4(0.0); hysteresis = 0.0;\n    \n    if (! showPlanet) { planet *= 0.0; }\n    \n\tfragColor.rgb = mix(planet * (1.0 - clouds.a) + clouds.rgb, dst, hysteresis);\n\n    // Save the old mouse position. Most users only rotate horizontally, so save\n    // a texture fetch on read by not storing the y component.\n    fragColor.a   = iMouse.x;   \n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const bool autoRotate = true;\n\nconst bool showBackground = true;\nconst bool showPlanet = true;\nconst bool showClouds = true;\n\nconst bool debugMaterials = false;\n    \n#define time (iTime)\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// Morgan's standard Shadertoy helpers\n#define Vector2      vec2\n#define Point3       vec3\n#define Vector3      vec3\n#define Color3       vec3\n#define Radiance3    vec3\n#define Radiance4    vec4\n#define Irradiance3  vec3\n#define Power3       vec3\n#define Biradiance3  vec3\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float inf         = 1.0 / 1e-10;\n\nfloat square(float x) { return x * x; }\nfloat pow3(float x) { return x * square(x); }\nfloat pow4(float x) { return square(square(x)); }\nfloat pow8(float x) { return square(pow4(x)); }\nfloat pow5(float x) { return x * square(square(x)); }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nstruct Ray { Point3 origin; Vector3 direction; };\t\nstruct Material { Color3 color; float metal; float smoothness; };\nstruct Surfel { Point3 position; Vector3 normal; Material material; };\nstruct Sphere { Point3 center; float radius; Material material; };\n   \n/** Analytic ray-sphere intersection. */\nbool intersectSphere(Point3 C, float r, Ray R, inout float nearDistance, inout float farDistance) { Point3 P = R.origin; Vector3 w = R.direction; Vector3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }\n\n///////////////////////////////////////////////////////////////////////////////////\n// The following are from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nconst float       verticalFieldOfView = 25.0 * degrees;\n\n// Directional light source\nconst Vector3     w_i             = Vector3(1.0, 1.3, 0.6) / 1.7464;\nconst Biradiance3 B_i             = Biradiance3(2.9);\n\nconst Point3      planetCenter    = Point3(0);\n\n// Including clouds\nconst float       planetMaxRadius = 1.0;\n\nconst float       cloudMinRadius  = 0.85;\n\nconst Radiance3   atmosphereColor = Color3(0.3, 0.6, 1.0) * 1.6;\n\n\n// This can g1 negative in order to make derivatives smooth. Always\n// clamp before using as a density. Must be kept in sync with Buf A code.\nfloat cloudDensity(Point3 X, float t) {\n    Point3 p = X * vec3(1.5, 2.5, 2.0);\n\treturn fbm5(p + 1.5 * fbm3(p - t * 0.047) - t * vec3(0.03, 0.01, 0.01)) - 0.42;\n}\n\nColor3 shadowedAtmosphereColor(vec2 fragCoord, vec3 iResolution, float minVal) {\n    vec2 rel = 0.65 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    const float maxVal = 1.0;\n    \n    float a = min(1.0,\n                  pow(max(0.0, 1.0 - dot(rel, rel) * 6.5), 2.4) + \n                  max(abs(rel.x - rel.y) - 0.35, 0.0) * 12.0 +                   \n\t              max(0.0, 0.2 + dot(rel, vec2(2.75))) + \n                  0.0\n                 );\n    \n    float planetShadow = mix(minVal, maxVal, a);\n    \n    return atmosphereColor * planetShadow;\n\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ccyzS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Global Win abossard 974",
    "description": "Generates pressure systems (click to show) and wind flow patterns from a land/ocean map.\n\nBased on [url=https://web.archive.org/web/20130619132254/http://jc.tech-galaxy.com/bricka/climate_cookbook.html]The Climate Cookbook[/url] and some simple modelling.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "simulation",
     "earth",
     "map",
     "flow",
     "vector",
     "model",
     "atmosphere",
     "particle",
     "wind",
     "pressure",
     "circulation",
     "climate"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// comment out the following line for original style\n#define PAPER\n\n// uncomment the following line for Mollweide projection\n//#define ELLIPTICAL\n\n#ifdef PAPER\n#define  LOW_PRESSURE vec3(0.,0.5,1.)\n#define HIGH_PRESSURE vec3(1.,0.5,0.)\n#else\n#define  LOW_PRESSURE vec3(1.,0.5,0.)\n#define HIGH_PRESSURE vec3(0.,0.5,1.)\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float lat = 180. * fragCoord.y/iResolution.y - 90.;\n#ifdef ELLIPTICAL\n    fragCoord.x -= iResolution.x/2.;\n    fragCoord.x /= sqrt(1. - pow(lat/90., 2.));\n    if (abs(fragCoord.x/iResolution.x) > 0.5) return;\n    fragCoord.x += iResolution.x/2.;\n    fragCoord.x -= 0.05 * iTime * iResolution.x;\n    fragCoord.x -= iMouse.x;\n    fragCoord.x = mod(fragCoord.x, iResolution.x);\n#endif\n    vec2 p = fragCoord * MAPRES / iResolution.xy;\n    if (p.x < 1.) p.x = 1.;\n    vec2 uv = p / iResolution.xy;\n    float land = texture(iChannel0, uv).x;\n    fragColor = vec4(0,0,0,1);\n    if (0.25 < land && land < 0.75) fragColor.rgb = vec3(0.5);\n    float mbar = texture(iChannel1, uv + PASS3).x;\n    if (iMouse.z > 0.) {\n        vec3 r = LOW_PRESSURE;\n        r = mix(r, vec3(0), smoothstep(1000., 1012., floor(mbar)));\n        r = mix(r, HIGH_PRESSURE, smoothstep(1012., 1024., floor(mbar)));\n        fragColor.rgb += 0.5 * r;\n    } else {\n        vec2 v = texture(iChannel1, uv + PASS4).xy;\n        float flow = texture(iChannel2, fragCoord/iResolution.xy).z;\n        vec3 hue = vec3(1.,0.75,0.5);\n#ifndef PAPER\n        hue = .6 + .6 * cos(atan(v.y,v.x) + vec3(0,23,21));\n#endif\n        float alpha = clamp(length(v), 0., 1.) * flow;\n        fragColor.rgb = mix(fragColor.rgb, hue, alpha);\n    }\n#ifdef PAPER\n    fragColor.rgb = 0.9 - 0.8 * fragColor.rgb;\n    if (mod(fragCoord.x, floor(iResolution.x/36.)) < 1. ||\n        mod(fragCoord.y, floor(iResolution.y/18.)) < 1.)\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.,0.5,1.), 0.2);\n#endif\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define MAPRES vec2(144,72)\n\n#define PASS1 vec2(0.0,0.0)\n#define PASS2 vec2(0.0,0.5)\n#define PASS3 vec2(0.5,0.0)\n#define PASS4 vec2(0.5,0.5)\n\n#define N vec2( 0, 1)\n#define E vec2( 1, 0)\n#define S vec2( 0,-1)\n#define W vec2(-1, 0)\n\n#define PI 3.14159265359\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// 1-bit land/ocean map, 2.5 degree resolution\n// auto-generated by https://github.com/rkibria/img2shadertoy\nconst vec2 bitmap_size = vec2(160, 72);\nconst int[] palette = int[] ( 0x00000000, 0x00ffffff );\nconst int[] rle = int[] ( 0x0001ff91, 0x03ff9100, 0xf8000000, 0x0008ff8f, 0xfffc0000, 0xf80fffff, 0x010aff89, 0xfe000000, 0x39ffffff, 0xff88fc3c, 0x0000030a, 0xffffc000, 0xc0003fff, 0x0100ff88, 0x80050084, 0x0000ffbf, 0x00ff87fe, 0x07008607, 0x20000078, 0xf7ffffff, 0x0f00ff83, 0x20000086, 0x20060083, 0xffff8fff, 0x00873fff, 0x00844000, 0x00007004, 0x0089f437, 0x00cd0100, 0x00921800, 0x00920c00, 0x00921c00, 0x008a1c00, 0x00860800, 0x008a3800, 0x00861000, 0x00897800, 0x00870400, 0x0089f800, 0x86400201, 0x01f80100, 0x0f000088, 0xf80b0087, 0x80000003, 0x00000007, 0x871fc3c0, 0x07f80b00, 0x0f800000, 0xc0000000, 0x00871fff, 0x000ff80b, 0x001f8000, 0xffc00000, 0x0b00871f, 0x00001ff0, 0x00001fc0, 0x1fffe000, 0xf00b0087, 0xc000003f, 0x0000063f, 0x870fffe0, 0xfff00b00, 0x3fe00000, 0xc0000004, 0x00870fff, 0x00fff00b, 0x0c3fe000, 0xfe000000, 0x0b008703, 0x0000fffc, 0x000cffe0, 0x027c0000, 0xfe0a0087, 0xe00000ff, 0x000008ff, 0x00883000, 0x01fffe05, 0x8dffe000, 0xffff0500, 0xffe00003, 0xff0b008d, 0xe00003ff, 0x000000ff, 0x87060004, 0xffff0b00, 0xfff00000, 0x02000000, 0x008703c1, 0x0007ff0a, 0x01fff000, 0x31710000, 0xff090088, 0xf000000f, 0x800003ff, 0x09008971, 0x000007fe, 0x0007fff0, 0x00896140, 0x0001fe09, 0x0ffffdf0, 0x88410100, 0xfec00b00, 0xfff80000, 0x80000fff, 0x00870600, 0x0008200a, 0xfffffc00, 0x0200c009, 0x700b0088, 0xfe000000, 0xc007ffff, 0x87010f80, 0x001e0b00, 0xfffc0000, 0x80e01eff, 0x00860107, 0x081bc00b, 0xfffc0000, 0xc3e07e7f, 0x0b008703, 0x000101c0, 0x7ffffe00, 0x07e7f0ff, 0xe00c0087, 0x00000001, 0x7fbffffc, 0x017ff7f8, 0xf00b0086, 0x00000081, 0x8ffffffc, 0x87ffffff, 0x83fc0c00, 0xf0000000, 0xfff7ffff, 0x8601ffff, 0x7ffa0700, 0xf0000000, 0xff83e77f, 0xfe070087, 0x000001ff, 0x83c00fe0, 0x853000ff, 0xff800800, 0x000003ff, 0x83c00f00, 0x85c800ff, 0xffc00e00, 0x000003ff, 0xcffb00f0, 0x043fffff, 0x0d008401, 0x07ffffc0, 0x61f00000, 0xffffcf67, 0x00850fff, 0xffffc00e, 0x8000000f, 0xfff707d7, 0x023fffff, 0xc00d0084, 0x003fffff, 0xafff8000, 0xffffffc3, 0x0900857f, 0x3fffffc0, 0xff800002, 0xff83e7ff, 0xe0070085, 0x03ffffff, 0x85fec000, 0x840100ff, 0xfff00700, 0x0001ff7f, 0xff85f890, 0x0083c000, 0xfff80108, 0x00007e1f, 0xff842840, 0x01c07f0f, 0x07000000, 0x6e03fffe, 0x7c000000, 0x0eff84fc, 0x00000101, 0xffffffc0, 0x00700603, 0x84ee7c00, 0x1f7f0eff, 0xff800000, 0x384fffff, 0xf00380f8, 0x0cff85fe, 0x8700007f, 0x7fffffff, 0x0003f878, 0x0eff87e0, 0xffc00000, 0x1e5c7bff, 0x80003ff8, 0x84df007f, 0x0d0084ff, 0xfc07f63e, 0x0000007f, 0xfffff820, 0x00841fef, 0xfd03c00c, 0x00fffc01, 0x00400000, 0x00875ffe, 0xf0e91204, 0x0083ffff, 0x1fa00302, 0x80060087, 0xfffff3f8, 0x0083f000, 0x00880300, 0xfffff004, 0x00c603ff );\n\nconst int rle_len_bytes = rle.length() << 2;\n\nint get_rle_byte( in int byte_index )\n{\n        int long_val = rle[ byte_index >> 2 ];\n        return ( long_val >> ( ( byte_index & 0x03 ) << 3 ) ) & 0xff;\n}\n\nint get_uncompr_byte( in int byte_index )\n{\n        int rle_index = 0;\n        int cur_byte_index = 0;\n        while( rle_index < rle_len_bytes )\n        {\n                int cur_rle_byte = get_rle_byte( rle_index );\n                bool is_sequence = int( cur_rle_byte & 0x80 ) == 0;\n                int count = ( cur_rle_byte & 0x7f ) + 1;\n\n                if( byte_index >= cur_byte_index && byte_index < cur_byte_index + count )\n                {\n                        if( is_sequence )\n                        {\n                                return get_rle_byte( rle_index + 1 + ( byte_index - cur_byte_index ) );\n                        }\n                        else\n                        {\n                                return get_rle_byte( rle_index + 1 );\n                        }\n                }\n                else\n                {\n                        if( is_sequence )\n                        {\n                                rle_index += count + 1;\n                                cur_byte_index += count;\n                        }\n                        else\n                        {\n                                rle_index += 2;\n                                cur_byte_index += count;\n                        }\n                }\n        }\n\n        return 0;\n}\n\n\nint getPaletteIndexXY( in ivec2 fetch_pos )\n{\n        int palette_index = 0;\n        if( fetch_pos.x >= 0 && fetch_pos.y >= 0\n                && fetch_pos.x < int( bitmap_size.x ) && fetch_pos.y < int( bitmap_size.y ) )\n        {\n                int uncompr_byte_index = fetch_pos.y * ( int( bitmap_size.x ) >> 3 )\n                        + ( fetch_pos.x >> 3);\n                int uncompr_byte = get_uncompr_byte( uncompr_byte_index );\n\n                int bit_index = fetch_pos.x & 0x07;\n                palette_index = ( uncompr_byte >> bit_index ) & 1;\n        }\n        return palette_index;\n}\n\n\nint getPaletteIndex( in vec2 uv )\n{\n        int palette_index = 0;\n        ivec2 fetch_pos = ivec2( uv * bitmap_size );\n        palette_index = getPaletteIndexXY( fetch_pos );\n        return palette_index;\n}\n\nvec4 getColorFromPalette( in int palette_index )\n{\n        int int_color = palette[ palette_index ];\n        return vec4( float( int_color & 0xff ) / 255.0,\n                                float( ( int_color >> 8 ) & 0xff) / 255.0,\n                                float( ( int_color >> 16 ) & 0xff) / 255.0,\n                                0 );\n}\n\nvec4 getBitmapColor( in vec2 uv )\n{\n        return getColorFromPalette( getPaletteIndex( uv ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = fragCoord / bitmap_size;\n        fragColor = getBitmapColor( uv );\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// 2018 David A Roberts <https://davidar.io>\n\n// atmospheric pressure and circulation model\n\n#define buf(uv) texture(iChannel1, uv)\n\n#define SIGMA vec4(6,4,0,0)\nvec4 normpdf(float x) {\n\treturn 0.39894 * exp(-0.5 * x*x / (SIGMA*SIGMA)) / SIGMA;\n}\n\n// mean sea level pressure\nvec4 mslp(vec2 uv) {\n    float lat = 180. * (uv.y * iResolution.y / MAPRES.y) - 90.;\n    float land = texture(iChannel0, uv).x;\n    vec4 r;\n    if (land > 0.) { // land\n        r.x = 1012.5 - 6. * cos(lat*PI/45.); // annual mean\n        r.y = 15. * sin(lat*PI/90.); // January/July delta\n    } else { // ocean\n        r.x = 1014.5 - 20. * cos(lat*PI/30.);\n        r.y = 20. * sin(lat*PI/35.) * abs(lat)/90.;\n    }\n    return r;\n}\n\n// horizontally blurred MSLP\nvec4 pass1(vec2 uv) {\n    //if (iFrame > 10) return buf(uv + PASS1);\n    vec4 r = vec4(0);\n    for (float i = -20.; i <= 20.; i++)\n        r += mslp(uv + i*E/iResolution.xy) * normpdf(i);\n    return r;\n}\n\n// fully blurred MSLP\nvec4 pass2(vec2 uv) {\n    //if (iFrame > 10) return buf(uv + PASS2);\n    vec4 r = vec4(0);\n    for (float i = -20.; i <= 20.; i++)\n        r += buf(uv + i*N/iResolution.xy + PASS1) * normpdf(i);\n    return r;\n}\n\n// time-dependent MSLP\nvec4 pass3(vec2 uv) {\n    vec4 c = buf(uv + PASS2);\n    float t = mod(iTime, 12.); // simulated month of the year\n    float delta = c.y * (1. - 2. * smoothstep(1.5, 4.5, t) + 2. * smoothstep(7.5, 10.5, t));\n    return vec4(c.x + delta,0,0,0);\n}\n\n// wind vector field\nvec4 pass4(vec2 uv) {\n    vec2 p = uv * iResolution.xy;\n    float n = buf(mod(p + N, MAPRES)/iResolution.xy + PASS3).x;\n    float e = buf(mod(p + E, MAPRES)/iResolution.xy + PASS3).x;\n    float s = buf(mod(p + S, MAPRES)/iResolution.xy + PASS3).x;\n    float w = buf(mod(p + W, MAPRES)/iResolution.xy + PASS3).x;\n    vec2 grad = vec2(e - w, n - s) / 2.;\n    float lat = 180. * fract(uv.y * iResolution.y / MAPRES.y) - 90.;\n    vec2 coriolis = 15. * sin(lat*PI/180.) * vec2(-grad.y, grad.x);\n    vec2 v = coriolis - grad;\n    return vec4(v,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if (uv.x < 0.5) {\n        if (uv.y < 0.5) {\n    \t\tfragColor = pass1(uv - PASS1);\n        } else {\n    \t\tfragColor = pass2(uv - PASS2);\n        }\n    } else {\n        if (uv.y < 0.5) {\n    \t\tfragColor = pass3(uv - PASS3);\n        } else {\n    \t\tfragColor = pass4(uv - PASS4);\n        }\n    }\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// 2018 David A Roberts <https://davidar.io>\n\n// wind flow map\n\nvec2 getVelocity(vec2 uv) {\n    vec2 p = uv * MAPRES;\n    if (p.x < 1.) p.x = 1.;\n    vec2 v = texture(iChannel1, p/iResolution.xy + vec2(0.5,0.5)).xy;\n    if (length(v) > 1.) v = normalize(v);\n    return v;\n}\n\nvec2 getPosition(vec2 fragCoord) {\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = (fragCoord + vec2(i,j)) / iResolution.xy;\n            vec2 p = texture(iChannel0, fract(uv)).xy;\n            if(p == vec2(0)) {\n                if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) > 1e-4) continue;\n                p = fragCoord + vec2(i,j) + hash21(float(iFrame)) - 0.5; // add particle\n            } else if (hash13(vec3(fragCoord + vec2(i,j), iFrame)) < 8e-3) {\n                continue; // remove particle\n            }\n            vec2 v = getVelocity(uv);\n            p = p + v;\n            p.x = mod(p.x, iResolution.x);\n            if(abs(p.x - fragCoord.x) < 0.5 && abs(p.y - fragCoord.y) < 0.5)\n                return p;\n        }\n    }\n    return vec2(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.xy = getPosition(fragCoord);\n    fragColor.z = 0.9 * texture(iChannel0, fragCoord/iResolution.xy).z;\n    if (fragColor.x > 0.) fragColor.z = 1.;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fcyzS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Very fast  abossard 099",
    "description": "It's fast because it doesn't use noise but rather sin waves",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "waves",
     "sea",
     "water",
     "ocean",
     "seascape",
     "scape"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// afl_ext 2017-2024\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define DRAG_MULT 0.38 // changes how much waves pull on the water\n#define WATER_DEPTH 1.0 // how deep is the water\n#define CAMERA_HEIGHT 1.5 // how high the camera should be\n#define ITERATIONS_RAYMARCH 12 // waves iterations of raymarching\n#define ITERATIONS_NORMAL 36 // waves iterations when calculating normals\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// Calculates wave value and its derivative, \n// for the wave direction, position in space, wave frequency and time\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\n// Calculates waves by summing octaves of various waves with various parameters\nfloat getwaves(vec2 position, int iterations) {\n  float wavePhaseShift = length(position) * 0.1; // this is to avoid every octave having exactly the same phase everywhere\n  float iter = 0.0; // this will help generating well distributed wave directions\n  float frequency = 1.0; // frequency of the wave, this will change every iteration\n  float timeMultiplier = 2.0; // time multiplier for the wave, this will change every iteration\n  float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n  float sumOfValues = 0.0; // will store final sum of values\n  float sumOfWeights = 0.0; // will store final sum of weights\n  for(int i=0; i < iterations; i++) {\n    // generate some wave direction that looks kind of random\n    vec2 p = vec2(sin(iter), cos(iter));\n    \n    // calculate wave data\n    vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);\n\n    // shift position around according to wave drag and derivative of the wave\n    position += p * res.y * weight * DRAG_MULT;\n\n    // add the results to sums\n    sumOfValues += res.x * weight;\n    sumOfWeights += weight;\n\n    // modify next octave ;\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    timeMultiplier *= 1.07;\n\n    // add some kind of random value to make next wave look random too\n    iter += 1232.399963;\n  }\n  // calculate and return\n  return sumOfValues / sumOfWeights;\n}\n\n// Raymarches the ray from top water layer boundary to low water layer boundary\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {\n  vec3 pos = start;\n  vec3 dir = normalize(end - start);\n  for(int i=0; i < 64; i++) {\n    // the height is from 0 to -depth\n    float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n    // if the waves height almost nearly matches the ray height, assume its a hit and return the hit distance\n    if(height + 0.01 > pos.y) {\n      return distance(pos, camera);\n    }\n    // iterate forwards according to the height mismatch\n    pos += dir * (pos.y - height);\n  }\n  // if hit was not registered, just assume hit the top layer, \n  // this makes the raymarching faster and looks better at higher distances\n  return distance(start, camera);\n}\n\n// Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\nvec3 normal(vec2 pos, float e, float depth) {\n  vec2 ex = vec2(e, 0);\n  float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n  vec3 a = vec3(pos.x, H, pos.y);\n  return normalize(\n    cross(\n      a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), \n      a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)\n    )\n  );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0) {\n    return proj;\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * (((NormalizedMouse.y == 0.0 ? 0.27 : NormalizedMouse.y) * 1.0) * 2.0 - 1.0))\n    * proj;\n}\n\n// Ray-Plane intersection checker\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\n// Some very barebones but fast atmosphere approximation\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {\n  //sundir.y = max(sundir.y, -0.07);\n  float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n  float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n  float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n  float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n  float mymie = sundt * special_trick * 0.2;\n  vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n  vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n  vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n  bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n  return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));\n} \n\n// Calculate where the sun should be, it will be moving around the sky\nvec3 getSunDirection() {\n  return normalize(vec3(-0.0773502691896258 , 0.5 + sin(iTime * 0.2 + 2.6) * 0.45 , 0.5773502691896258));\n}\n\n// Get atmosphere color for given direction\nvec3 getAtmosphere(vec3 dir) {\n   return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;\n}\n\n// Get sun color for given direction\nfloat getSun(vec3 dir) { \n  return pow(max(0.0, dot(dir, getSunDirection())), 720.0) * 210.0;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // get the ray\n  vec3 ray = getRay(fragCoord);\n  if(ray.y >= 0.0) {\n    // if ray.y is positive, render the sky\n    vec3 C = getAtmosphere(ray) + getSun(ray);\n    fragColor = vec4(aces_tonemap(C * 2.0),1.0);   \n    return;\n  }\n\n  // now ray.y must be negative, water must be hit\n  // define water planes\n  vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);\n  vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);\n\n  // define ray origin, moving around\n  vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);\n\n  // calculate intersections and reconstruct positions\n  float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));\n  float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));\n  vec3 highHitPos = origin + ray * highPlaneHit;\n  vec3 lowHitPos = origin + ray * lowPlaneHit;\n\n  // raymatch water and reconstruct the hit pos\n  float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);\n  vec3 waterHitPos = origin + ray * dist;\n\n  // calculate normal at the hit position\n  vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);\n\n  // smooth the normal with distance to avoid disturbing high frequency noise\n  N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n\n  // calculate fresnel coefficient\n  float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n  // reflect the ray and make sure it bounces up\n  vec3 R = normalize(reflect(ray, N));\n  R.y = abs(R.y);\n  \n  // calculate the reflection and approximate subsurface scattering\n  vec3 reflection = getAtmosphere(R) + getSun(R);\n  vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);\n\n  // return the combined result\n  vec3 C = fresnel * reflection + scattering;\n  fragColor = vec4(aces_tonemap(C * 2.0), 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3c3czS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Oceanic abossard 111",
    "description": "This shader demonstrates volumetric (multi sliced) height-clouds with density (based on fractal noise, 'against sun'-shading and god-rays) and a reflecting water simulation.\n\nEnable/Disable God-Rays by changing the code (see comment)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raymarching",
     "waves",
     "sea",
     "raycasting",
     "clouds",
     "water",
     "ocean",
     "godrays",
     "lightrays",
     "sunrays",
     "waterrender",
     "oceanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Clouds: slice based volumetric height-clouds with god-rays, density, sun-radiance/shadow\n// and \n// Water: simple reflecting sky/sun and cloud shaded height-modulated waves\n//\n// Created by Frank Hugenroth 03/2013\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// noise and raymarching based on concepts and code from shaders by inigo quilez\n//\n\n// some variables to change :)\n\n#define RENDER_GODRAYS    1    // set this to 1 to enable god-rays\n//#define RENDER_GODRAYS    0    // disable god-rays\n\n#define RENDER_CLOUDS 1\n#define RENDER_WATER   1\n\nfloat waterlevel = 70.0;        // height of the water\nfloat wavegain   = 1.0;       // change to adjust the general water wave level\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nfloat small_waveheight = 1.0; // change to adjust the small waves\n\nvec3 fogcolor    = vec3( 0.5, 0.7, 1.1 );              \nvec3 skybottom   = vec3( 0.6, 0.8, 1.2 );\nvec3 skytop      = vec3(0.05, 0.2, 0.5);\nvec3 reflskycolor= vec3(0.025, 0.10, 0.20);\nvec3 watercolor  = vec3(0.2, 0.25, 0.3);\n\nvec3 light       = normalize( vec3(  0.1, 0.25,  0.9 ) );\n\n\n\n\n\n\n\n\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\nfloat noise(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noise( p ); p = m2*p;\n  f += 0.2500*noise( p ); p = m2*p;\n  f += 0.1666*noise( p ); p = m2*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n\n// this calculates the water as a height of a given position\nfloat water( vec2 p )\n{\n  float height = waterlevel;\n\n  vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float wave = 0.0;\n  wave += sin(p.x*0.021  + shift2.x)*4.5;\n  wave += sin(p.x*0.0172+p.y*0.010 + shift2.x*1.121)*4.0;\n  wave -= sin(p.x*0.00104+p.y*0.005 + shift2.x*0.121)*4.0;\n  // ...added by some smaller faster waves...\n  wave += sin(p.x*0.02221+p.y*0.01233+shift2.x*3.437)*5.0;\n  wave += sin(p.x*0.03112+p.y*0.01122+shift2.x*4.269)*2.5 ;\n  wave *= large_waveheight;\n  wave -= fbm(p*0.004-shift2*.5)*small_waveheight*24.;\n  // ...added by some distored random waves (which makes the water looks like water :)\n\n  float amp = 6.*small_waveheight;\n  shift1 *= .3;\n  for (int i=0; i<7; i++)\n  {\n    wave -= abs(sin((noise(p*0.01+shift1)-.5)*3.14))*amp;\n    amp *= .51;\n    shift1 *= 1.841;\n    p *= m2*0.9331;\n  }\n  \n  height += wave;\n  return height;\n}\n\n\n// cloud intersection raycasting\nfloat trace_fog(in vec3 rStart, in vec3 rDirection )\n{\n#if RENDER_CLOUDS\n  // makes the clouds moving...\n  vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n  float sum = 0.0;\n  // use only 12 cloud-layers ;)\n  // this improves performance but results in \"god-rays shining through clouds\" effect (sometimes)...\n  float q2 = 0., q3 = 0.;\n  for (int q=0; q<10; q++)\n  {\n    float c = (q2+350.0-rStart.y) / rDirection.y;// cloud distance\n    vec3 cpos = rStart + c*rDirection + vec3(831.0, 321.0+q3-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n    float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 )); // cloud density\n\tsum += (1.0-sum)*alpha; // alpha saturation\n    if (sum>0.98)\n        break;\n    q2 += 120.;\n    q3 += 0.15;\n  }\n  \n  return clamp( 1.0-sum, 0.0, 1.0 );\n#else\n  return 1.0;\n#endif\n}\n\n// fog and water intersection function.\n// 1st: collects fog intensity while traveling\n// 2nd: check if hits the water surface and returns the distance\nbool trace(in vec3 rStart, in vec3 rDirection, in float sundot, out float fog, out float dist)\n{\n  float h = 20.0;\n  float t = 0.0;\n  float st = 1.0;\n  float alpha = 0.1;\n  float asum = 0.0;\n  vec3 p = rStart;\n\t\n  for( int j=1000; j<1120; j++ )\n  {\n    // some speed-up if all is far away...\n    if( t>500.0 ) \n      st = 2.0;\n    else if( t>800.0 ) \n      st = 5.0;\n    else if( t>1000.0 ) \n      st = 12.0;\n\n    p = rStart + t*rDirection; // calc current ray position\n\n#if RENDER_GODRAYS\n    if (rDirection.y>0. && sundot > 0.001 && t>400.0 && t < 2500.0)\n    {\n      alpha = sundot * clamp((p.y-waterlevel)/waterlevel, 0.0, 1.0) * st * 0.024*smoothstep(0.80, 1.0, trace_fog(p,light));\n      asum  += (1.0-asum)*alpha;\n      if (asum > 0.9)\n        break;\n    }\n#endif\n\n    h = p.y - water(p.xz);\n\n    if( h<0.1 ) // hit the water?\n    {\n      dist = t; \n      fog = asum;\n      return true;\n    }\n\n    if( p.y>450.0 ) // lost in space? quit...\n      break;\n    \n    // speed up ray if possible...    \n    if(rDirection.y > 0.0) // look up (sky!) -> make large steps\n      t += 30.0 * st;\n    else\n      t += max(1.0,1.0*h)*st;\n  }\n\n  dist = t; \n  fog = asum;\n  if (h<10.0)\n   return true;\n  return false;\n}\n\n\nvec3 camera( float time )\n{\n  return vec3( 500.0 * sin(1.5+1.57*time), 0.0, 1200.0*time );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n  vec2 s = xy*vec2(1.75,1.0);\n\n  // get camera position and view direction\n  float time = (iTime+13.5+44.)*.05;\n  vec3 campos = camera( time );\n  vec3 camtar = camera( time + 0.4 );\n  campos.y = max(waterlevel+30.0, waterlevel+90.0 + 60.0*sin(time*2.0));\n  camtar.y = campos.y*0.5;\n\n  float roll = 0.14*sin(time*1.2);\n  vec3 cw = normalize(camtar-campos);\n  vec3 cp = vec3(sin(roll), cos(roll),0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n  float sundot = clamp(dot(rd,light),0.0,1.0);\n\n  vec3 col;\n  float fog=0.0, dist=0.0;\n\n  if (!trace(campos,rd,sundot, fog, dist))\n  {\n    // render sky\n    float t = pow(1.0-0.7*rd.y, 15.0);\n    col = 0.8*(skybottom*t + skytop*(1.0-t));\n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 );\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 );\n\n#if RENDER_CLOUDS\n    // CLOUDS\n    vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n    vec4 sum = vec4(0,0,0,0); \n    for (int q=1000; q<1100; q++) // 100 layers\n    {\n      float c = (float(q-1000)*12.0+350.0-campos.y) / rd.y; // cloud height\n      vec3 cpos = campos + c*rd + vec3(831.0, 321.0+float(q-1000)*.15-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n      float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 ))*.9; // fractal cloud density\n      vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n      alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n      sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n      \n      if (sum.w>0.98)\n        break;\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n\n    // This is an important stuff to darken dense-cloud parts when in front (or near)\n    // of the sun (simulates cloud-self shadow)\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7)*pow(sundot,13.0)*alpha;\n    // This brightens up the low-density parts (edges) of the clouds (simulates light scattering in fog)\n    sum.rgb += 0.2*vec3(1.3, 1.2, 1.0)* pow(sundot,5.0)*(1.0-alpha);\n\n    col = mix( col, sum.rgb , sum.w*(1.0-t) );\n#endif\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog;\n  }\n  else\n  {\n#if RENDER_WATER        \n    //  render water\n    \n    vec3 wpos = campos + dist*rd; // calculate position where ray meets water\n\n    // calculate water-mirror\n    vec2 xdiff = vec2(0.1, 0.0)*wavegain*4.;\n    vec2 ydiff = vec2(0.0, 0.1)*wavegain*4.;\n\n    // get the reflected ray direction\n    rd = reflect(rd, normalize(vec3(water(wpos.xz-xdiff) - water(wpos.xz+xdiff), 1.0, water(wpos.xz-ydiff) - water(wpos.xz+ydiff))));  \n    float refl = 1.0-clamp(dot(rd,vec3(0.0, 1.0, 0.0)),0.0,1.0);\n  \n    float sh = smoothstep(0.2, 1.0, trace_fog(wpos+20.0*rd,rd))*.7+.3;\n    // water reflects more the lower the reflecting angle is...\n    float wsky   = refl*sh;     // reflecting (sky-color) amount\n    float wwater = (1.0-refl)*sh; // water-color amount\n\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n\n    // watercolor\n\n    col = wsky*reflskycolor; // reflecting sky-color \n    col += wwater*watercolor;\n    col += vec3(.003, .005, .005) * (wpos.y-waterlevel+30.);\n\n    // Sun\n    float wsunrefl = wsky*(0.5*pow( sundot, 10.0 )+0.25*pow( sundot, 3.5)+.75*pow( sundot, 300.0));\n    col += vec3(1.5,1.3,1.0)*wsunrefl; // sun reflection\n\n#endif\n\n    // global depth-fog\n    float fo = 1.0-exp(-pow(0.0003*dist, 1.5));\n    vec3 fco = fogcolor + 0.6*vec3(0.6,0.5,0.4)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog; \n  }\n\n  fragColor=vec4(col,1.0);\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wc3czS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Luminescen abossard 121",
    "description": "My entry for the monthly challenge on r/proceduralgeneration \nUse the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\nCode is a bit of a mess, too lazy to clean up. Hope you like it!",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "ocean",
     "underwater",
     "jellyfish",
     "deepsea"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dlXz7",
       "filepath": "https://soundcloud.com/klauslunde/zebra-tribute",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Luminescence by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// My entry for the monthly challenge (May 2017) on r/proceduralgeneration \n// Use the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\n// Code is a bit of a mess, too lazy to clean up. Hope you like it!\n\n// Music by Klaus Lunde\n// https://soundcloud.com/klauslunde/zebra-tribute\n\n// YouTube: The Art of Code -> https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// Twitter: @The_ArtOfCode\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100.\n#define VOLUME_STEPS 8.\n//#define SINGLE\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define HIT_DISTANCE .01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 accentColor1 = vec3(1., .1, .5);\nvec3 secondColor1 = vec3(.1, .5, 1.);\n\nvec3 accentColor2 = vec3(1., .5, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nvec3 bg;\t \t// global background color\nvec3 accent;\t// color of the phosphorecence\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// final distance to field\n    float m; \t// material\n    vec3 uv;\n    float pump;\n    \n    vec3 id;\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    //vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    //o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// ============== Functions I borrowed ;)\n\n//  3 out, 1 in... DAVE HOSKINS\nvec3 N31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// DE functions from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s); }\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n    \n// -------------------------\n\n\nfloat Dist( vec2 P,  vec2 P0, vec2 P1 ) {\n    //2d point-line distance\n    \n\tvec2 v = P1 - P0;\n    vec2 w = P - P0;\n\n    float c1 = dot(w, v);\n    float c2 = dot(v, v);\n    \n    if (c1 <= 0. )  // before P0\n    \treturn length(P-P0);\n    \n    float b = c1 / c2;\n    vec2 Pb = P0 + b*v;\n    return length(P-Pb);\n}\n\nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nvec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n\t// returns the two t's for the closest point between two rays\n    // ro+rd*t1 = ro2+rd2*t2\n    \n    vec3 dO = ro2-ro1;\n    vec3 cD = cross(rd1, rd2);\n    float v = dot(cD, cD);\n    \n    float t1 = dot(cross(dO, rd2), cD)/v;\n    float t2 = dot(cross(dO, rd1), cD)/v;\n    return vec2(t1, t2);\n}\n\nfloat DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n\t// returns the distance from ray r to line segment p1-p2\n    vec3 rd2 = p2-p1;\n    vec2 t = RayRayTs(ro, rd, p1, rd2);\n    \n    t.x = max(t.x, 0.);\n    t.y = clamp(t.y, 0., length(rd2));\n                \n    vec3 rp = ro+rd*t.x;\n    vec3 sp = p1+rd2*t.y;\n    \n    return length(rp-sp);\n}\n\nvec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n\t// does a ray sphere intersection\n    // returns a vec2 with distance to both intersections\n    // if both a and b are MAX_DISTANCE then there is no intersection\n    \n    vec3 oc = pos - ro;\n    float l = dot(rd, oc);\n    float det = l*l - dot(oc, oc) + radius*radius;\n    if (det < 0.0) return vec2(MAX_DISTANCE);\n    \n    float d = sqrt(det);\n    float a = l - d;\n    float b = l + d;\n    \n    return vec2(a, b);\n}\n\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = bg*(1.+y);\n    \n\tfloat t = iTime;\t\t\t\t// add god rays\n    \n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.05;\n\n    return col;\n}\n\n\n\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\n\nde map( vec3 p, vec3 id ) {\n\n    float t = iTime*2.;\n    \n    float N = N3(id);\n    \n    de o;\n    o.m = 0.;\n    \n    float x = (p.y+N*twopi)*1.+t;\n    float r = 1.;\n    \n    float pump = cos(x+cos(x))+sin(2.*x)*.2+sin(4.*x)*.02;\n    \n    x = t + N*twopi;\n    p.y -= (cos(x+cos(x))+sin(2.*x)*.2)*.6;\n    p.xz *= 1. + pump*.2;\n    \n    float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n    float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n    \n    o.d = smax(d1, -d2, .1);\n    o.m = 1.;\n    \n    if(p.y<.5) {\n        float sway = sin(t+p.y+N*twopi)*S(.5, -3., p.y)*N*.3;\n        p.x += sway*N;\t// add some sway to the tentacles\n        p.z += sway*(1.-N);\n        \n        vec3 mp = p;\n    \tmp.xz = pModPolar(mp.xz, 6., 0.);\n        \n        float d3 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .01, mp.y);\n    \tif(d3<o.d) o.m=2.;\n        d3 += (sin(mp.y*10.)+sin(mp.y*23.))*.03;\n        \n        float d32 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .04, mp.y)*.5;\n        d3 = min(d3, d32);\n        o.d = smin(o.d, d3, .5);\n        \n        if( p.y<.2) {\n             vec3 op = p;\n    \t\top.xz = pModPolar(op.xz, 13., 1.);\n            \n        \tfloat d4 = length(op.xz-vec2(.85, .0))-remap(.5, -3., .04, .0, op.y);\n    \t\tif(d4<o.d) o.m=3.;\n            o.d = smin(o.d, d4, .15);\n        }\n    }    \n    o.pump = pump;\n    o.uv = p;\n    \n    o.d *= .8;\n    return o;\n}\n\nvec3 calcNormal( de o ) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy, o.id).d - map(o.pos-eps.xyy, o.id).d,\n\t    map(o.pos+eps.yxy, o.id).d - map(o.pos-eps.yxy, o.id).d,\n\t    map(o.pos+eps.yyx, o.id).d - map(o.pos-eps.yyx, o.id).d );\n\treturn normalize(nor);\n}\n\nde CastRay(ray r) {\n    float d = 0.;\n    float dS = MAX_DISTANCE;\n    \n    vec3 pos = vec3(0., 0., 0.);\n    vec3 n = vec3(0.);\n    de o, s;\n    \n    float dC = MAX_DISTANCE;\n    vec3 p;\n    rc q;\n    float t = iTime;\n    vec3 grid = vec3(6., 30., 6.);\n        \n    for(float i=0.; i<MAX_STEPS; i++) {\n        p = r.o + r.d*d;\n        \n        #ifdef SINGLE\n        s = map(p, vec3(0.));\n        #else\n        p.y -= t;  // make the move up\n        p.x += t;  // make cam fly forward\n            \n        q = Repeat(p, grid);\n    \t\n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n        float N = N3(q.id);\n        q.p += (N31(N)-.5)*grid*vec3(.5, .7, .5);\n        \n\t\tif(Dist(q.p.xz, r.d.xz, vec2(0.))<1.1)\n        //if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.), vec3(0., -3.3, 0)) <1.1) \n        \ts = map(q.p, q.id);\n        else\n            s.d = dC;\n        \n        \n        #endif\n           \n        if(s.d<HIT_DISTANCE || d>MAX_DISTANCE) break;\n        d+=min(s.d, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    if(s.d<HIT_DISTANCE) {\n        o.m = s.m;\n        o.d = d;\n        o.id = q.id;\n        o.uv = s.uv;\n        o.pump = s.pump;\n        \n        #ifdef SINGLE\n        o.pos = p;\n        #else\n        o.pos = q.p;\n        #endif\n    }\n    \n    return o;\n}\n\nfloat VolTex(vec3 uv, vec3 p, float scale, float pump) {\n    // uv = the surface pos\n    // p = the volume shell pos\n    \n\tp.y *= scale;\n    \n    float s2 = 5.*p.x/twopi;\n    float id = floor(s2);\n    s2 = fract(s2);\n    vec2 ep = vec2(s2-.5, p.y-.6);\n    float ed = length(ep);\n    float e = B(.35, .45, .05, ed);\n    \n   \tfloat s = SIN(s2*twopi*15. );\n\ts = s*s; s = s*s;\n    s *= S(1.4, -.3, uv.y-cos(s2*twopi)*.2+.3)*S(-.6, -.3, uv.y);\n    \n    float t = iTime*5.;\n    float mask = SIN(p.x*twopi*2. + t);\n    s *= mask*mask*2.;\n    \n    return s+e*pump*2.;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*10.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = S(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = CastRay(camRay);\n    \n    float t = iTime;\n    vec3 L = up;\n    \n\n    if(o.m>0.) {\n        vec3 n = calcNormal(o);\n        float lambert = sat(dot(n, L));\n        vec3 R = reflect(camRay.d, n);\n        float fresnel = sat(1.+dot(camRay.d, n));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n        float fade = 0.;\n        \n        if(o.m==1.) {\t// hood color\n            float density = 0.;\n            for(float i=0.; i<VOLUME_STEPS; i++) {\n                float sd = sph(o.uv, camRay.d, vec3(0.), .8+i*.015).x;\n                if(sd!=MAX_DISTANCE) {\n                    vec2 intersect = o.uv.xz+camRay.d.xz*sd;\n\n                    vec3 uv = vec3(atan(intersect.x, intersect.y), length(intersect.xy), o.uv.z);\n                    density += VolTex(o.uv, uv, 1.4+i*.03, o.pump);\n                }\n            }\n            vec4 volTex = vec4(accent, density/VOLUME_STEPS); \n            \n            \n            vec3 dif = JellyTex(o.uv).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, volTex.rgb, volTex.a);\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(up, n));\n\n            //fade\n            fade = max(fade, S(.0, 1., fresnel));\n        } else if(o.m==2.) {\t\t\t\t\t\t// inside tentacles\n            vec3 dif = accent;\n    \t\tcol = mix(bg, dif, fresnel);\n            \n            col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n            \n            float prop = o.pump+.25;\n            prop *= prop*prop;\n            col += pow(1.-fresnel, 20.)*dif*prop;\n            \n            \n            fade = fresnel;\n        } else if(o.m==3.) {\t\t\t\t\t\t// outside tentacles\n        \tvec3 dif = accent;\n            float d = S(100., 13., o.d);\n    \t\tcol = mix(bg, dif, pow(1.-fresnel, 5.)*d);\n        }\n        \n        fade = max(fade, S(0., 100., o.d));\n        col = mix(col, bg, fade);\n        \n        if(o.m==4.)\n            col = vec3(1., 0., 0.);\n    } \n     else\n        col = bg;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.04;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x; \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    if(m.x<0.05 || m.x>.95) {\t\t\t\t// move cam automatically when mouse is not used\n    \tm = vec2(t*.25, SIN(t*pi)*.5+.5);\n    }\n\t\n    accent = mix(accentColor1, accentColor2, SIN(t*15.456));\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    #ifdef SINGLE\n    float camDist = -10.;\n    #else\n    float camDist = -.1;\n    #endif\n    \n    vec3 lookAt = vec3(0., -1., 0.);\n    \n    vec3 camPos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n   \t\n    CameraSetup(uv, camPos+lookAt, lookAt, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n    \n    col = pow(col, vec3(mix(1.5, 2.6, SIN(t+pi))));\t\t// post-processing\n    float d = 1.-dot(uv, uv);\t\t// vignette\n    col *= (d*d*d)+.1;\n    \n    fragColor = vec4(col, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3f3czS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Cross-Gala abossard 134",
    "description": "The ocean is the vorono diagram of a distorted grid. The wave sound is a white noise with a low pass filter. Use your mouse to rotate the camera!",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "voronoi",
     "raymarch",
     "retro",
     "water",
     "space",
     "80"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.1415926535\n#define STEPS 50\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\n// noise function\nfloat noise( in vec2 p ) {\t\n    p *= rot(1.941611);\n    return sin(p.x) * .25 + sin(p.y) * .25 + .50;\n}\n\n// get the 2 closest point with the projected height as z\nvoid grid( in vec2 p, inout vec3 projClosest, inout vec3 projSecondClosest ) {\n    vec2 center = floor(p) + 0.5;\n    vec2 secondBestCenter = center;\n    float secondBestDist = 99999.9;\n    vec2 bestCenter = center;\n    float bestDist = 99999.9;\n    \n    for (int y = -1 ; y <= 1 ; y++)\n    for (int x = -1 ; x <= 1 ; x++) {\n\t\tvec2 currentCenter = center + vec2(x, y);\n        // vary each center a bit\n       \tcurrentCenter.x += noise( \n            iTime * vec2(0.5124, 0.5894) + \n            currentCenter * vec2(1.3124, 1.7894)) * 1.0 - 0.5;\n        currentCenter.y += noise( \n            iTime * vec2(0.5565, 0.5561) - \n            currentCenter * vec2(1.5124, 1.6053)) * 1.0 - 0.5;\n        \n        vec2 delta = p - currentCenter;\n        float currentDist = dot(delta, delta)*0.5;\n        // use an analytical if to avoid the branch\n        float if1 = step(currentDist, bestDist);\n        float if1m = 1.0 - if1;\n        secondBestCenter = if1*bestCenter + if1m*secondBestCenter;\n        secondBestDist = if1*bestDist + if1m*secondBestDist;\n        bestCenter = if1*currentCenter + if1m*bestCenter;\n        bestDist = if1*currentDist + if1m*bestDist;\n        // else if\n        float if2 = step(currentDist, secondBestDist)*if1m;\n        float if2m = 1.0 - if2;\n        secondBestCenter = if2*currentCenter + if2m*secondBestCenter;\n        secondBestDist = if2*currentDist + if2m*secondBestDist;\n\n    }\n    \n    projClosest = vec3(bestCenter, bestDist);\n    projSecondClosest = vec3(secondBestCenter, secondBestDist);\n\n}\n\n// normal function\nvec3 normal( in vec3 p, in vec3 proj ) {\n    vec2 dir = proj.xy - p.xy;\n    vec3 tang = vec3(dir, proj.z*0.12);\n    vec3 nine = vec3(dir, 0).yxz;\n    nine.x = -nine.x;\n    return normalize(cross(nine, tang));\n}\n\n// distance function\nfloat de( in vec3 p, inout vec3 projClosest, inout vec3 projSecondClosest ) {\n    // get the closest points\n    grid(p.xy, projClosest, projSecondClosest);\n    float below = 0.0;\n    below -= sin(dot(p.xy, vec2(0.005, 0.051)) * 4.0 + iTime * 0.5) * 0.4 + 0.2;\n    below -= 1.0 - projClosest.z;\n\treturn max(0.0, p.z - below);\n}\n\n// return the sun color at this direction\nvec4 getSunColor( in vec3 dir, inout float inside ) {\n    float dotp = dot(dir, vec3(-0.99, 0.0, 0.1));\n    float sunHeight = smoothstep(0.01, 0.29, dir.z);\n    inside = smoothstep(0.977, 0.979, dotp);\n    float ytemp = abs(dir.y)*dir.y;\n    float sunWave = sin(dir.z*300.0+iTime*1.846+\n                        sin(ytemp*190.0+iTime*0.45)*1.3)*0.5+0.5;\n   \tfloat sunHeight2 = smoothstep(-0.1, 0.2, dir.z);\n    sunWave = sunWave * sunHeight2 + 1.0 - sunHeight2;\n    sunWave = (1.0-smoothstep(sunHeight2, 1.0, sunWave)) * (1.0 - sunHeight2) + sunHeight2;\n    float sun = inside * sunWave;\n    return vec4(mix(vec3(0.998, 0.108, 0.47), vec3(0.988, 0.769, 0.176), sunHeight), sun);\n}\n\n// get the space color\nvec3 getSpaceColor( in vec3 dir ) {\n    float scanline = sin(dir.z * 700.0 - iTime * 5.1)*0.5+0.5;\n    scanline *= scanline;\n    vec3 color = mix(vec3(0.1, 0.16, 0.26), vec3(0.1), scanline);\n    vec2 uv = vec2(atan(dir.y, dir.x) / (2.0 * PI) + 0.5, mod(dir.z, 1.0));\n    uv.x = mod(uv.x+2.0*PI, 1.0);\n    uv.x *= 100.0;\n    uv.y *= 15.00;\n    uv *= rot(1.941611+iTime*0.00155);\n    vec2 center = floor(uv) + 0.5;\n    center.x += noise(center*48.6613) * 0.8 - 0.4;\n    center.y += noise(center*-31.1577) * 0.8 - 0.4;\n    float radius = smoothstep(0.6, 1.0, noise(center*42.487+\n                                              vec2(0.1514, 0.1355)*iTime)); \n    radius *= 0.01;\n    vec2 delta = uv-center;\n    float dist = dot(delta, delta);\n    float frac = 1.0-smoothstep(0.0, radius, dist);\n    float frac2 = frac;\n    frac2 *= frac2; frac2 *= frac2; frac2 *= frac2;\n    vec3 lightColor = mix(vec3(0.988, 0.769, 0.176), \n                          vec3(0.988, 0.434, 0.875), noise(center*74.487));\n    return mix(color, lightColor, frac) + vec3(1)*frac2;\n}\n\n// get the background color (ala cubemap)\nvec3 getBackgroundColor( in vec3 dir ) {\n    float horizon = 1.0 - smoothstep(0.0, 0.02, dir.z);\n    // this is the background with the scanline\n    vec3 color = getSpaceColor(dir);\n    // get the sun\n    float inside = 0.0;\n    vec4 sun = getSunColor(dir, inside);\n    color = mix(color, vec3(0.1, 0.16, 0.26), inside);\n    color = mix(color, sun.rgb, sun.a);\n    // the horizon\n    color = mix(color, vec3(0.43, 0.77, 0.85), horizon * (1.0 - sun.a * 0.19));\n    return color;\n}\n\n// the color gets more blue/white near edges of the voronoi cells\nvec3 getWaveColor( in vec3 p, in vec3 projClosest, in vec3 projSecondClosest,\n                  in vec3 dir, float dist, vec2 frag ) {\n    float distanceToEdge = abs(projClosest.z-projSecondClosest.z);\n    float distanceFrac = smoothstep(-10.0, 100.0, dist);\n    distanceFrac *= distanceFrac; distanceFrac *= distanceFrac;\n    float frac = smoothstep(0.0, 0.1+distanceFrac*0.9, distanceToEdge);\n    // get the reflection\n    vec3 norm = normal(p, projClosest);\n    vec3 color = getBackgroundColor(reflect(dir, norm));\n    // add a screenspace scanline\n    frac *= (sin(frag.y/iResolution.y*700.0)*0.5+0.5)*(1.0-distanceFrac);\n    return mix(vec3(0.43, 0.77, 0.85), color, frac);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(0, 0, 0.2);\n\tvec3 dir = normalize(vec3(uv.x*0.6, 1.0, uv.y*-0.6));\n    \n\tdir.xy *= rot(PI*.5);\n\tvec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n    mouse *= step(1.0, iMouse.z);\n\tdir.xz *= rot(3.16-(-mouse.y*1.5)+sin(iTime*0.785)*0.008);\n\tdir.xy *= rot(-mouse.x*4.0+sin(iTime*0.416)*0.01);\n    dir.yz *= rot(sin(iTime*0.287)*0.009);\n    \n\tvec3 color = vec3(0);\n    \n    if (dir.z > 0.0) {\n        color = getBackgroundColor(dir);\n    } else {\n       // project the starting position to z = 0 so we ccan lower the raymarch count\n        float totdist = from.z / -dir.z;\n        for (int steps = 0 ; steps < STEPS ; steps++) {\n            vec3 p = from + totdist * dir;\n            vec3 projClosest;\n            vec3 projSecondClosest;\n            p.x -= iTime * 2.7;\n            float dist = de(p, projClosest, projSecondClosest);\n            totdist += dist;\n            if ( dist < 0.01 || steps == STEPS-1 ) {\n                color = getWaveColor(p, projClosest, projSecondClosest,\n                                     dir, totdist, fragCoord);\n                break;\n            }\n        }\n\t}\n    \n    fragColor = vec4(color, 1);\n    \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "XsfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.1415926535\n\n// comment these define to remove the synth and/or wave sound\n#define SYNTH\n#define WAVE\n\n// octave is an integer number, 0 is some octave, 1 is an octave higher, etc\n// pitch is an integer between 0 and 7\n// fractionnal and negative values are allowed\n// returns a frequency in Hz\nfloat tone(float octave, float pitch) {\n    float baseFreq = 264.0;\n    baseFreq *= pow(2.0, octave); // multiply the frequency by 2 for higher octave\n    baseFreq *= pow(1.1041, pitch); // seventh root of 2\n    return baseFreq;\n}\n\n// 1D version of IQ code, see https://www.shadertoy.com/view/lsf3WH\nfloat hash( float p ){\n\tfloat h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\nfloat perlinNoise( in float x ) {\n    float lower = floor(x);\n    float upper = lower + 1.0;\n    float lowerV = hash(lower);\n    float upperV = hash(upper);\n    return smoothstep(lower, upper, x) * (upperV - lowerV) + lowerV;\n}\n\n// return a different white noise on both channels\n// thanks Dave Hoskins! see https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec2 hash22( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 noise( in float time ) {\n\tvec2 audio = vec2(0.0);\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t)*3.21239;\n\t\taudio += hash22(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    return audio;\n}\n\n// do a low pass on the white noise and get the wave sound\n#define SAMPLES 41\nvec2 getWaveSound( in float time ) {\n    // snap to the nearest 1/iSampleRate\n    float period = 1.0 / iSampleRate;\n    time = floor(time/period)*period;\n    float totAmpl = 0.0;\n    vec2 audio = vec2(0);\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float index = float(i - SAMPLES/2);\n        float currStepF = period * index;\n        vec2 curr = noise(time + currStepF);\n        index /= 2.0; index *= index;\n        float ampl = 1.0 - index;\n        totAmpl += ampl;\n        audio += curr*ampl;\n    }\n    return audio/totAmpl;\n}\n\n// base synth sound\n#define SYNTH_HARMONICS 3\nfloat getSynthBase( in float time, in float freq, in float frac ) {\n    float x = fract(time*freq);\n    float value = 0.0;\n    if ( x < 0.078) {\n        value = 0.692 - smoothstep(0.0, 0.078, x) * 0.588;\n    } else if ( x < 0.346 ) {\n        value = smoothstep(0.078, 0.346, x) * 0.666 + 0.105; \n    } else if ( x < 0.986 ) {\n        value = 0.771 - smoothstep(0.346, 0.986, x) * 0.351;\n    } else {\n        value = smoothstep(0.986, 1.0, x) * 0.272 + 0.420;\n    }\n    value *= 2.7;\n    float totAmpl = 2.7;\n    \n    // add harmonics\n    float mult = time*2.0*PI*freq;\n    for (int i = 0 ; i < SYNTH_HARMONICS ; i++) {\n        float fact = 1.0 / pow(2.0, float(i)); // = 1, = .5, =.25 etc\n        float harm = sin(mult * fact);\n        float ampl = (cos(frac*2.0*PI) * 3.0 + 4.0) * (1.0 - fact) + 3.0;\n       \tvalue += harm * ampl;\n        totAmpl += ampl;\n    }\n    \n    return value / totAmpl;\n}\n\n#define TEMPO 7.0\n\n// partition\nfloat getTone( in float time ) {\n    float timei = floor((time+TEMPO) / TEMPO);\n    return floor((sin(timei*3.95216) * 0.5 + 0.5) * 4.0);\n}\n\n// synth sound\n#define PART_LENGTH 4.0\n#define PART_COUNT 3.0\n#define TOT_PART (PART_LENGTH*PART_COUNT)\nvec2 getSynth( in float time ) {\n    float part = mod(floor(time / TEMPO / PART_LENGTH), PART_COUNT);\n    if (mod(time, TEMPO * TOT_PART) > TEMPO * 7.0) return vec2(0); // add some calm\n    float currentTone = getTone(time);\n    float frac = mod(time, TEMPO);\n    float freq = tone(-2.0+part, currentTone);\n\tfloat ampl = smoothstep(0.0, 2.0, frac) * (1.0 - smoothstep(TEMPO-2.0, TEMPO, frac));\n    float synthBase = ampl * getSynthBase(time, freq, mod(time, TEMPO)/TEMPO);\n    frac = smoothstep(0.0, TEMPO, frac); // stereo panning\n    if ( mod(floor(time / TEMPO), 2.0) < 1.0) frac = 1.0 - frac;\n    return vec2((1.0-frac)*synthBase, 1.0*synthBase);\n}\n\nvec2 mainSound( in int samp,float time) {\n    vec2 result = vec2(0);\n    \n    #ifdef SYNTH\n    result += smoothstep(0.0, 2.0, time) * getSynth(time);\n    #endif\n    \n    #ifdef WAVE\n    float waveAmpl = sin(time * 0.353) * 0.12 + 0.24;\n    float perlinAmpl = 1.0 - perlinNoise( time * 1.2146 ) * 0.5;\n    result += smoothstep(0.0, 12.0, time) * getWaveSound(time) * waveAmpl * perlinAmpl;\n    #endif\n    \n    return result;\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf3czS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Oblivion r abossard 213",
    "description": "A simple sci-fi radar.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "radar"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*iTime, 80.0);\n    return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WccczS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Grid of Cy abossard 275",
    "description": "Using a 2D regular grid as acceleration structure for raytracing (an infinite amount of) cylinders. I trace across the 2D grid and then intersect the cylinder inside each cell. When the first intersection is found, the tracing can stop.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raytracing",
     "grid",
     "dda",
     "cylinder",
     "regulargrid",
     "vr"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRn",
       "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot\n// host, display, distribute or share this Work neither as\n// is or altered, in any form including physical and\n// digital. You cannot use this Work in any commercial or\n// non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it. You\n// cannot use this Work to train AI models. I share this\n// Work for educational purposes, you can link to it as\n// an URL, proper attribution and unmodified screenshot,\n// as part of your educational material. If these\n// conditions are too restrictive please contact me.\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#if HW_PERFORMANCE==0\n#define VIS_SAMPLES 1\n#else\n#define VIS_SAMPLES 4\n#endif\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\n\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\tf *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell (dda)\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nconst vec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\t\n    float sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n    vec3 bgcol = vec3(0.9,1.0,1.0) + 0.3*pow(sun,4.0);\n\n    // raytrace\n    vec3 col = bgcol;\n    vec4 res = raycast( ro, rd );\n    vec2 vos = res.zw;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + rd*t;\n        float id  = hash1( vos );\n        vec3  nor = calcNormal( fract(pos)-0.5, res.y );\n        float h = map(vos);\n\n        // material color\t\t\t\n        vec3 mate = 0.55 + 0.45*sin( 2.0*id + 1.8 + vec3(0.0,0.5,1.0) );\n\n        vec3 uvw = pos - vec3(0.0,h,0.0);\n        vec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n        mate *= 0.2+4.0*tex*tex;\n        mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\n        // material cheap/wrong bump\t\t\t \n        //vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n        //nor = normalize(nor + 0.3*bn*(1.0-0.5*nor.y) );\n\n        // procedural occlusion\n        float occ = nor.y*0.75;\n        occ += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n        occ += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n        occ += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n        occ += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n        occ = 0.2 + 0.8*occ;\n        occ *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n        occ = occ*0.5+0.5*occ*occ;\n        float rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n\n        //-------------\n        // lighitng\n        //-------------\n        float amb = 1.0;\n        //-------------\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n        //-------------\n        float dif = dot( nor, lig );\n        if( dif>0.0 ) dif *= castShadowRay( pos, lig );\n        dif = max( dif, 0.0 );\n        float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n        //-------------\n        vec3 lin  = 3.00*vec3(1.0,1.0,1.0)*dif;\n             lin += 0.80*vec3(0.4,1.0,1.7)*amb*occ;\n             lin += 0.30*vec3(0.8,0.5,0.3)*bac*occ;\n\n        col = mate*lin + tex.x*1.5*(0.3+0.7*rim)*spe*dif;\n\n        // fog\n        float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n        col = mix( col, bgcol, 1.0-ff );\n        \n    }\n    col += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\n    // tone mapping\t\t\t\n    tot = tot*1.2/(1.0+tot);\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    tot = tot*tot*(3.0-2.0*tot);\n    \n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fcczS",
    "date": "0",
    "viewed": 0,
    "name": "Fork Pretty Hip abossard 280",
    "description": "Definitely some squares. The math is almost certainly more complicated than it needs to be - I'm refusing to think too hard today.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "cineshader"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n    float value;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    uv -= vec2(0.5, 0.5*aspect);\n    float rot = radians(45.0); // radians(45.0*sin(iTime));\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tuv  = m * uv;\n    uv += vec2(0.5, 0.5*aspect);\n    uv.y+=0.5*(1.0-aspect);\n    vec2 pos = 10.0*uv;\n    vec2 rep = fract(pos);\n    float dist = 2.0*min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n    \n    float edge = sin(iTime-squareDist*0.5)*0.5+0.5;\n    \n    edge = (iTime-squareDist*0.5)*0.5;\n    edge = 2.0*fract(edge*0.5);\n    //value = 2.0*abs(dist-0.5);\n    //value = pow(dist, 2.0);\n    value = fract (dist*2.0);\n    value = mix(value, 1.0-value, step(1.0, edge));\n    //value *= 1.0-0.5*edge;\n    edge = pow(abs(1.0-edge), 2.0);\n    \n    //edge = abs(1.0-edge);\n    value = smoothstep( edge-0.05, edge, 0.95*value);\n    \n    \n    value += squareDist*.1;\n    //fragColor = vec4(value);\n    fragColor = mix(vec4(1.0,1.0,1.0,1.0),vec4(0.5,0.75,1.0,1.0), value);\n    fragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3c3yRB",
    "date": "0",
    "viewed": 0,
    "name": "Fork Simple Gre abossard 362",
    "description": "Manual unroll of so called shape grammar split (for \"man made\" tech detail) applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\nMouse to look around (2 camera paths) ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "tech",
     "tiles",
     "greeble",
     "split",
     "laserbeam",
     "deathstar",
     "trench",
     "shapegrammar",
     "cineshader"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Simple Greeble - Split4 by Jerome Liard, August 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4tXcRl\n\n// Manual unroll of so called shape grammar split (for \"man made\" tech detail)\n// applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\n// Mouse to look around (2 camera paths)\n\n// I was initially working on split/subdivided tiles for something else,\n// but as it started to look familiar I pushed in the fan art direction.\n//\n// The tiles use several hardcoded quad split variants (all resulting in 4 children),\n// and we recurse down 1 level on a couple of them (max 10 leaves).\n//\n// I find the lack of motion blur disturbing, but time was spent on other futile things instead.\n\n#if 1\n#define TIME_OFFSET 0.0\n#define CAM2_TIME_OFFSET 0.0\n#else\n#define TIME_OFFSET 54.0\n#define CAM2_TIME_OFFSET 7.0\n#endif\n#define CAMERA_REPEAT\n// tile eval count (x1 x2 x4 (max)... to deal with cell boundaries), the more evals the less artifacts but it also depend on a ton of other things - use 1 or 2 really\n#define NUM_TILE_EVALS 1\n// warp first iteration with raytracing to reduce trace iteration count, affects lighting a bit\n#define RAYTRACE_FIRST_MARCH_DISTANCE\n// small trace optim that creates color disparity as a side effect (a bug promoted into a feature)\n#define RAYMARCH_WITH_LOD\n// allow proper shadows close to us, expensive and doesn't contribute that much... disable\n//#define TRACED_SHADOW\n// do the main cast shadow analytically\n#define ANALYTICAL_SHADOW\n// worry not, it's not screenspace\n#define AO\n// color tiles (debug)\n//#define COLOR_TILES\n#define STARFIELD\n#define SUN\n// scene type\n//#define PRIMITIVES\n#define SORT_OF_MOON\n#define LASERS\n// max marching iterations\n#define MAX_ITERATIONS 140\n// tweak for perfs vs quality etc\n#define DBREAK 0.00125\n#define TMAX 200.0\n#define TFRAC 0.5\n\n// threshold distance used by RAYMARCH_WITH_LOD and RAYTRACE_FIRST_MARCH_DISTANCE\n#define ROUGH_SHELL_D 0.45\n\n#define FLYING_SPEED 10.0\n#define TRENCH_DEPTH 4.8\n#define TRENCH_HALF_WIDTH 2.0\n\nfloat PI = 3.141592654;\n\n#ifndef FLT_MAX\n#define FLT_MAX 1000000.0\n#endif\n\nvec3 RED\t = vec3( 1, 0, 0 );\nvec3 GREEN\t = vec3( 0, 1, 0 );\nvec3 BLACK\t = vec3( 0, 0, 0 );\n\nvec2 xset( vec2 p, float v ) { return vec2( v, p.y );}\nvec2 yset( vec2 p, float v ) { return vec2( p.x, v );}\nvec3 xset( vec3 p, float v ) { return vec3( v, p.y, p.z );}\nvec3 yset( vec3 p, float v ) { return vec3( p.x, v, p.z );}\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec2 )\nIMPL_SATURATE( vec3 )\nIMPL_SATURATE( vec4 )\n\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\n// cubicstep is a generic smoothstep where you can set in and out slopes\n// slope at x=0 is df0\n// slope at x=1 is df1\n// smoothstep_unchecked(x) == cubicstep(x,0,0)\nfloat cubicstep( float x, float df0, float df1 ) { float b = 3.0 - df1 - 2.0 * df0; float a = 1.0 - df0 - b; return ( ( a * x + b ) * x + df0 ) * x; }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nfloat box( float x ) { return abs( x ) < 1.0 ? 1.0 : 0.0; }\nvec3 chrominance( vec3 c ) { return c / max( c.r, max( c.g, c.b ) ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\n\n// project this on line (O,d), d is assumed to be unit length for project_on_line1\n// project_on_liney: d = 0,1,0\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_liney( type P, type O ) { O.y += ( P - O ).y; return O; } /* d = vec3(0,1,0) */\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\n/* min,max constructor*/ \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\n/*btype mkbounds_unchecked_invalid() { btype ret; ret.pmin = FLT_MAX; ret.pmax = -FLT_MAX; return ret; }*/ \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\ntype closest( btype b, type p ) { return min( max( p, b.pmin ), b.pmax ); } \\\nbool inside( btype b, type p ) { return all_( /*booltype*/( p == closest( b, p ) ) ); }\n\nbool all_( bool value ) { return value; } // not defined in glsl, apparently + can't use same name else some compilers barf\nbool all_( bvec2 value ) { return all( value ); }\nbool all_( bvec3 value ) { return all( value ); }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\nbounds3 mkbounds_unchecked( bounds2 b, float height )\n{\n\tbounds3 ret;\n\tret.pmin = vec3( b.pmin.xy, 0 );\n\tret.pmax = vec3( b.pmax.xy, height );\n\treturn ret;\n}\nbounds2 xy( bounds3 b ) { return mkbounds_unchecked( b.pmin.xy, b.pmax.xy  ); }\nbounds2 xy( bounds2 b ) { return b; }\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n/* y=1-x on 0,1, output 0,1 */ \\\ntype tri0( type x ) { return abs( fract( x * 0.5 ) - type(0.5) ) * 2.0; } \\\n/* function returns 0 at x = half_width */ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\nfloat spaced_tri( float x, float period, float half_width ) { period *= 0.5; x /= period; return max( 0.0, 1.0 + ( tri0( x ) - 1.0 ) * ( period / half_width ) ); }\nfloat spaced_bumps( float x, float s, float r ) { return smoothstep_unchecked( spaced_tri( x, s, r ) ); }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE3 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195, 444.129)\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx  ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yxz  + 19.19 );\n\treturn fract( ( p3.xxy  + p3.yzz  ) * p3.zyx );\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42( vec2 p )\n{\n\tvec4 p4 = fract( vec4( p.xyxy  ) * HASHSCALE4 );\n\tp4 += dot( p4, p4.wzxy  + 19.19 );\n\treturn fract( ( p4.xxyz + p4.yzzw ) * p4.zywx );\n\n}\n\nvec2 V30 = vec2( 0.866025403, 0.5 );\nvec2 V45 = vec2( 0.707106781, 0.707106781 );\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// debug visualization\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n    vec3 x = normalize( cross( up, z ) );\n\treturn mat4( vec4( x, 0.0 ), vec4( cross( z, x ), 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n\nstruct Plane2 { vec2 base; vec2 normal; };\nstruct Plane { vec3 base; vec3 normal; };\n\nPlane2 mkplane2( vec2 base, vec2 normal ) { Plane2 plane; plane.base = base; plane.normal = normal; return plane; }\nPlane mkplane( vec3 base, vec3 normal ) { Plane plane; plane.base = base; plane.normal = normal; return plane; }\n\n// a few tediously hardcoded subdivisions that generates 4 children\n\n#define SPLIT4_BOUNDS\n\nstruct Split4\n{\n#ifdef SPLIT4_BOUNDS\n\tbounds2 b00;\n\tbounds2 b01;\n\tbounds2 b10;\n\tbounds2 b11;\n#endif\n\tvec4 d;\n};\n\nvec4 get_distances( vec2 p, Split4 split )\n{\n#if 1\n\treturn split.d;\n#else\n// should be same result\n\tvec4 d;\n\td.x = sd_bounds_range( p, split.b00.pmin, split.b00.pmax );\n\td.y = sd_bounds_range( p, split.b01.pmin, split.b01.pmax );\n\td.z = sd_bounds_range( p, split.b10.pmin, split.b10.pmax );\n\td.w = sd_bounds_range( p, split.b11.pmin, split.b11.pmax );\n\treturn d;\n#endif\n}\n\nSplit4 sd_Split_b_xxx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//  -------------------------\n//  |     |\t    |     |     |\n//  | b00 | b01 | b10 | b11 |\n//  |     |\t    |     |     |\n//  -------------------------\n//     x10     x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat x10 = mix( mi.x, x0, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n\tx10 += dx;\n\tx11 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x10 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.x - x10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyy( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//     ---------------\n//     | \t  |      |\n//     | b01  |  b11 |\n// y10 | -----|      |\n//     | \t  |------| y11\n//     | b00  |  b10 |\n//     ---------------\n//            x0\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat y11 = mix( mi.y, ma.y, s.z );\n\n#if 1\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), yset( ma, y11 ) );\n\tsplit.b11 = mkbounds_unchecked( vec2( x0, y11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.y - y11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n// \t   ------------------\n//     | b01 |     |    |\n// y10 | ----| b10 | b11|\n//     | b00 |     |    |\n// \t   ------------------\n// \t        x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\n#if 0\n// diagonal features (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal feature (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx11 += dx;\n#endif\n\n\t//\n\tSplit4 split;\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\n// that one can't be expressed as a 2 levels split, but as an incomplete level 3 (we only store 4 bounds)\nSplit4 sd_Split_b_H( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//   --------------------\n//   |     |  b10 |     |\n//   |     |\t  |     |\n//   | b00 |------| b11 | y20\n//   |     |\t  |     |\n//   |     |  b01 |     |\n//   --------------------\n//         x0    x10\n\n\t// note: we sort s.x and s.z, it make this function easier to use\n\tfloat x0 = mix( mi.x, ma.x, min( s.x, s.z ) );\n\tfloat y20 = mix( mi.y, ma.y, s.y );\n\tfloat x10 = mix( x0, ma.x, max( s.x, s.z ) );\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x0 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x0 ), vec2( x10, y20 ) );\n\tsplit.b10 = mkbounds_unchecked( vec2( x0, y20 ), xset( ma, x10 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x10 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat d0 = opI( p.x - x0, d );\n\tfloat d1 = opI( -p.x + x0, d );\n\tfloat d20 = opI( p.x - x10, d1 );\n\tfloat d21 = opI( -p.x + x10, d1 );\n\tsplit.d.x = opI( d0, p.x - x0 );\n\tsplit.d.y = opI( d20, -p.y + y20 );\n\tsplit.d.z = opI( d20, p.y - y20 );\n\tsplit.d.w = opI( d21, -p.x + x10 );\n\t//\n\treturn split;\n}\n\nstruct TechTilesArgs\n{\n\tvec4 height0, height10, height11;\n\tvec3 size0, size10, size11; //relative\n\tbool sub10, sub11; // recurse or not\n};\n\n// d stores 4 df for 4 boxes, h stored boxes height\nfloat getDist4( float z, vec4 d, vec4 h )\n{\n\tvec4 v = vec4( z ) - h;\n\treturn opU( opU( opI( v.x, d.x ), opI( v.y, d.y ) ),\n\t\t\t\topU( opI( v.z, d.z ), opI( v.w, d.w ) ) );\n}\n\n// 4 scopes output + recurse 2 of them\nfloat sd_TechTilesTestsSub( vec3 p, int lod, float t, TechTilesArgs args, float e )\n{\n\tvec4 d = vec4( FLT_MAX );\n\tvec4 heights = args.height0;\n\n//\tSplit4 b = sd_Split_b_xxx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_xyy( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\tSplit4 b = sd_Split_b_xyx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_H( p.xy,vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\n\td = get_distances( p.xy, b ) + e;\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub10 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xyy( p.xy, b.b01.pmin, b.b01.pmax, args.size10 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.y = getDist4( p.z, d2, args.height10 );\n\t\theights = max( heights, args.height10 );\n\t}\n#endif\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub11 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xxx( p.xy, b.b11.pmin, b.b11.pmax, args.size11 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.w = getDist4( p.z, d2, args.height11 );\n\t\theights = max( heights, args.height11 );\n\t}\n#endif\n\n\treturn getDist4( p.z, d, heights );\n}\n\nstruct TechTilesArgs0\n{\n\tfloat hmin;\n\tfloat hmax;\n\tfloat hdetail; // the height of sub detail\n};\n\nfloat sd_TechTilesTestsSub0( vec3 p, int lod, float t, Ray ray, vec2 index, TechTilesArgs0 targs )\n{\n\tfloat d = FLT_MAX;\n\n//\td = opI( p.z - 1.0, sd_bounds_range( p.xy, vec2( 0, 0 ), vec2( 1, 1 ) ) );\n//\treturn d;\n\n\tfloat e0 = 0.0125 * 2.0;\n\tfloat e = e0 + t * 0.001; // else e becomes 0 as far as tracing is concerned... increases cost\n\n\tTechTilesArgs args;\n\n\tvec4 ha = hash42( index );\n\tvec4 hb = hash42( index + 100.0 );\n\n\tfloat rnd_type_and_rotation = ha.w;\n\tvec3 size0_hash = ha.xyz;\n\tvec4 height0_hash = hb;\n\n\targs.sub10 = rnd_type_and_rotation < 0.6;\n\targs.sub11 = rnd_type_and_rotation < 0.3;\n\n\tfloat rota = fract( rnd_type_and_rotation * 3.0 );\n\tif ( rota < 0.25 ) p.xy = p.yx;\n\telse if ( rota < 0.5 ) p.xy = vec2( 1.0 - p.y, p.x );\n\n\tfloat m1 = 0.15;\n\targs.size0 = m1 + ( 1.0 - m1 * 2.0 ) * size0_hash; // hash32 expensive\n\n\targs.size10 = vec3( 0.25, 0.5, 0.75 );\n\targs.height10 = vec4( 1.0 );\n//\targs.height10 = hash42( index + 80.0 ) * 0.25; // don't hash all... leave splits is interesting too\n\n\targs.size11 = vec3( 0.25, 0.5, 0.5 );\n\targs.height11 = vec4( 1.0 );\n//\targs.height11 = hash42( index + 85.0 ) * 0.25;\n\n\targs.height0 = mix( vec4( targs.hmin ), vec4( targs.hmax ), height0_hash );\n\n\targs.height10 = args.height0 + targs.hdetail * args.height10;\n\targs.height11 = args.height0 + targs.hdetail * args.height11;\n\n\td = sd_TechTilesTestsSub( p, lod, t, args, e );\n\n\t// bevel\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( -V45.x, 0, V45.y ) ) );\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( 0, -V30.x, V30.y ) ) );\n\n\treturn d;\n}\n\n// feature max height will be hscale*2\nfloat sd_TechTiles( vec3 p, int lod, float t, Ray ray, TechTilesArgs0 targs, float e )\n{\n#if ( NUM_TILE_EVALS == 2 )\n\n\t// we do 2 evals in alternate checker patterns, \"only\" x2 cost and relatively clean\n\t// it still has corner cases (ha..ha..) but help in some situations\n\n\tfloat d = FLT_MAX;\n\n\tvec2 index0 = floor( p.xy );\n\tvec2 indexi = index0;\n\tfloat m = mod( indexi.x + indexi.y, 2.0 );\n\n\tvec2 dd;\n\n\tfor ( int k = 0; k < 2; k += 1 )\n\t{\n\t\tvec3 p2 = p;\n\t\tvec2 index = index0;\n\t\tp2.xy = p.xy - index;\n\n\t\tif ( m == float( k ) )\n\t\t{\n\t\t\tvec2 offset = vec2( 0.0 );\n\t\t\tvec2 rp2 = p2.xy - 0.5;\n\t\t\tif ( abs( rp2.y ) > abs( rp2.x ) ) offset.y += rp2.y > 0.0 ? 1.0 : -1.0;\n\t\t\telse offset.x += rp2.x > 0.0 ? 1.0 : -1.0;\n\t\t\tindex += offset;\n\t\t\tp2.xy -= offset;\n\t\t}\n\n\t\tfloat ddd = sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs );\n#if 0\n\t\tdd[k] = ddd; // gpu hangs on desktop (GTX 970)\n#else\n\t\tif ( k == 0 ) dd.x = ddd;\n\t\telse  dd.y = ddd;\n#endif\n\n//\t\td = ddd; // compiler bug? doesn't work on laptop...\n\t}\n\n\td = opU( dd.x, dd.y );\n\n#else\n\n\tvec3 p2 = p;\n\tvec2 index = floor( p.xy );\n\tp2.xy = p.xy - index;\n\treturn sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs  ); // only 1 eval\n\n#endif\n\n}\n\nfloat sd_DeathStarTrench( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d = FLT_MAX;\n\tfloat hw = TRENCH_HALF_WIDTH;\n\n#ifdef RAYMARCH_WITH_LOD\n\td = opU( d, p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, -p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, p.z + TRENCH_DEPTH );\n\td = opI( d, p.z );\n\tif ( abs( d ) > ROUGH_SHELL_D ) return d;\n#endif\n\n\tTechTilesArgs0 targs;\n\ttargs.hmin = 0.025;\n\ttargs.hmax = 0.30;\n\ttargs.hdetail = 0.05;\n\n\t// tiles for vertical walls\n\tTechTilesArgs0 targs_walls;\n\ttargs_walls.hmin = 0.01;\n\ttargs_walls.hmax = 0.22;\n\ttargs_walls.hdetail = 0.05;\n\n#if 1\n\t// the shallow trench rows perpendicular to the main one\n\tif ( mod( floor( p.y ), 7.0 ) == 0.0 )\n\t{\n\t\ttargs.hmax *= 0.3;\n\t\ttargs.hmin *= 0.3;\n\t\ttargs_walls.hmax *= 0.3;\n\t\ttargs_walls.hmin *= 0.3;\n\t}\n#endif\n\n\tfloat h03 = 0.0; // surface trench clamp control\n\tfloat h00 = ( targs.hmax + targs.hdetail ); // wall tile top clamp control\n\tfloat h0 = h00;\n\tfloat h1 = ( targs_walls.hmax + targs_walls.hdetail );\n\n\t// inflate more for tracing\n\th0 *= 2.0;\n\th1 *= 2.0;\n\n\tbounds2 bsides = mkbounds_unchecked( vec2( hw - h1, -TRENCH_DEPTH ), vec2( hw, h0 ) );\n\tbounds2 trench_xz = mkbounds_unchecked( vec2( -hw, -TRENCH_DEPTH ), vec2( hw, 10 ) );\n\n\tfloat e = 0.15; // 51%\n//\tfloat e = 0.25; // 75%\n\n\tbool top_layer = ( p.z > 0.0 ) && ( p.z < h0 );\n\tbool bottom_layer = ( p.z < -TRENCH_DEPTH + h0 );\n\n\tbool top_layer2 = top_layer && ( abs( p.x ) > hw - h03 );\n\tbool bottom_layer2 = bottom_layer && ( abs( p.x ) <= hw );\n\n\tfloat hoffset = top_layer2 ? 0.0 : -TRENCH_DEPTH;\n\n\ttargs.hmin += hoffset;\n\ttargs.hmax += hoffset;\n\n\t{\n\t\tfloat d1 = sd_TechTiles( p, lod, t, ray, targs, e );\n\t\td = opS( p.z, sd_bounds( p.xz, trench_xz ) );\n\n\t\tif ( top_layer2 || bottom_layer2 ) d = opU( d, d1 );\n\t}\n\n\tif ( inside( bsides, xset( p.xz, abs( p.x ) ) ) ) // perf culling\n\t{\n\t\tvec3 p2 = p.yzx;\n\t\tp2.z = abs( p2.z );\n\t\tp2.z -= hw;\n\t\tp2.z = -p2.z;\n\t\tp2.xy *= 2.0;\n\n\t\tfloat d1 = opI( p.z - TRENCH_DEPTH, sd_TechTiles( p2, lod, t, ray, targs_walls, e ) );\n\t\td1 = opI( d1, p.z - h00 * 0.45 ); // clamp top\n\t\td = opU( d1, d );\n\t}\n\n\treturn d;\n}\n\nfloat sindecay( float x, vec3 args ) { return exp( -args.x * x ) * sin( x * args.y ) * args.z; }\nfloat sindecay_derivative( float x, vec3 args ) { return ( args.y * cos( args.y * x ) - args.x * sin( args.y * x ) ) * exp( -args.x * x ) * args.z; }\n\n// function used in overshoot steps, d is the derivative of the curve at x=0, only x>0 bit is used\nfloat overshoot( float x, vec3 args, float df0 )\n{\n\tif ( x > 1.0 ) return 1.0 - sindecay( x - 1.0, args );\n\treturn cubicstep( x, df0, -sindecay_derivative( 0.0, args ) );\n}\n\n// first test, with an anticipation bump\nfloat overshootstep1( float x, vec3 args )\n{\n\tfloat df0 = 6.0;\n\tfloat s = 0.5;\n\tif ( x > 0.0 ) return 1.0 - ( 1.0 - overshoot( x, args, df0 ) ) * s;\n\treturn 1.0 - ( 1.0 + ( 1.0 - cubicstep( max( x, -1.0 ) + 1.0, 0.0, df0 ) ) ) * s;\n}\n\n// dive_step_expin_a from y0+1.0 to 0.0\n// df0 is the derivative at x=0 if we don't scale by 1/(1+y0)\n// the real derivative at 0 is a/(a+df0)\n// a controls the rate of ease in exp dive\n// same as dive_step_expin_y0( x, df0, df0/a )\nfloat overshootstep2( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : -( 1.0 - exp( x * a ) ) * y0; // look there is a smiley in that calculation\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\n// like overshootstep2 but from -inf to 1 instead of 0 to 1 (steep turn)\nfloat overshootstep3( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : 1.0 - exp( -df0 * x );\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\nfloat oversteer( float x, float a, float b, float x0 ) { return exp( -pow2( x ) * 3.0 ) - exp( -pow2( x - x0 ) * 3.0 ) * 0.5; }\n\nstruct CameraRet { vec3 eye; float roll; float pitch; vec4 debug_color; float exposure; };\n\nCameraRet init_cam()\n{\n\tCameraRet cam;\n\tcam.pitch = 0.0;\n\tcam.roll = 0.0;\n\tcam.exposure = 1.0;\n\tcam.debug_color = vec4( 0.0 );\n\treturn cam;\n}\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 )\n\t\tmm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\treturn camera * yup_spherical_offset( mm.y, mm.x );\n}\n\n// awkwardly reproduce a camera path similar to the one in the movie\nCameraRet get_camera1_movie_dive_path( float t )\n{\n\tCameraRet cam = init_cam();\n\n\t// approach curves\n\n\t// turn curve\n\tfloat x = overshootstep3( t * 0.55 - 1.4, 2.2, 6.0, vec3( 1.1, 3.0, 0.5 ) ) - 1.0;\n\n\t// descent curve\n\tfloat zz = 1.0 - overshootstep2( t * 1.0 - 2.0, 0.8, 4.0, vec3( 1.0, 1.0, 0.4 ) );\n\tfloat z = -TRENCH_DEPTH * 0.75 + zz * 5.0;\n\n\tcam.eye = vec3( -x, t * FLYING_SPEED, z );\n\n\tfloat pp = ( 1.0 - smoothstep( 0.0, 2.4, t ) );\n\tcam.pitch = -PI * 0.18 * pp;\n//\tcam.debug_color = vec4( GREEN.rgb, pp * 0.5 );\n\n\tfloat rr = oversteer( ( t - 2.7 ), 0.3, 0.3, 1.0 );\n\tcam.roll -= -rr * PI * 0.2;\n//\tcam.debug_color = vec4( RED.rgb, rr*0.5 );\n\n\tcam.eye.z += 0.2 * sin( t * 2.0 );\n\n\tcam.eye.x += ( 0.4 * TRENCH_HALF_WIDTH * sin( t * 1.0 ) ); // left right amplitude\n//\tcam.roll -= 0.2 * cos( t * 1.0 + 0.25 ); // steering roll (anticipates, derivative)\n\tcam.roll += 0.05 * sin( t * 2.0 ); // noise roll\n\n\t// occasional jumps\n\tcam.eye.z += ( 1.0 - ( 1.0 + cos( PI * spaced_tri( t * 0.2, 4.0, 0.5 ) ) ) * 0.5 ) * 7.0;\n\n\tcam.exposure = mix( 0.57*7., 0.18*7., smoothstep( -1.0, 2.0, cam.eye.z ) );\n\treturn cam;\n}\n\nmat4 get_camera1_movie_dive( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera1_movie_dive_path( t + 0.05 ).eye;\n\tCameraRet cam = get_camera1_movie_dive_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy );\n}\n\nCameraRet get_camera2_path( float t )\n{\n\tt *= 0.4; // slow down\n\tCameraRet cam = init_cam();\n\tcam.exposure = 0.35*7.;\n\tcam.roll -= cos( t + 0.25 ) * 0.175;\n\tcam.pitch -= PI * 0.2;\n\tfloat xpos_max = 2.5;\n\tfloat ypos = t * FLYING_SPEED;\n\txpos_max += ( 1.0 + sin( t * 0.05 ) * 0.5 ) * 2.0;\n\tcam.eye = vec3( xpos_max * sin( t ), ypos, 2.75 );\n\treturn cam;\n}\n\nmat4 get_camera2( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera2_path( t + 0.02 ).eye;\n\tCameraRet cam = get_camera2_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch - PI * 0.08, tan_half_fovy );\n}\n\n// plane base 0,0,pz plane normal 0,0,nz\nvec2 intersect_plane2_nz( Ray ray, float pz, float nz )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.z * nz;\n\tfloat d = ( ray.o.z - pz ) * nz;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// plane base 0,0,px plane normal 0,0,nx\nvec2 intersect_plane2_nx( Ray ray, float px, float nx )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.x * nx;\n\tfloat d = ( ray.o.x - px ) * nx;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// turn t (result of intersect_plane* functions) into a negative space range\nvec2 mm3( vec2 t ) { return t.y * t.x > 0.0 ? vec2( t.x, FLT_MAX ) : vec2( -FLT_MAX, t.x ); }\n\n// intersect 2 negative space ranges, assume convex\nvec2 mm4( vec2 a, vec2 b ) { return vec2( max( a.x, b.x ), min( a.y, b.y ) ); }\n\n// raytrace to get a better first march distance\nfloat warpTrace( Ray ray )\n{\n\tvec2 t0 = intersect_plane2_nz( ray, ROUGH_SHELL_D, 1.0 );\n\tvec2 t1 = intersect_plane2_nx( ray, -TRENCH_HALF_WIDTH + ROUGH_SHELL_D, 1.0 );\n\tvec2 t2 = intersect_plane2_nx( ray, TRENCH_HALF_WIDTH - ROUGH_SHELL_D, -1.0 );\n\tvec2 t3 = intersect_plane2_nz( ray, -TRENCH_DEPTH + ROUGH_SHELL_D, 1.0 );\n\tfloat d = opU( opU( opI( t0.y, t1.y ), opI( t0.y, t2.y ) ), t3.y );\n\tif ( d < 0.0 ) return 0.0; // we are inside... do nothing and gtfo\n\tvec2 r0 = mm3( t0 );\n\tvec2 r01 = mm4( r0, mm3( t1 ) );\n\tvec2 r02 = mm4( r0, mm3( t2 ) );\n\tvec3 dd = vec3( FLT_MAX );\n\tif ( r01.x != FLT_MAX && r01.y > r01.x && r01.x > 0.0 ) dd.x = r01.x;\n\tif ( r02.x != FLT_MAX && r02.y > r02.x && r02.x > 0.0 ) dd.y = r02.x;\n\tif ( t3.x != FLT_MAX && t3.x > 0.0 ) dd.z = t3.x;\n\treturn mincomp( dd );\n}\n\nfloat sd_Scene( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d1 = FLT_MAX;\n\tfloat d2 = FLT_MAX;\n#ifdef PRIMITIVES\n// was for simple check lighting (need disable shadow hacks)\n\td1 = opU( sd_bounds_range( p, -vec3( 1. ), vec3( 1. ) ), length( p - vec3( 0., 3., 0. ) ) - 1. );\n#endif\n#ifdef SORT_OF_MOON\n\td2 = sd_DeathStarTrench( p, lod, t, ray );\n#endif\n\treturn opU( d1, d2 );\n}\n\nstruct TraceOutput\n{\n\tfloat t; // ray travel distance\n\tfloat num_iterations;\n\tfloat dist; // \"hit\" point distance to surface\n\tfloat shadow;\n};\n\nvec3 sd_SceneGrad( vec3 p, int lod, TraceOutput to, Ray ray )\n{\n\t// if p is far away the epsilon will vanish in the addition and normal calculation will be broken\n\t// this was to keep the gradient working even at large-ish distances...\n//\tvec3 h = max( vec3( 0.006 ), abs( p ) * 1e-6 );\n\tvec3 h = vec3( 0.001 );\n\tvec3 n = normalize( vec3( sd_Scene( p + vec3( h.x, 0.0, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, h.y, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, 0.0, h.z ), lod, to.t, ray ) ) - to.dist ); // to.dist == sd_Scene( p, lod, to.t, ray ), our last eval \n\t// if the normal is backfacing, our point p is likely behind an occluded object (a thin object or an edge we accidentally traced through)\n\t// this creates distracting salt noise that makes certain lighting components unstable (fresnel)\n\t// if we care the simplest hack to do that attenuates the artifacts in our scene is to negate\n\treturn dot( n, ray.d ) > 0.0 ? -n : n;\n}\n\nTraceOutput traceScene( Ray ray, int lod, float shadow_sharpness, float tmax, bool warp_trace, float max_iterations )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n#ifdef RAYTRACE_FIRST_MARCH_DISTANCE\n\tif ( warp_trace ) { to.t += warpTrace( ray ); if ( to.t == FLT_MAX ) return to; } // jump close to first hit\n#endif\n\n\tfor ( int i = 0; i < MAX_ITERATIONS; ++i )\n\t{\n\t\tfloat d = sd_Scene( ray.o + to.t * ray.d, lod, to.t, ray );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > tmax ) break;\n\t\tto.shadow = min( to.shadow, shadow_sharpness * to.dist / to.t ); // iq's awesome trick https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\tto.t += to.dist * TFRAC;\n\t\tto.num_iterations += 1.0;\n\t\tif ( to.num_iterations >= max_iterations ) break;\n\t}\n\n\tto.shadow = max( 0.0, to.shadow ); // fixes some artifacts\n\treturn to;\n}\n\nfloat star_glare( float x, float e, float c ) { return exp2( -pow( x, e ) * c ); }\n\n// black body color adapted from Fabrice Neyret's https://www.shadertoy.com/view/4tdGWM\n// T absolute temperature (K), m1 is a 0,1 param that controls output scale\nvec3 black_body( float T, float m1 )\n{\n\tfloat m = .01 + 5. * m1;\n\tvec3 f = vec3( 1. ) + 0.5 * vec3( 0., 1., 2. );\n\tfloat Trcp = 1. / T;\n\treturn ( 10. / m * ( f * f * f ) ) / ( exp( ( 19e+3 * f * Trcp ) ) - 1. );  // Planck law\n}\n\n// assumes x 0,1 maps to 24e+2, 30e+3\n#define FF 24.\n// vaguely use this distribution there https://en.wikipedia.org/wiki/Stellar_classification\nfloat Tprob2( float x ) { return exp( -x * FF ); }\nfloat Tprob2_int( float x ) { return -exp( -x * FF ) * ( 1.0 / FF ); }\nfloat Tprob2_int_inv( float x ) { return -log( -x * FF ) * ( 1.0 / FF ); }\n#if 0\nfloat cdf( float x ) { return Tprob2_int( x ) - Tprob2_int( 0. );}\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + Tprob2_int( 0. ) ); }\n#else\nfloat cdf( float x ) { return Tprob2_int( x ) - ( -1. / FF ); } // hardcode the function\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + ( -1. / FF ) ); }\n#endif\n\nvec3 star_color( float x ) { return black_body( mix( 24e+2, 30e+3, x ), 1. ); }\n\n#ifdef STARFIELD\n// stars are clamped on their cell borders (we don't bother iterating neighbours)\nvec3 starfield( vec3 viewvec )\n{\n\tvec2 num = vec2( 1.0, 2.0 ) * 250.0;\n\tfloat theta = acos( viewvec.z );\n\tfloat phi = calc_angle( viewvec.xy );\n\tif ( phi < 0.0 ) phi += 2.0 * PI;\n\tvec2 sc = vec2( theta, phi );\n\tvec2 scd = vec2( 1.0, 2.0 ) * PI / num;\n\tvec2 sci = floor( sc / scd ); // if ( mod( sci.x + sci.y, 2.0 ) == 1.0 ) return RED;\n\tvec2 scf = ( sc - sci * scd ) / scd; //\treturn vec3( scf, 0.0 ); // view cells\n//\tvec4 r = vec4(0.5); // aligned stars\n\tvec4 r = hash42( sci ); //\treturn vec3( r ); // color cell by hash\n\tvec2 scc = ( ( sci + 0.5 ) * scd ); // cell center\n\tvec2 r2 = hash22( sci ); //\treturn vec3( r2.y ); // debug // x: discard probability, y: color distribution uniform input\n\tif ( r2.x > sin( scc.x ) ) return BLACK; // randomly decimate in sin theta fashion for something uniform-ish\n//\tif ( r2.x > sin( scc.x ) ) return RED; // visualize the decimation\n\tvec2 sc2 = ( ( sci + r.xy ) * scd ); // cell center\n\tvec3 v = zup_spherical_coords_to_vector( sc2.x, sc2.y ); // return v;\n\tv = normalize( v ); // we also need to renormalize already normal vector here else broken on GTX1060 laptop\n\tfloat c = 1.0 - dot( v, viewvec ); // return vec3( 1.0 - smoothstep( 0.0, 1.0, c ) ); // debug: show the full disks (max glow radius) // 0->2\n\tvec3 col = star_color( cdf_inv( r2.y * cdf( 1. ) ) ); // return vec3( chrominance( col ) );\n#if 1\n\tc *= 1e+6;\n\tcol = mix( col, vec3( maxcomp( col ) ), 0.5 ); // after all those efforts we lerp towards monotone... :-]\n\treturn star_glare( c * 0.0095, 0.8, 80.0 ) * col * 1.5; // fixme: make the radius resolution/fovy dependent \n//\treturn star_glare( c * 0.01, mix( 0.4, 0.8, r.w ), mix( 30.0, 60.0, r.z ) ) * col * 120.; // manual glow;\n#else\n// with larger glares and plausible star colors it starts to look like space photos a bit (maybe)\n\tc *= 6e+4;\n\treturn star_glare( c, mix( 0.3, 0.8, r.w ), mix( 3.0, 6.0, r.z ) ) * col * 80.; // manual glow;\n#endif\n}\n#endif\n\nvoid build_onb( vec3 z, vec3 x0, out vec3 x, out vec3 y ) { y = normalize( cross( x0, z ) ); x = normalize( cross( z, y ) ); }\n\nvec3 sunval( float sun_dp, vec2 p, vec3 sun_color, vec3 sun_color_c )\n{\n\tfloat r = ( ( -sun_dp + 1. ) * 0.5 ) * 300.0;\n\tfloat f = 0.;\n#if 1\n// flares\n\tfloat a = calc_angle( p );\n\tfloat da = 2.0 * PI / 6.0;\n\tfloat a0 = floor( a * ( 1.0 / da ) ) * da;\n\tvec2 va0 = perp( unit_vector2( a0 ) );\n\tvec2 va1 = -perp( unit_vector2( a0 + da ) );\n\tvec2 d = vec2( dot( va0, p ), dot( va1, p ) );\n\tfloat f0 = opU( d.x, d.y );\n\tf = f0 * 8.;\n\tf += 1.0 - exp( -r * 0.01 ) * 0.85;\n\tf = 1. / ( 0.01 + f * 50. );\n\tf *= 0.125;\n#endif\n\treturn 2. * sun_color * star_glare( max( 0.0, r - 0.17 ) * 0.075, 0.35, 24.0 ) + f * sun_color_c;\n}\n\n// I used a bit of pbr reference to see what happens (don't worry it all deteriorates into sad hacks pretty quickly)\n// https://learnopengl.com/#!PBR/Theory\n// http://graphicrants.blogspot.jp/\n// alpha = roughness * roughness\nfloat D_blinn_phong( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return pow( m_dot_n, ( 2. / alpha_sqr ) - 2. ) / ( PI * alpha_sqr ); }\nfloat D_beckmann( float m_dot_n, float alpha )\n{\n\tfloat alpha_sqr = alpha * alpha;\n\tfloat m_dot_n_sqr = m_dot_n * m_dot_n;\n\treturn exp( ( m_dot_n_sqr - 1. ) / ( alpha_sqr * m_dot_n_sqr ) ) / ( PI * alpha_sqr * m_dot_n_sqr * m_dot_n_sqr );\n}\n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_implicit( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v; }\nfloat G_neumann( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v / max( n_dot_l, n_dot_v ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v / pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, float Li, float dwi, float kdiffuse, float kspecular )\n{\n\tfloat F0 = 0.08;\n\tfloat roughness = 0.25;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; // else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat l_dot_h = max( eps, dot( l, h ) );\n\n//\tfloat D = D_blinn_phong( n_dot_h, alpha ); // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n//\tfloat D = D_beckmann( n_dot_h, alpha );\n\tfloat D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n\n//\tfloat G = G_implicit( n_dot_l, n_dot_v );\n\tfloat G = G_neumann( n_dot_l, n_dot_v );\n//\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n\n//\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\n\treturn  ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\nfloat penumbra_sun( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 1.9 ); } // darker/narrower\n//float penumbra_sun( float x ) { x = max( -x, 0.0 ); return exp2( -x * iSlider0 * 10. ); } // brighter/wider\nfloat penumbra_bounce( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 0.2 ); } // darker/narrower\n//float penumbra_bounce( float x ) { x = max( x, 0.0 ); return x = exp2( -x * 1.4 ); } // brighter/wider\n\n// e = eye pos, v = vader vector, p = lit point, n = normal, l = sun direction\nvec3 shade( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t, float traced_shadow, float sun_shadow, float first_bounce\n\t\t\t, TraceOutput to, float ao, float exposure, vec2 uv )\n{\n\tvec3 col = vec3( 0. );\n\tbool sky = to.t > TMAX;\n\n//\treturn sky ? BLACK : ( vec3( 1.0 ) + n ) * 0.5; // normal debug color\n//\treturn vec3( 1.0 - exp( -to.t * 0.15 ) ); // distance to hit point\n//\treturn viridis_quintic( to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) ) ); // visualize the number of iterations\n//\treturn viridis_quintic( to.dist / ( DBREAK * to.t ) );\n//\treturn viridis_quintic( to.dist );\n//\treturn viridis_quintic( ao );\n\n\tvec3 sun_color = black_body( 19000.0, 0.8 );\n\tvec3 sun_color_c = chrominance( sun_color );\n\tvec3 albedo = vec3( 0.85, 0.85, 1 );\n#ifdef COLOR_TILES\n\talbedo = mix( vec3( 0.2 ), vec3( 1.0 ), hash32( floor( p.xy ) ) );\n#endif\n\n\tif ( !sky )\n\t{\n\t\tfloat iter = to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) );\n\t\tfloat fog_start = 30.0;\n\t\tfloat fog = exp2( -max( to.t - fog_start, 0.0 ) * 0.02 ); // this is mostly to fade the horizon\n\t\tfloat ao_z = 1.0 - saturate( abs( p.z * ( 1.0 / TRENCH_DEPTH ) ) ); // vertical occlusion\n\t\tfloat kdiffuse = 0.75;\n\t\tfloat kspecular = 1.0;\n\t\tfloat sunI = 2.2;\n\t\tfloat kambient = 0.005;\n\t\tfloat shadow = min( traced_shadow, sun_shadow );\n\n//\t\treturn vec3( shadow );\n//\t\tn = normalize( n + 0.07 * l ); // soften a bit\n#if 1\n // main sun light\n\t\tcol += add_light_contrib( albedo, l, n, -v\n\t\t\t\t\t\t\t\t  , sunI * mix( 0.0, 1., ao_z ) * mix( 0., 1., shadow )\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// dummy secondary source\n\t\tvec3 l2 = normalize( vec3( 5, -5.5, 10 ) );\n\t\tcol += add_light_contrib( albedo, l2, n, -v\n\t\t\t\t\t\t\t\t  , 0.34 * mix( 0.08, 1., ao_z ) * ao\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// first bounce\n\t\tcol += add_light_contrib( albedo, reflect( l, vec3( -1., 0., 0. ) ), n, -v\n\t\t\t\t\t\t\t\t  , first_bounce\n\t\t\t\t\t\t\t\t  , 0.05\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z );\n#endif\n#if 1\n// ambient\n\t\tcol += PI * vec3( kambient * ao_z * ao );\n#endif\n#if 1\n// random crap\n\t\tcol *= fog * ao * ao * ( 1. - iter * 0.7 );\n#endif\n\t}\n\telse\n\t{\n\t\tcol = vec3( 0. );\n\n#ifdef SUN\n\t\tvec3 sx, sy;\n\t\tbuild_onb( l, cam[0].xyz, sx, sy ); // we want the flares to be viewspaceish\n\t\tcol += sunval( dot( l, v ), vec2( dot( v, sx ), dot( v, sy ) ), sun_color, sun_color_c );\n#endif\n\n#ifdef STARFIELD\n\t\tcol += starfield( v );\n#endif\n\t}\n\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.015 ) ) );\n\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); \n\tcol *= vignette;\n\n\tcol = gamma_correction_itu( col );\n//\tcol = gamma_correction( col );\n\n\treturn col;\n}\n\n// black -> green -> white gradient\nvec3 laser_heatmap( float u ) { float r = 0.5; vec3 c = vec3( smoothbump( r * float( 2.0 ), r, u ) ); c.g += smoothbump( r * float( 1.0 ), r, u ); return c; }\n\n#define LASER_LEN 1.5\n#define LASER_LEN_RCP (1.0/(LASER_LEN))\n#define LASER_SPEED (60.0)\n// spawn at player + that\n#define LASER_SPAWN_DISTANCE (40.0)\n#define LASER_PERIOD (LASER_SPAWN_DISTANCE*2.0/(FLYING_SPEED+LASER_SPEED))\n\n// for lasers capsules...\nvec2 sphere_trace( vec2 O, vec2 d, float radius, vec2 C )\n{\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec2 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n// laser code is total bloat, we raytrace infinite cylinders and integrate something\n// volumetric along a fixed number of steps between the 2 intersections, when they exist\nvec3 lasers( Ray view_ray, float hs, float time, float t0 )\n{\n\tfloat fade = 1.0 - smoothstep( -TRENCH_DEPTH * 0.05, 0.0, view_ray.o.z );\n\tfloat pos = FLYING_SPEED * time; // camera pos\n\tfloat laser_period = LASER_PERIOD * FLYING_SPEED;\n\tfloat offset = hs * 5.0;\n\tfloat nth = floor( ( pos - offset ) / laser_period );\n\tfloat y0 = offset + nth * laser_period + LASER_SPAWN_DISTANCE;\n\tfloat yy_t = ( pos - ( offset + nth * laser_period ) ) * ( 1.0 / FLYING_SPEED );\n\tfloat laser_pos = y0 - yy_t * LASER_SPEED;\n\tvec2 orig = hash21( nth * hs );\n\tfloat w2 = TRENCH_HALF_WIDTH * 0.8;\n\torig = mix( vec2( -w2, -TRENCH_DEPTH * 0.9 ), vec2( w2, -TRENCH_DEPTH * 0.3 ), orig );\n\tfloat r = 0.085;\n\tvec3 color = BLACK;\n\n\t//todo: case when we are inside the laser\n\tfloat vzx1len = length( view_ray.d.zx );\n\tvec2 vzx1 = view_ray.d.zx / vzx1len;\n\tvec2 st = sphere_trace( view_ray.o.zx, vzx1, r, vec3( orig.x, 0, orig.y ).zx );\n\tif ( st.x == FLT_MAX || // no hit\n\t\t st.y < 0.0 ) // hitting behind the camera\n\t\t\t\t\t  // we don't intersect the laser cylinder, gtfo\n\t\treturn color;\n\n\tvec3 cacc = vec3( 0.0);\n\tfloat aacc = 0.0;\n\n\tfloat vzx1len_rcp = 1.0 / vzx1len;\n\tfloat t00 = st.x * vzx1len_rcp;\n\tfloat t11 = st.y * vzx1len_rcp;\n\n#define LASER_ITER 20.0\n\tfor ( float i = 0.0; i <= LASER_ITER; i += 1.0 )\n\t{\n\t\tfloat x = i * ( 1.0 / LASER_ITER );\n\t\tfloat t = t00 + ( t11 - t00 ) * cubicstep(  x, 2.5, 2.5 ); // smaller steps near the center to better capture the gradient\n\t\tvec3 p = view_ray.o + t * view_ray.d;\n\t\tvec3 vzx = p - project_on_liney( p, vec3( orig.x, 0, orig.y ) );\n\t\tvec3 pl = p;\n\t\tpl.y -= laser_pos; // local\n\t\tfloat ri = length( vzx );\n\t\tif ( pl.y > LASER_LEN - r ) ri = length( pl - vec3( orig.x, LASER_LEN - r, orig.y ) );\n\t\telse if ( pl.y < -LASER_LEN + r ) ri = length( pl - vec3( orig.x, -LASER_LEN + r, orig.y ) );\n\t\tfloat ddx = 1.0 - saturate( ri * ( 1.0 / r ) );\n\t\tfloat xxx = pl.y * LASER_LEN_RCP;\n\t\tddx *= box( xxx ) * fade;\n\t\tvec3 emission = laser_heatmap( ddx ) * 0.2;\n\t\tfloat opacity = saturate( ddx * 0.1 );\n\t\tcacc += ( 1.0 - aacc ) * emission;\n\t\taacc += ( 1.0 - aacc ) * opacity; // http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch39.html\n\t}\n\n\tcolor = cacc;\n\tcolor = cacc * aacc;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( 0., 0., 0., 1 );\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n//\tfragColor.xyz = star_color( uv.x ).xyz; return;\n//\tfragColor.xyz = laser_heatmap( uv.x ); return;\n\n\tfloat tan_half_fovy = 0.6;\n\tfloat znear = 0.1;\n\tvec4 debug_color = vec4( 1.0, 1.0, 1.0, 0.0 );\n\tfloat time = iTime + TIME_OFFSET;\n\tfloat fade = 1.0;\n\tfloat exposure = 1.0;\n\tmat4 camera;\n\n#ifdef EXTRA_3D_CAMERA\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\ttan_half_fovy = iTanHalfFovy;\n\texposure = iExposure;\n#else\n\t{\n\t\tfloat time_slice = 30.0;\n#ifdef CAMERA_REPEAT\n\t\tfloat camera_select = mod( floor( time / time_slice ), 2.0 );\n\t\tfloat time_slice_r = 0.25;\n\t\tfade = 1.0 - min( spaced_bumps( time, time_slice, time_slice_r ), 1.0 - box( time / time_slice_r ) );\n\t\ttime = mod( time, time_slice );\n#else\n\t\tfloat camera_select = 0.0;\n#endif\n\t\tif ( camera_select == 0.0 ) camera = get_camera1_movie_dive( camera, tan_half_fovy, time, debug_color, exposure );\n\t\telse camera = get_camera2( camera, tan_half_fovy, time + CAM2_TIME_OFFSET, debug_color, exposure );\n\t}\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0.0 ) ).xyz;\n\tview_ray.d = normalize( view_ray.d ); // have to renormalize this already normalized (yey!) vector here else lasers are broken (only on laptop GTX1060)\n\n\tTraceOutput to = traceScene( view_ray, 0, 15.0, TMAX, true, float( MAX_ITERATIONS ) );\n\n\tvec3 l = normalize( vec3( -8, 0, 5.2 ) ); // careful with z, long shadows make the tracing slower\n\tvec3 p = view_ray.o + to.t * view_ray.d;\n\tvec3 n = sd_SceneGrad( p, 0, to, view_ray );\n\n\tfloat ao = 1.0;\n\n#ifdef AO\n\t{\n\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\tfloat delta = 0.1;\n\t\tfloat a = 0.0;\n\t\tfloat b = 1.0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n//\t\t\tif ( to.t > 30 ) break;\n\t\t\tfloat fi = float( i );\n\t\t\tfloat d = sd_Scene( p + delta * fi * n, 0, to.t, view_ray );\n\t\t\ta += ( delta * fi  - d ) * b;\n\t\t\tb *= 0.5;\n\t\t}\n\t\tao = saturate( 1.0 - 1.2 * a );\n\t\t// note: had to lower DBREAK inorder to avoid ugly patterns when far away from surface\n\t}\n#endif\n\n\tbool sky = to.t > TMAX;\n\n\tfloat sun_shadow = 1.0; // shadow\n\tfloat first_bounce = 0.0; // first light bounce (illuminates the bottom left corner)\n\tfloat traced_shadow = 1.0;\n\n\tif ( !sky )\n\t{\n#ifdef TRACED_SHADOW\n\t\tfloat expensive_shadow_dist = 40.0;\n\t\tif ( to.t < expensive_shadow_dist )\n\t\t{\n\t\t\tRay sray;\n\t\t\tsray.o = p + n * 0.1 * 1.0;\n\t\t\tsray.d = l;\n\n\t\t\tTraceOutput tos = traceScene( sray, 0, 15.0, 10.0, false, 20.0 );\n\t\t\ttraced_shadow = tos.shadow;\n\t\t\ttraced_shadow += smoothstep( expensive_shadow_dist - 2.0, expensive_shadow_dist, to.t );\n\t\t\ttraced_shadow = saturate( traced_shadow );\n\t\t}\n#endif\n\t\tvec2 l2 = normalize( l.xz );\n\t\tvec2 l2r = reflect( l2, vec2( -1, 0 ) );\n\t\tfloat so = 0.0; // shadow plane offset from z=0\n\t\tPlane2 pl1 = mkplane2( vec2( -TRENCH_HALF_WIDTH, so ), -perp( l2 ) );\n\t\tPlane2 pl2 = mkplane2( vec2( TRENCH_HALF_WIDTH, so ), -perp( l2r ) );\n\t\tPlane2 pl3 = pl2;\n\t\tpl3.normal = -pl3.normal;\n\t\tpl3.base.y += ( l2.y / l2.x ) * 2.0 * TRENCH_HALF_WIDTH;\n\n\t\tif ( ( abs( p.x ) < TRENCH_HALF_WIDTH ) && ( p.z < so ) )\n\t\t{\n#ifdef ANALYTICAL_SHADOW\n\t\t\tsun_shadow = penumbra_sun( dot( p.xz - pl1.base, pl1.normal ) );\n#endif\n\t\t\tfirst_bounce = penumbra_bounce( min( dot( p.xz - pl2.base, pl2.normal ),\n\t\t\t\t\t\t\t\t\t\t\t\t dot( p.xz - pl3.base, pl3.normal ) ) );\n\n\t\t\tfirst_bounce *= step( p.x, TRENCH_HALF_WIDTH - 0.5 ) * step( p.z, 0.0 );\n\t\t}\n\t}\n\n\tfragColor.rgb = shade( view_ray.o, view_ray.d, camera, p, n, l\n\t\t\t\t\t\t   , traced_shadow, sun_shadow, first_bounce, to, ao, exposure, uv );\n#ifdef LASERS\n\tfragColor.rgb += lasers( view_ray, 0.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, 1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -0.5, time, to.t );\n\tfragColor.rgb += lasers( view_ray, +0.5, time, to.t );\n#endif\n\tfragColor.rgb *= fade;\n\tfragColor.rgb = mix( fragColor.rgb, debug_color.rgb, debug_color.a );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}