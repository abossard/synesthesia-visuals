#define PROCESSING_COLOR_SHADER
// RingLattice_Organic - Living, breathing structure that pulses
// Based on RGBringlattice3D

#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

uniform float bass;
uniform float mid;
uniform float highs;
uniform float level;
uniform float kickEnv;
uniform float speed;
uniform float energySlow;

// Smooth noise for organic deformation
float hash(vec3 p) {
    p = fract(p * 0.3183099 + 0.1);
    p *= 17.0;
    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    
    return mix(
        mix(mix(hash(i + vec3(0, 0, 0)), hash(i + vec3(1, 0, 0)), f.x),
            mix(hash(i + vec3(0, 1, 0)), hash(i + vec3(1, 1, 0)), f.x), f.y),
        mix(mix(hash(i + vec3(0, 0, 1)), hash(i + vec3(1, 0, 1)), f.x),
            mix(hash(i + vec3(0, 1, 1)), hash(i + vec3(1, 1, 1)), f.x), f.y), f.z);
}

// Organic deformation - makes structure breathe
vec3 organicDeform(vec3 p, float intensity) {
    float t = time * 0.5;
    
    // Slow breathing motion
    float breath = sin(t * 0.8) * 0.5 + 0.5;
    breath += bass * 0.3;  // React to bass
    
    // Wave displacement
    vec3 wave;
    wave.x = sin(p.y * 0.1 + t) * sin(p.z * 0.1 + t * 0.7);
    wave.y = sin(p.x * 0.1 + t * 0.8) * sin(p.z * 0.1 + t * 0.6);
    wave.z = sin(p.x * 0.1 + t * 0.6) * sin(p.y * 0.1 + t * 0.9);
    
    // Noise-based displacement
    vec3 noiseDisp;
    noiseDisp.x = noise(p * 0.05 + t * 0.2) - 0.5;
    noiseDisp.y = noise(p * 0.05 + t * 0.2 + 100.0) - 0.5;
    noiseDisp.z = noise(p * 0.05 + t * 0.2 + 200.0) - 0.5;
    
    return p + (wave * 3.0 + noiseDisp * 5.0) * intensity * (0.5 + breath * 0.5);
}

float pointToGrille(vec3 pp, float b, float r) {
    vec3 p = abs(pp);
    vec3 pa = mod(p, 2.0 * b) - b;
    
    float dy = length(vec2(b - length(pa.xz), pa.y));
    float dz = length(vec2(b - length(pa.xy), pa.z));
    float ddy = length(vec3(pa.x, pa.z, pa.y * step(0.0, pa.y)));
    float ddz = length(vec3(pa.x, pa.y, pa.z * step(0.0, pa.z)));
    
    return min(min(dy, ddy), min(dz, ddz)) - r;
}

vec3 rotor(vec3 p) {
    float co = time * 0.06;
    float c = cos(co);
    float s = sin(co);
    mat3 mz = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);
    mat3 mx = mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);
    return p * mz * mx;
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.1, 0.0);
    vec3 pd = organicDeform(rotor(p), 1.0);
    float d = pointToGrille(pd, 14.0, 0.8);
    return normalize(vec3(
        pointToGrille(organicDeform(rotor(p + e.xyy), 1.0), 14.0, 0.8) - d,
        pointToGrille(organicDeform(rotor(p + e.yxy), 1.0), 14.0, 0.8) - d,
        pointToGrille(organicDeform(rotor(p + e.yyx), 1.0), 14.0, 0.8) - d
    ));
}

float render(vec3 org, vec3 dir, out vec3 hitNormal) {
    float lambda = 0.0;
    float lamb = 100.0;
    float couleur = 0.0;
    
    // Ring size pulses with audio
    float ringSize = 0.7 + sin(time * 2.0) * 0.1 + bass * 0.3;
    float cellSize = 14.0 + sin(time * 0.3) * 2.0;
    
    for(int i = 0; i < 80; i++) {
        vec3 pos = org + lambda * dir;
        vec3 deformed = organicDeform(rotor(pos), 1.0);
        lamb = pointToGrille(deformed, cellSize, ringSize);
        lambda += lamb * 0.8;
        couleur += 0.012;
        if(abs(lamb) < 0.01 || lambda > 250.0) {
            hitNormal = getNormal(pos);
            break;
        }
    }
    return clamp(couleur * 1.2, 0.0, 1.0);
}

void main(void) {
    vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
    uv.x *= resolution.x / resolution.y;
    
    float t = time * (0.25 + speed * 0.2);
    
    // Organic camera motion
    vec3 eye = vec3(
        sin(t * 0.3) * 120.0 + sin(t * 0.7) * 30.0,
        cos(t * 0.25) * 100.0 + cos(t * 0.6) * 20.0,
        t * 35.0
    );
    
    vec3 dir = normalize(rotor(vec3(uv.x, uv.y, 1.3)));
    
    vec3 hitNormal;
    float coul = render(eye, dir, hitNormal);
    
    // Organic color palette - flesh tones, corals, deep reds
    vec3 baseColor = vec3(0.8, 0.4, 0.3);   // Coral
    vec3 deepColor = vec3(0.4, 0.1, 0.15);  // Deep red
    vec3 highlightColor = vec3(1.0, 0.8, 0.7); // Pale pink
    
    // Subsurface scattering approximation
    float sss = pow(1.0 - coul, 2.0);
    vec3 sssColor = vec3(0.8, 0.2, 0.1) * sss * 0.5;
    
    // Lighting
    vec3 lightDir = normalize(vec3(0.5, 0.8, 0.3));
    float diffuse = max(dot(hitNormal, lightDir), 0.0);
    float rim = pow(1.0 - max(dot(hitNormal, -dir), 0.0), 3.0);
    
    // Color mixing
    vec3 color = mix(deepColor, baseColor, diffuse);
    color += highlightColor * rim * 0.4;
    color += sssColor;
    color *= 1.0 - coul * 0.4;
    
    // Pulse with bass
    float pulse = sin(time * 3.0) * 0.5 + 0.5;
    color += vec3(0.3, 0.05, 0.0) * bass * pulse;
    
    // Vein-like details (noise-based)
    float veins = noise(dir * 20.0 + time * 0.5);
    veins = smoothstep(0.4, 0.6, veins);
    color = mix(color, deepColor, veins * 0.3 * (1.0 - coul));
    
    // Warm ambient
    color += vec3(0.1, 0.05, 0.03) * (1.0 - coul);
    
    // Soft vignette
    float vignette = 1.0 - pow(length(uv) * 0.9, 2.0);
    color *= vignette;
    
    gl_FragColor = vec4(color, 1.0);
}
