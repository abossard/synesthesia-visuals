#define PROCESSING_COLOR_SHADER
// RingLattice_Flyover - Top-down flight over infinite ring landscape
// Based on RGBringlattice3D

#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;

uniform float bass;
uniform float mid;
uniform float highs;
uniform float level;
uniform float kickEnv;
uniform float speed;

float pointToGrille(vec3 pp, float b, float r) {
    vec3 p = abs(pp);
    vec3 pa = mod(p, 2.0 * b) - b;
    
    float dy = length(vec2(b - length(pa.xz), pa.y));
    float dz = length(vec2(b - length(pa.xy), pa.z));
    float ddy = length(vec3(pa.x, pa.z, pa.y * step(0.0, pa.y)));
    float ddz = length(vec3(pa.x, pa.y, pa.z * step(0.0, pa.z)));
    
    return min(min(dy, ddy), min(dz, ddz)) - r;
}

// Ground plane for flyover
float sdGround(vec3 p) {
    return p.y + 50.0;
}

float map(vec3 p) {
    float lattice = pointToGrille(p, 15.0, 0.5 + bass * 0.4);
    float ground = sdGround(p);
    return min(lattice, ground);
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.01, 0.0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

float render(vec3 org, vec3 dir, out vec3 hitPos, out vec3 normal) {
    float lambda = 0.0;
    float lamb = 100.0;
    float ao = 0.0;
    
    for(int i = 0; i < 100; i++) {
        vec3 pos = org + lambda * dir;
        lamb = map(pos);
        lambda += lamb * 0.8;
        ao += 0.01;
        if(abs(lamb) < 0.001 || lambda > 500.0) {
            hitPos = pos;
            normal = getNormal(pos);
            break;
        }
    }
    return clamp(ao, 0.0, 1.0);
}

void main(void) {
    vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
    uv.x *= resolution.x / resolution.y;
    
    float t = time * (0.3 + speed * 0.4);
    
    // Flyover camera - high up, looking down-forward
    vec3 eye = vec3(
        sin(t * 0.2) * 100.0,
        80.0 + sin(t * 0.3) * 30.0,  // Height varies
        t * 80.0
    );
    
    // Looking mostly forward and slightly down
    vec3 target = eye + vec3(sin(t * 0.15) * 20.0, -40.0, 100.0);
    vec3 forward = normalize(target - eye);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = cross(forward, right);
    
    vec3 dir = normalize(uv.x * right + uv.y * up + 1.2 * forward);
    
    vec3 hitPos, normal;
    float ao = render(eye, dir, hitPos, normal);
    
    // Sun direction
    vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
    float sunLight = max(dot(normal, sunDir), 0.0);
    float rimLight = pow(1.0 - max(dot(normal, -dir), 0.0), 3.0);
    
    // Sky gradient
    vec3 skyColor = mix(vec3(0.6, 0.7, 0.9), vec3(0.2, 0.4, 0.8), uv.y + 0.5);
    
    // Surface color
    vec3 surfaceColor = vec3(0.8, 0.6, 0.4) * sunLight;
    surfaceColor += vec3(0.2, 0.3, 0.5) * rimLight;
    surfaceColor *= (1.0 - ao * 0.5);
    
    // Fog
    float dist = length(hitPos - eye);
    float fog = 1.0 - exp(-dist * 0.003);
    vec3 color = mix(surfaceColor, skyColor, fog);
    
    // Audio reactive highlights
    color += vec3(0.3, 0.1, 0.0) * kickEnv * (1.0 - fog);
    
    gl_FragColor = vec4(color, 1.0);
}
